<!doctype html>
<html>
        <head>
                <meta name="generator" content="JSDoc 3">
                <meta charset="utf-8">
                <title>Module: qm</title>
                <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Karla:400,400i,700,700i" type="text/css">
                <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Noto+Serif:400,400i,700,700i" type="text/css">
                <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Inconsolata:500" type="text/css">
                <link href="css/baseline.css" rel="stylesheet">
        </head>
        <body onload="prettyPrint()">
                <nav id="jsdoc-navbar" role="navigation" class="jsdoc-navbar">
    <div id="jsdoc-navbar-container">
        <div id="jsdoc-navbar-content">
            <a href="index.html" class="jsdoc-navbar-package-name">Home</a>
        </div>
    </div>
</nav>

                <div id="jsdoc-body-container">
                        <div id="jsdoc-content">
                                <div id="jsdoc-content-container">
                                        <div id="jsdoc-main" role="main">
                    <header class="page-header">
        <h1><div class="symbol-detail-labels"><span class="label label-kind">module</span></div><small></small><span class="symbol-name">qm</span></h1>        <p class="source-link">Source: <a href="qminer_aggrdoc.js.html#source-line-8">qminer_aggrdoc.<wbr>js:8</a></p>
            <div class="symbol-description">
                    <p>Qminer module.</p>

            </div>
                <section>
        <h2>
            Example
        </h2>
                <div>
    <pre class="prettyprint"><code>// import modulevar qm = require(&#x27;qminer&#x27;);</code></pre>
</div>

    </section>

        <dl class="dl-compact">
            
            
            
        </dl>
</header>


    <section id="summary">
                

                    <div class="summary-callout">
            <h2 class="summary-callout-heading">Child classes</h2>
        <div class="summary-content">
                    <div class="summary-column">
        <dl class="dl-summary-callout">
                <dt><a href="module-qm.Base.html">Base(paramObj)</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.CircularRecordBuffer.html">CircularRecordBuffer([param])</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.FeatureSpace.html">FeatureSpace(base, param)</a></dt>
                <dd>
                </dd>
        </dl>
</div>

                    <div class="summary-column">
        <dl class="dl-summary-callout">
                <dt><a href="module-qm.Iterator.html">Iterator()</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.Record.html">Record()</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.RecordSet.html">RecordSet()</a></dt>
                <dd>
                </dd>
        </dl>
</div>

                    <div class="summary-column">
        <dl class="dl-summary-callout">
                <dt><a href="module-qm.Store.html">Store()</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.StreamAggr.html">StreamAggr(base, json[, storeName])</a></dt>
                <dd>
                </dd>
        </dl>
</div>

        </div>
    </div>


                

                    <div class="summary-callout">
            <h2 class="summary-callout-heading">Properties</h2>
        <div class="summary-content">
                    <div class="summary-column">
        <dl class="dl-summary-callout">
                <dt><a href="module-qm.html#.flags">flags</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~BaseModes">BaseModes</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~FeatureMode">FeatureMode</a></dt>
                <dd>
                </dd>
        </dl>
</div>

                    <div class="summary-column">
        <dl class="dl-summary-callout">
                <dt><a href="module-qm.html#~FeatureStream">FeatureStream</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~FeatureTokenizerStemmer">FeatureTokenizerStemmer</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~FeatureTokenizerStopwords">FeatureTokenizerStopwords</a></dt>
                <dd>
                </dd>
        </dl>
</div>

                    <div class="summary-column">
        <dl class="dl-summary-callout">
                <dt><a href="module-qm.html#~FeatureTokenizerType">FeatureTokenizerType</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~FeatureWeight">FeatureWeight</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~FieldTypes">FieldTypes</a></dt>
                <dd>
                </dd>
        </dl>
</div>

        </div>
    </div>


                    <div class="summary-callout">
            <h2 class="summary-callout-heading">Method</h2>
        <div class="summary-content">
                    <div class="summary-column">
        <dl class="dl-summary-callout">
                <dt><a href="module-qm.html#.verbosity">verbosity([level])</a></dt>
                <dd>
                </dd>
        </dl>
</div>

                    <div class="summary-column">
</div>

                    <div class="summary-column">
</div>

        </div>
    </div>


                    <div class="summary-callout">
            <h2 class="summary-callout-heading">Abstract types</h2>
        <div class="summary-content">
                    <div class="summary-column">
        <dl class="dl-summary-callout">
                <dt><a href="module-qm.html#~BaseConstructorParam">BaseConstructorParam</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~BaseLoadCSVParam">BaseLoadCSVParam</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~FeatureExtractorCategorical">FeatureExtractorCategorical</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~FeatureExtractorConstant">FeatureExtractorConstant</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~FeatureExtractorDateWindow">FeatureExtractorDateWindow</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~FeatureExtractorJoin">FeatureExtractorJoin</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~FeatureExtractorJsfunc">FeatureExtractorJsfunc</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~FeatureExtractorMultinomial">FeatureExtractorMultinomial</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~FeatureExtractorNumeric">FeatureExtractorNumeric</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~FeatureExtractorPair">FeatureExtractorPair</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~FeatureExtractorRandom">FeatureExtractorRandom</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~FeatureExtractors">FeatureExtractors</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~FeatureExtractorSparseVector">FeatureExtractorSparseVector</a></dt>
                <dd>
                </dd>
        </dl>
</div>

                    <div class="summary-column">
        <dl class="dl-summary-callout">
                <dt><a href="module-qm.html#~FeatureExtractorText">FeatureExtractorText</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~FeatureSource">FeatureSource</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~FeatureTokenizer">FeatureTokenizer</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~SchemaDefinition">SchemaDefinition</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~SchemaFieldDefinition">SchemaFieldDefinition</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~SchemaJoinDefinition">SchemaJoinDefinition</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~SchemaKeyDefinition">SchemaKeyDefinition</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~SchemaTimeWindowDefinition">SchemaTimeWindowDefinition</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggregateEMA">StreamAggregateEMA</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggregateHistogram">StreamAggregateHistogram</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggregateMax">StreamAggregateMax</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggregateMerger">StreamAggregateMerger</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggregateMin">StreamAggregateMin</a></dt>
                <dd>
                </dd>
        </dl>
</div>

                    <div class="summary-column">
        <dl class="dl-summary-callout">
                <dt><a href="module-qm.html#~StreamAggregateMovingAverage">StreamAggregateMovingAverage</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggregateMovingCorrelation">StreamAggregateMovingCorrelation</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggregateMovingCovariance">StreamAggregateMovingCovariance</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggregateMovingVariance">StreamAggregateMovingVariance</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggregateRecordBuffer">StreamAggregateRecordBuffer</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggregateResampler">StreamAggregateResampler</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggregateSlottedHistogram">StreamAggregateSlottedHistogram</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggregateSum">StreamAggregateSum</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggregateTimeSeriesTick">StreamAggregateTimeSeriesTick</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggregateTimeSeriesWindow">StreamAggregateTimeSeriesWindow</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggregateVecDiff">StreamAggregateVecDiff</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggregators">StreamAggregators</a></dt>
                <dd>
                </dd>
        </dl>
</div>

        </div>
    </div>


                
    </section>







            <section>
                <h2>Classes</h2>
    <section id='members-links'>
            <h3><a href="module-qm.Base.html">Base</a></h3>
            
            
            <h3><a href="module-qm.CircularRecordBuffer.html">CircularRecordBuffer</a></h3>
            
            
            <h3><a href="module-qm.FeatureSpace.html">FeatureSpace</a></h3>
            
            
            <h3><a href="module-qm.Iterator.html">Iterator</a></h3>
            
            
            <h3><a href="module-qm.Record.html">Record</a></h3>
            
            
            <h3><a href="module-qm.RecordSet.html">RecordSet</a></h3>
            
            
            <h3><a href="module-qm.Store.html">Store</a></h3>
            
            
            <h3><a href="module-qm.StreamAggr.html">StreamAggr</a></h3>
            
            
    </section>


            

                <h2>Properties</h2>
    <section>
                <h3 id=".flags"><div class="symbol-detail-labels"><span class="label label-static">static</span></div><span class="symbol-name">flags</span></h3>
    
    
    
        <section>
        <h4>Property</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>flags</p>
        </td>
        <td>
                <p>Object</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>Returns an object with all compile flags</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~BaseModes"><div class="symbol-detail-labels"><span class="label label-inner">inner</span>&nbsp;<span class="label label-readonly">read-only</span></div><span class="symbol-name">BaseModes</span><small class="property-type">
            &nbsp;string</small></h3>
        <p>Base access modes.</p>

    
    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>create</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>sets up the db folder</p>
        </td>
</tr>

                <tr>
        <td>
            <p>createClean</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>cleans the db folder and calls create</p>
        </td>
</tr>

                <tr>
        <td>
            <p>open</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>opens with write permissions</p>
        </td>
</tr>

                <tr>
        <td>
            <p>openReadOnly</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>opens in read-only mode</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~FeatureMode"><div class="symbol-detail-labels"><span class="label label-inner">inner</span>&nbsp;<span class="label label-readonly">read-only</span></div><span class="symbol-name">FeatureMode</span><small class="property-type">
            &nbsp;string</small></h3>
        <p>How are multi-record cases combined into a single vector. //TODO not implemented for join record cases (works only if the start store and the
feature store are the same)</p>

    
    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>concatenate</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>Multi-record cases are merged into one document.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>centroid</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>Treat each case as a separate document.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>tokenized</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>Use the tokenizer option</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~FeatureStream"><div class="symbol-detail-labels"><span class="label label-inner">inner</span>&nbsp;<span class="label label-readonly">read-only</span></div><span class="symbol-name">FeatureStream</span><small class="property-type">
            &nbsp;string</small></h3>
        <p>Details on forgetting old IDFs when running on stream.</p>

    
    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>field</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>(optional) Field name which is providing timestamp, if missing system time is used.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>factor</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>Forgetting factor, by which the old IDFs are multiplied after each iteration.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>interval</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The time between iterations when the factor is applied, standard JSon time format is used to specify the interval duration.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~FeatureTokenizerStemmer"><div class="symbol-detail-labels"><span class="label label-inner">inner</span>&nbsp;<span class="label label-readonly">read-only</span></div><span class="symbol-name">FeatureTokenizerStemmer</span><small class="property-type">
            &nbsp;Object</small></h3>
        <p>The steemer used for extraction.</p>

    
    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>boolean</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>For using the porter stemmer.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>porter</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>For using the porter stemmer.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>none</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>For using no stemmer.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~FeatureTokenizerStopwords"><div class="symbol-detail-labels"><span class="label label-inner">inner</span>&nbsp;<span class="label label-readonly">read-only</span></div><span class="symbol-name">FeatureTokenizerStopwords</span><small class="property-type">
            &nbsp;Object</small></h3>
        <p>THe stopwords used for extraction.</p>

    
    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>none</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The pre-defined stopword list (none).</p>
        </td>
</tr>

                <tr>
        <td>
            <p>en</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The pre-defined stopword list (english).</p>
        </td>
</tr>

                <tr>
        <td>
            <p>si</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The pre-defined stopword list (slovene).</p>
        </td>
</tr>

                <tr>
        <td>
            <p>es</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The pre-defined stopword list (spanish).</p>
        </td>
</tr>

                <tr>
        <td>
            <p>de</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The pre-defined stopword list (german).</p>
        </td>
</tr>

                <tr>
        <td>
            <p>array</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>An array of stopwords. The array must be given as a parameter instead of 'array'!</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~FeatureTokenizerType"><div class="symbol-detail-labels"><span class="label label-inner">inner</span>&nbsp;<span class="label label-readonly">read-only</span></div><span class="symbol-name">FeatureTokenizerType</span><small class="property-type">
            &nbsp;string</small></h3>
        <p>The type of the encoding text.</p>

    
    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>simple</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The simple encoding.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>html</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The html encoding.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>unicode</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The unicode encoding.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~FeatureWeight"><div class="symbol-detail-labels"><span class="label label-inner">inner</span>&nbsp;<span class="label label-readonly">read-only</span></div><span class="symbol-name">FeatureWeight</span><small class="property-type">
            &nbsp;string</small></h3>
        <p>Type of weighting used for scoring terms.</p>

    
    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>none</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>Sets 1 if term occurs, 0 otherwise.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>tf</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>Sets the term frequency in the document.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>idf</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>Sets the inverse document frequency in the document.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>tfidf</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>Sets the product of the tf and idf frequency.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~FieldTypes"><div class="symbol-detail-labels"><span class="label label-inner">inner</span>&nbsp;<span class="label label-readonly">read-only</span></div><span class="symbol-name">FieldTypes</span><small class="property-type">
            &nbsp;string</small></h3>
        <p>Field types.</p>

    
    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>int</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>signed 32-bit integer</p>
        </td>
</tr>

                <tr>
        <td>
            <p>int_v</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>vector of signed 32-bit integers</p>
        </td>
</tr>

                <tr>
        <td>
            <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>string</p>
        </td>
</tr>

                <tr>
        <td>
            <p>string_v</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>vector of strings</p>
        </td>
</tr>

                <tr>
        <td>
            <p>bool</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
</tr>

                <tr>
        <td>
            <p>float</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>double precision floating point number</p>
        </td>
</tr>

                <tr>
        <td>
            <p>float_pair</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>a pair of floats, useful for storing geo coordinates</p>
        </td>
</tr>

                <tr>
        <td>
            <p>float_v</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>vector of floats</p>
        </td>
</tr>

                <tr>
        <td>
            <p>datetime</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>date and time format, stored in a form of milliseconds since 1600</p>
        </td>
</tr>

                <tr>
        <td>
            <p>num_sp_v</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>sparse vector(same format as used by QMiner JavaScript linear algebra library)</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

    </section>


                <h2>Method</h2>
    <section>
                <h3 id=".verbosity"><div class="symbol-detail-labels"><span class="label label-static">static</span></div><span class="symbol-name">verbosity</span><span class="signature"><span class="signature-params">([level])</span></span></h3>
        <p>Set verbosity of QMiner internals.</p>

    
        <section>
        <h4>Parameter</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>level</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>verbosity level: 0 = no output, 1 = log output, 2 = log and debug output.</p>
                <p>Defaults to <code>0</code>.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>

    

    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

    </section>


                <h2>Abstract types</h2>
    <section>
                <h3 id="~BaseConstructorParam"><div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><span class="symbol-name">BaseConstructorParam</span><small class="property-type">
            &nbsp;Object</small></h3>
        <p>Base constructor parameter object</p>

    
    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>BaseConstructorParam.mode</p>
        </td>
        <td>
                <p><a href="module-qm.html#~BaseModes">module:qm~BaseModes</a></p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Base access mode: 
<br> create (sets up the db folder), 
<br> createClean (cleans db folder and then sets it up), 
<br> open (opens the db with read/write permissions), 
<br> openReadOnly (opens the db in read only mode).</p>
                <p>Defaults to <code>'openReadOnly'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>BaseConstructorParam.indexCache</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>The ammount of memory reserved for indexing (in MB).</p>
                <p>Defaults to <code>1024</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>BaseConstructorParam.storeCache</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>The ammount of memory reserved for store cache (in MB).</p>
                <p>Defaults to <code>1024</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>BaseConstructorParam.schemaPath</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>The path to schema definition file.</p>
                <p>Defaults to <code>''</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>BaseConstructorParam.schema</p>
        </td>
        <td>
                <p>Array of <a href="module-qm.html#~SchemaDefinition">module:qm~SchemaDefinition</a></p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Schema definition object array.</p>
                <p>Defaults to <code>[]</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>BaseConstructorParam.dbPath</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>The path to db directory.</p>
                <p>Defaults to <code>'./db/'</code>.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~BaseLoadCSVParam"><div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><span class="symbol-name">BaseLoadCSVParam</span><small class="property-type">
            &nbsp;object</small></h3>
        <p>The parameter given to <a href="module-qm.Base.html#loadCSV">module:qm.Base#loadCSV</a>.</p>

    
    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>BaseLoadCSVParam.file</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the input file.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>BaseLoadCSVParam.store</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>Name of the store which will be created.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>BaseLoadCSVParam.base</p>
        </td>
        <td>
                <p><a href="module-qm.Base.html">module:qm.Base</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>QMiner base object that creates the store.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>BaseLoadCSVParam.delimiter</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Optional delimiter.</p>
                <p>Defaults to <code>','</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>BaseLoadCSVParam.quote</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Optional character to escape values that contain a delimiter.</p>
                <p>Defaults to <code>'"'</code>.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~FeatureExtractorCategorical"><div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><span class="symbol-name">FeatureExtractorCategorical</span><small class="property-type">
            &nbsp;Object</small></h3>
        <p>The feature extractor of type 'categorical'.</p>

        <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>var qm = require(&#x27;qminer&#x27;);// create a simple base, where each record contains the student name and it&#x27;s study group// here we know the student is part of only one study groupvar base = new qm.Base({   mode: &#x27;createClean&#x27;,   schema: [{      name: &quot;Class&quot;,      fields: [         { name: &quot;Name&quot;, type: &quot;string&quot; },         { name: &quot;StudyGroup&quot;, type: &quot;string&quot; }      ]   }]});// create a feature space containing the categorical extractor, where the it&#x27;s values// are taken from the field &quot;StudyGroup&quot;: &quot;A&quot;, &quot;B&quot;, &quot;C&quot; and &quot;D&quot;var ftr = new qm.FeatureSpace(base, { type: &quot;categorical&quot;, source: &quot;Class&quot;, field: &quot;StudyGroup&quot;, values: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;] });base.close();</code></pre>
</div>

    </section>

    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>FeatureExtractorCategorical.type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the extractor. It must be equal <b>'categorical'</b>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorCategorical.values</p>
        </td>
        <td>
                <p>Array of Object</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>A fixed set of values, which form a fixed feature set. No dimensionality changes if new values are seen in the upgrades.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorCategorical.hashDimension</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>A hashing code to set the fixed dimensionality. All values are hashed and divided modulo hasDimension to get the corresponding dimension.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorCategorical.field</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the field form which to take the values.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorCategorical.source</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FeatureSource">module:qm~FeatureSource</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The source of the extractor.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~FeatureExtractorConstant"><div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><span class="symbol-name">FeatureExtractorConstant</span><small class="property-type">
            &nbsp;Object</small></h3>
        <p>The feature extractor of type 'contant'.</p>

        <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>var qm = require(&#x27;qminer&#x27;);// create a simple base, where each record contains only a persons namevar base = new qm.Base({  mode: &#x27;createClean&#x27;,  schema: [{     name: &quot;Person&quot;,     fields: [{ name: &quot;Name&quot;, type: &quot;string&quot; }]  }]});// create a feature space containing the constant extractor, where the constant is equal 5var ftr = new qm.FeatureSpace(base, { type: &quot;constant&quot;, source: &quot;Person&quot;, const: 5 });base.close();</code></pre>
</div>

    </section>

    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>FeatureExtractorConstant.type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the extractor. It must be equal <b>'constant'</b>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorConstant.const</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>A constant number.</p>
                <p>Defaults to <code>1.0</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorConstant.source</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FeatureSource">module:qm~FeatureSource</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The source of the extractor.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~FeatureExtractorDateWindow"><div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><span class="symbol-name">FeatureExtractorDateWindow</span><small class="property-type">
            &nbsp;Object</small></h3>
        <p>The feature extractor of type 'dateWindow'.</p>

        <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import qm modulevar qm = require(&#x27;qminer&#x27;);</code></pre>
</div>

    </section>

    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>FeatureExtractorDateWindow.type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the extractor. It must be equal <b>'dateWindow'</b>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorDateWindow.unit</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>How granular is the time window. The options are: 'day', 'week', 'month', 'year', '12hours', '6hours', '4hours', '2hours',
'hour', '30minutes', '15minutes', '10minutes', 'minute', 'second'.</p>
                <p>Defaults to <code>'day'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorDateWindow.window</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>The size of the window.</p>
                <p>Defaults to <code>1</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorDateWindow.normalize</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Normalize the resulting vector of the extractor to have L2 norm 1.0. //TODO</p>
                <p>Defaults to <code>'false'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorDateWindow.start</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>//TODO</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorDateWindow.end</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>//TODO</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorDateWindow.source</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FeatureSource">module:qm~FeatureSource</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The source of the extractor.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~FeatureExtractorJoin"><div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><span class="symbol-name">FeatureExtractorJoin</span><small class="property-type">
            &nbsp;Object</small></h3>
        <p>The feature extractor of type 'join'.</p>

        <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import qm modulevar qm = require(&#x27;qminer&#x27;);</code></pre>
</div>

    </section>

    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>FeatureExtractorJoin.type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the extractor. It must be equal <b>'join'</b>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorJoin.bucketSize</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>The size of the bucket in which we group consecutive records.</p>
                <p>Defaults to <code>1</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorJoin.source</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FeatureSource">module:qm~FeatureSource</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The source of the extractor.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~FeatureExtractorJsfunc"><div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><span class="symbol-name">FeatureExtractorJsfunc</span><small class="property-type">
            &nbsp;Object</small></h3>
        <p>The feature extractor of type 'jsfunc'.</p>

        <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>var qm = require(&#x27;qminer&#x27;);// create a simple base, where each record contains the name of the student and his study groups// each student is part of multiple study groupsvar base = new qm.Base({   mode: &#x27;createClean&#x27;,   schema: [{      name: &quot;Class&quot;,      fields: [         { name: &quot;Name&quot;, type: &quot;string&quot; },         { name: &quot;StudyGroups&quot;, type: &quot;string_v&quot; }      ]   }]});// create a feature space containing the jsfunc extractor, where the function counts the number// of study groups each student is part of. The functions name is &quot;NumberOFGroups&quot;, it&#x27;s dimension// is 1 (returns only one value, not an array)var ftr = new qm.FeatureSpace(base, {             type: &quot;jsfunc&quot;, source: &quot;Class&quot;, name: &quot;NumberOfGroups&quot;, dim: 1,             fun: function (rec) { return rec.StudyGroups.length; }          });base.close();</code></pre>
</div>

    </section>

    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>FeatureExtractorJsfunc.type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the extractor. It must be equal <b>'jsfunc'</b>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorJsfunc.name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The feature's name.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorJsfunc.fun</p>
        </td>
        <td>
                <p>function()</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The javascript function callback. It should take a record as input and return a number or a dense vector.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorJsfunc.dim</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>The dimension of the feature extractor.</p>
                <p>Defaults to <code>1</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorJsfunc.source</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FeatureSource">module:qm~FeatureSource</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The source of the extractor.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~FeatureExtractorMultinomial"><div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><span class="symbol-name">FeatureExtractorMultinomial</span><small class="property-type">
            &nbsp;Object</small></h3>
        <p>The feature extractor of type 'multinomial'.</p>

        <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>var qm = require(&#x27;qminer&#x27;);// create a simple base, where each record contains the student name and an array of study groups// here we know a student can be part of multiple study groupsvar base = new qm.Base({   mode: &#x27;createClean&#x27;,   schema: [{      name: &quot;Class&quot;,      fields: [         { name: &quot;Name&quot;, type: &quot;string&quot; },         { name: &quot;StudyGroups&quot;, type: &quot;string_v&quot; }      ]   }]});// create a feature space containing the multinomial extractor, where the values are normalized,// and taken from the field &quot;StudyGroup&quot;: &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;var ftr = new qm.FeatureSpace(base, {             type: &quot;multinomial&quot;, source: &quot;Class&quot;, field: &quot;StudyGroups&quot;, normalize: true, values: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;]          });base.close();</code></pre>
</div>

    </section>

    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>FeatureExtractorMultinomial.type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the extractor. It must be equal <b>'multinomial'</b>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorMultinomial.normalize</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Normalize the resulting vector of the extractor to have L2 norm 1.0.</p>
                <p>Defaults to <code>'false'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorMultinomial.values</p>
        </td>
        <td>
                <p>Array of Object</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>A fixed set of values, which form a fixed feature set, no dimensionality changes if new values are seen in the updates. Cannot be used the same time as datetime.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorMultinomial.hashDimension</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>A hashing code to set the fixed dimensionality. All values are hashed and divided modulo hashDimension to get the corresponding dimension.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorMultinomial.datetime</p>
        </td>
        <td>
                <p>Object</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Same as 'values', only with predefined values which are extracted from date and time (month, day of month, day of week, time of day, hour).
<br> This fixes the dimensionality of feature extractor at the start, making it not dimension as new dates are seen. Cannot be used the same time as values.</p>
                <p>Defaults to <code>false</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorMultinomial.field</p>
        </td>
        <td>
                <p>(string or Array of String)</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the field from which to take the key value.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorMultinomial.valueField</p>
        </td>
        <td>
                <p>(string or Array of String)</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>The name of the field from which to take the numeric value. When not provided, 1.0 is used as default numeric values for non-zero elements in the vector.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorMultinomial.source</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FeatureSource">module:qm~FeatureSource</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The source of the extractor.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~FeatureExtractorNumeric"><div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><span class="symbol-name">FeatureExtractorNumeric</span><small class="property-type">
            &nbsp;Object</small></h3>
        <p>The feature extractor of type 'numeric'.</p>

        <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>var qm = require(&#x27;qminer&#x27;);// create a simple base, where each record contains the student name and it&#x27;s gradevar base = new qm.Base({   mode: &#x27;createClean&#x27;,   schema: [{      name: &quot;Class&quot;,      fields: [         { name: &quot;Name&quot;, type: &quot;string&quot; },         { name: &quot;Grade&quot;, type: &quot;int&quot; }      ]   }]});// create a feature space containing the numeric extractor, where the values are// normalized, the values are taken from the field &quot;Grade&quot;var ftr = new qm.FeatureSpace(base, { type: &quot;numeric&quot;, source: &quot;Class&quot;, normalize: true, field: &quot;Grade&quot; });base.close();</code></pre>
</div>

    </section>

    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>FeatureExtractorNumeric.type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the extractor. It must be equal <b>'numeric'</b>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorNumeric.normalize</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Normalize values between 0.0 and 1.0.</p>
                <p>Defaults to <code>'false'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorNumeric.min</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>The minimal value used to form the normalization.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorNumeric.max</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>The maximal value used to form the normalization.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorNumeric.field</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the field from which to take the value.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorNumeric.source</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FeatureSource">module:qm~FeatureSource</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The source of the extractor.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~FeatureExtractorPair"><div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><span class="symbol-name">FeatureExtractorPair</span><small class="property-type">
            &nbsp;Object</small></h3>
        <p>The feature extractor of type 'pair'.</p>

        <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>var qm = require(&#x27;qminer&#x27;);</code></pre>
</div>

    </section>

    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>FeatureExtractorPair.type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the extractor. It must be equal <b>'pair'</b>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorPair.first</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FeatureExtractors">module:qm~FeatureExtractors</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The first feature extractor.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorPair.second</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FeatureExtractors">module:qm~FeatureExtractors</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The second feature extractor.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorPair.source</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FeatureSource">module:qm~FeatureSource</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The source of the extractor.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~FeatureExtractorRandom"><div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><span class="symbol-name">FeatureExtractorRandom</span><small class="property-type">
            &nbsp;Object</small></h3>
        <p>The feature extractor of type 'random'.</p>

        <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>var qm = require(&#x27;qminer&#x27;);// create a simple base, where each record contains only a persons namevar base = new qm.Base({  mode: &#x27;createClean&#x27;,  schema: [{     name: &quot;Person&quot;,     fields: [{ name: &quot;Name&quot;, type: &quot;string&quot; }]  }]});// create a feature space containing the random extractorvar ftr = new qm.FeatureSpace(base, { type: &quot;random&quot;, source: &quot;Person&quot; });base.close();</code></pre>
</div>

    </section>

    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>FeatureExtractorRandom.type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the extractor. It must be equal <b>'random'</b>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorRandom.seed</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>The seed number used to construct the random number.</p>
                <p>Defaults to <code>0</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorRandom.source</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FeatureSource">module:qm~FeatureSource</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The source of the extractor.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~FeatureExtractors"><div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><span class="symbol-name">FeatureExtractors</span><small class="property-type">
            &nbsp;Object</small></h3>
        <p>Feature extractor types.</p>

    
    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>constant</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FeatureExtractorConstant">module:qm~FeatureExtractorConstant</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The constant type.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>random</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FeatureExtractorRandom">module:qm~FeatureExtractorRandom</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The random type.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>numeric</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FeatureExtractorNumeric">module:qm~FeatureExtractorNumeric</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The numeric type.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>categorical</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FeatureExtractorCategorical">module:qm~FeatureExtractorCategorical</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The categorical type.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>multinomial</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FeatureExtractorMultinomial">module:qm~FeatureExtractorMultinomial</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The multinomial type.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>text</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FeatureExtractorText">module:qm~FeatureExtractorText</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The text type.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>join</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FeatureExtractorJoin">module:qm~FeatureExtractorJoin</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The join type.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>pair</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FeatureExtractorPair">module:qm~FeatureExtractorPair</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The pair type.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>jsfunc</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FeatureExtractorJsfunc">module:qm~FeatureExtractorJsfunc</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The jsfunc type.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>dateWindow</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FeatureExtractorDateWindow">module:qm~FeatureExtractorDateWindow</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The date window type.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>sparseVector</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FeatureExtractorSparseVector">module:qm~FeatureExtractorSparseVector</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The sparse vector type.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~FeatureExtractorSparseVector"><div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><span class="symbol-name">FeatureExtractorSparseVector</span><small class="property-type">
            &nbsp;Object</small></h3>
        <p>The feature extractor of type 'num_sp_v'.</p>

        <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>var qm = require(&#x27;qminer&#x27;);// create a simple base, where each record contains the student name and it&#x27;s gradevar base = new qm.Base({   mode: &#x27;createClean&#x27;,   schema: [{      &quot;name&quot;: &quot;Class&quot;,      &quot;fields&quot;: [         { &quot;name&quot;: &quot;Name&quot;, &quot;type&quot;: &quot;string&quot; },         { &quot;name&quot;: &quot;Features&quot;, &quot;type&quot;: &quot;num_sp_v&quot; }      ]   }]});// create a feature space containing the numeric extractor, where the values are// normalized, the values are taken from the field &quot;Grade&quot;var ftr = new qm.FeatureSpace(base, { type: &quot;num_sp_v&quot;, source: &quot;Class&quot;, normalize: false, field: &quot;Features&quot; });base.close();</code></pre>
</div>

    </section>

    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>FeatureExtractorSparseVector.type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the extractor. It must be equal <b>'num_sp_v'</b>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorSparseVector.dimension</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Dimensionality of sparse vectors.</p>
                <p>Defaults to <code>0</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorSparseVector.normalize</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Normalize vectors to L2 norm of 1.0.</p>
                <p>Defaults to <code>false</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorSparseVector.field</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the field from which to take the value.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorSparseVector.source</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FeatureSource">module:qm~FeatureSource</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The source of the extractor.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~FeatureExtractorText"><div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><span class="symbol-name">FeatureExtractorText</span><small class="property-type">
            &nbsp;Object</small></h3>
        <p>The feature extractor of type 'text'.</p>

        <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>var qm = require(&#x27;qminer&#x27;);// create a simple base, where each record contains the title of the article and it&#x27;s contentvar base = new qm.Base({   mode: &#x27;createClean&#x27;,   schema: [{      name: &quot;Articles&quot;,      fields: [         { name: &quot;Title&quot;, type: &quot;string&quot; },         { name: &quot;Text&quot;, type: &quot;string&quot; }      ]   }]});// create a feature spave containing the text (bag of words) extractor, where the values are normalized,// weighted with &#x27;tfidf&#x27; and the tokenizer is of &#x27;simple&#x27; type, it uses english stopwords.var ftr = new qm.FeatureSpace(base, {             type: &quot;text&quot;, source: &quot;Articles&quot;, field: &quot;Text&quot;, normalize: true, weight: &quot;tfidf&quot;,             tokenizer: { type: &quot;simple&quot;, stopwords: &quot;en&quot;}          });base.close();</code></pre>
</div>

    </section>

    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>FeatureExtractorText.type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the extractor. It must be equal <b>'text'</b>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorText.normalize</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Normalize the resulting vector of the extractor to have L2 norm 1.0.</p>
                <p>Defaults to <code>'true'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorText.weight</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FeatureWeight">module:qm~FeatureWeight</a></p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Type of weighting used for scoring terms.</p>
                <p>Defaults to <code>'tfidf'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorText.hashDimension</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>A hashing code to set the fixed dimensionality. All values are hashed and divided modulo hashDimension to get the corresponding dimension.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorText.field</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the field from which to take the value.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorText.tokenizer</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FeatureTokenizer">module:qm~FeatureTokenizer</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The settings for extraction of text.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorText.mode</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FeatureMode">module:qm~FeatureMode</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>How are multi-record cases combined into single vector.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorText.stream</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FeatureStream">module:qm~FeatureStream</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>Details on forgetting old IDFs when running on stream.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureExtractorText.source</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FeatureSource">module:qm~FeatureSource</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The source of the extractor.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~FeatureSource"><div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><span class="symbol-name">FeatureSource</span><small class="property-type">
            &nbsp;Object</small></h3>
        <p>From where are the input records taken.</p>

    
    
        <section>
        <h4>Property</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>FeatureSource.store</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The store name.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~FeatureTokenizer"><div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><span class="symbol-name">FeatureTokenizer</span><small class="property-type">
            &nbsp;Object</small></h3>
        <p>The settings for extraction of text.</p>

    
    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>FeatureTokenizer.type</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FeatureTokenizerType">module:qm~FeatureTokenizerType</a></p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>The type of the encoding text.</p>
                <p>Defaults to <code>'simple'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureTokenizer.stopwords</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FeatureTokenizerStopwords">module:qm~FeatureTokenizerStopwords</a></p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>The stopwords used for extraction.</p>
                <p>Defaults to <code>'en'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureTokenizer.stemmer</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FeatureTokenizerStemmer">module:qm~FeatureTokenizerStemmer</a></p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>The stemmer used for extraction.</p>
                <p>Defaults to <code>'none'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureTokenizer.uppercase</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Changing all words to uppercase.</p>
                <p>Defaults to <code>'true'</code>.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~SchemaDefinition"><div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><span class="symbol-name">SchemaDefinition</span><small class="property-type">
            &nbsp;Object</small></h3>
        <p>Store schema definition object</p>

        <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>var qm = require(&#x27;qminer&#x27;);// create a simple movies store, where each record contains only the movie title.var base = new qm.Base({    mode: &#x27;createClean&#x27;,    schema: [{      name: &quot;Movies&quot;,      fields: [{ name: &quot;title&quot;, type: &quot;string&quot; }]    }]});base.close();</code></pre>
</div>

    </section>

    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>SchemaDefinition.name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store. Store name can be composed by from English letters, numbers, _ or $ characters. It can only begin with a character.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>SchemaDefinition.fields</p>
        </td>
        <td>
                <p>Array of <a href="module-qm.html#~SchemaFieldDefinition">module:qm~SchemaFieldDefinition</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The array of field descriptors.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>SchemaDefinition.joins</p>
        </td>
        <td>
                <p>Array of <a href="module-qm.html#~SchemaJoinDefinition">module:qm~SchemaJoinDefinition</a></p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>The array of join descriptors, used for linking records from different stores.</p>
                <p>Defaults to <code>[]</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>SchemaDefinition.keys</p>
        </td>
        <td>
                <p>Array of <a href="module-qm.html#~SchemaKeyDefinition">module:qm~SchemaKeyDefinition</a></p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>The array of key descriptors. Keys define how records are indexed, which is needed for search using the query language.</p>
                <p>Defaults to <code>[]</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>SchemaDefinition.timeWindow</p>
        </td>
        <td>
                <p><a href="module-qm.html#~SchemaTimeWindowDefinition">module:qm~SchemaTimeWindowDefinition</a></p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Time window description. Stores can have a window, which is used by garbage collector to delete records once they fall out of the time window. Window can be defined by number of records or by time.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~SchemaFieldDefinition"><div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><span class="symbol-name">SchemaFieldDefinition</span><small class="property-type">
            &nbsp;Object</small></h3>
        <p>Store schema field definition object</p>

        <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>var qm = require(&#x27;qminer&#x27;); var base = new qm.Base({     mode: &#x27;createClean&#x27;,     schema: [       { name: &#x27;NewsArticles&#x27;,         fields: [           { name: &quot;ID&quot;, primary: true, type: &quot;string&quot;, shortstring: true },           { name: &quot;Source&quot;, type: &quot;string&quot;, codebook: true },           { name: &quot;DateTime&quot;, type: &quot;datetime&quot; },           { name: &quot;Title&quot;, type: &quot;string&quot;, store: &quot;cache&quot; },           { name: &quot;Tokens&quot;, type: &quot;string_v&quot;, store: &quot;cache&quot;, null: true },           { name: &quot;Vector&quot;, type: &quot;num_sp_v&quot;, store: &quot;cache&quot;, null: true }]       }    ] });// add a record:// - we set the date using the ISO string representation// - we set the string vector Tokens with an array of strings// - we set the numeric sparse vector Vector with an array of two element arrays//   (index, value), see the sparse vector constructor {@link module:la.SparseVector}base.store(&#x27;NewsArticles&#x27;).push({  ID: &#x27;t12344&#x27;,   Source: &#x27;s1234&#x27;,   DateTime: &#x27;2015-01-01T00:05:00&#x27;,   Title: &#x27;the title&#x27;,   Tokens: [&#x27;token1&#x27;, &#x27;token2&#x27;],   Vector: [[0,1], [1,1]]});base.close();</code></pre>
</div>

    </section>

    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>SchemaFieldDefinition.name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the field.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>SchemaFieldDefinition.type</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FieldTypes">module:qm~FieldTypes</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the field.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>SchemaFieldDefinition.primary</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Field which can be used to identify record. There can be only one primary field in a store. There can be at most one record for each value of the primary field. Currently following fields can be marked as primary: int, uin64, string, float, datetime. Primary fields of type string are also used for record names.</p>
                <p>Defaults to <code>false</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>SchemaFieldDefinition.null</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>When set to true, null is a possible value for a field (allow missing values).</p>
                <p>Defaults to <code>false</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>SchemaFieldDefinition.store</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Defines where to store the field, options are: <b>'cache'</b> or <b>'memory'</b>. The default option is <b>'memory'</b>, which stores the values in RAM. Option <b>'cache'</b> stores the values on disk, with a layer of FIFO cache in RAM, storing the most recently used values.</p>
                <p>Defaults to <code>'memory'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>SchemaFieldDefinition.default</p>
        </td>
        <td>
                <p>Object</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Default value for field when not given for a new record.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>SchemaFieldDefinition.codebook</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Useful when many records have only few different values of this field. If set to true, then a separate table of all values is kept, and records only point to this table (replacing variable string field in record serialisation with fixed-length integer). Useful to decrease memory footprint, and faster to update. (STRING FIELD TYPE SPECIFIC).</p>
                <p>Defaults to <code>false</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>SchemaFieldDefinition.shortstring</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Useful for string shorter then 127 characters (STRING FIELD TYPE SPECIFIC).</p>
                <p>Defaults to <code>false</code>.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~SchemaJoinDefinition"><div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><span class="symbol-name">SchemaJoinDefinition</span><small class="property-type">
            &nbsp;Object</small></h3>
        <p>Store schema join definition object</p>

        <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>var qm = require(&#x27;qminer&#x27;);// Create two stores: People which stores only names of persons and Movies, which stores only titles.// Each person can direct zero or more movies, so we use an index join named &#x27;directed&#x27; and// each movie has a single director, so we use a field join &#x27;director&#x27;. The joins are // inverses of each other. The inverse join simplifies the linking, since only one join needs// to be specified, and the other direction can be linked automatically (in the example // below we specify only the &#x27;director&#x27; link and the &#x27;directed&#x27; join is updated automatically).//var base = new qm.Base({    mode: &#x27;createClean&#x27;,    schema: [      { name: &#x27;People&#x27;,         fields: [{ name: &#x27;name&#x27;, type: &#x27;string&#x27;, primary: true }],         joins: [{ name: &#x27;directed&#x27;, &#x27;type&#x27;: &#x27;index&#x27;, &#x27;store&#x27;: &#x27;Movies&#x27;, &#x27;inverse&#x27;: &#x27;director&#x27; }] },      { name: &#x27;Movies&#x27;,         fields: [{ name: &#x27;title&#x27;, type: &#x27;string&#x27;, primary: true }],         joins: [{ name: &#x27;director&#x27;, &#x27;type&#x27;: &#x27;field&#x27;, &#x27;store&#x27;: &#x27;People&#x27;, &#x27;inverse&#x27;: &#x27;directed&#x27; }] }    ]});// Adds a movie, automatically adds &#x27;Jim Jarmusch&#x27; to People, sets the &#x27;director&#x27; join (field join)// and automatically updates the index join &#x27;directed&#x27;, since it&#x27;s an inverse join of &#x27;director&#x27;base.store(&#x27;Movies&#x27;).push({ title: &#x27;Broken Flowers&#x27;, director: { name: &#x27;Jim Jarmusch&#x27; } });// Adds a movie, sets the &#x27;director&#x27; join, updates the index join of &#x27;Jim Jarmusch&#x27;base.store(&#x27;Movies&#x27;).push({ title: &#x27;Coffee and Cigarettes&#x27;, director: { name: &#x27;Jim Jarmusch&#x27; } });// Adds movie, automatically adds &#x27;Lars von Trier&#x27; to People, sets the &#x27;director&#x27; join// and &#x27;directed&#x27; inverse join (automatically)base.store(&#x27;Movies&#x27;).push({ title: &#x27;Dogville&#x27;, director: { name: &#x27;Lars von Trier&#x27; } });var movie = base.store(&#x27;Movies&#x27;)[0]; // get the first movie (Broken Flowers)// Each movie has a property corresponding to the join name: &#x27;director&#x27;. // Accessing the property returns a {@link module:qm.Record} from the store People.var person = movie.director; // get the directorvar personName = person.name; // get person&#x27;s name (&#x27;Jim Jarmusch&#x27;)// Each person has a property corresponding to the join name: &#x27;directed&#x27;. // Accessing the property returns a {@link module:qm.RecSet} from the store People.var movies = person.directed; // get all the movies the person directed.movies.each(function (movie) { var title = movie.title; });// Gets the following titles://   &#x27;Broken Flowers&#x27;//   &#x27;Coffee and Cigarettes&#x27;base.close();</code></pre>
</div>

    </section>

    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>SchemaJoinDefinition.name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the join.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>SchemaJoinDefinition.type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The supported types are: <b>'field'</b> and <b>'index'</b>. 
<br> A join with type=<b>'field'</b> can point to zero or one record and is implemented as an additional hidden field of type uint64, which can hold the ID of the record it links to. Accessing the record's join returns a record.
<br> A join with type=<b>'index'</b> can point to any number of records and is implemented using the inverted index, where for each record a list (vector) of linked records is kept. Accessing the record's join returns a record set.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>SchemaJoinDefinition.store</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The store name from which the linked records are.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~SchemaKeyDefinition"><div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><span class="symbol-name">SchemaKeyDefinition</span><small class="property-type">
            &nbsp;Object</small></h3>
        <p>Store schema key definition object</p>

        <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>var qm = require(&#x27;qminer&#x27;);// Create a store People which stores only names of persons.var base = new qm.Base({    mode: &#x27;createClean&#x27;,    schema: [        { name: &#x27;People&#x27;,          fields: [{ name: &#x27;name&#x27;, type: &#x27;string&#x27;, primary: true }],          keys: [            { field: &#x27;name&#x27;, type: &#x27;value&#x27;},             { field: &#x27;name&#x27;, name: &#x27;nameText&#x27;, type: &#x27;text&#x27;}         ]       }    ]});base.store(&#x27;People&#x27;).push({name : &#x27;John Smith&#x27;});base.store(&#x27;People&#x27;).push({name : &#x27;Mary Smith&#x27;});// search based on indexed valuesbase.search({$from : &#x27;People&#x27;, name: &#x27;John Smith&#x27;}); // Return the record set containing &#x27;John Smith&#x27;// search based on indexed valuesbase.search({$from : &#x27;People&#x27;, name: &#x27;Smith&#x27;}); // Returns the empty record set.// search based on text indexingbase.search({$from : &#x27;People&#x27;, nameText: &#x27;Smith&#x27;}); // Returns both records.base.close();</code></pre>
</div>

    </section>

    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>SchemaKeyDefinition.field</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the field that will be indexed.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>SchemaKeyDefinition.type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The supported types are: <b>'value'</b>, <b>'text'</b> and <b>'location'</b>.
<br> A key with type=<b>'value'</b> indexes records using an inverted index using full value of the field (no processing).
 The key type supports 'string', 'string_v' and 'datetime' fields types.
<br> A key with type=<b>'text'</b> indexes string fields by using a tokenizer and text processing. Supported by string fields.
<br> A key with type=<b>'location'</b> indexes records as points on a sphere and enables nearest-neighbour queries. Supported by float_pair type fields.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>SchemaKeyDefinition.name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Allows using a different name for the key in search queries. This allows for multiple keys to be put against the same field. Default value is the name of the field.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>SchemaKeyDefinition.vocabulary</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>defines the name of the vocabulary used to store the tokens or values. This can be used indicate to several keys to use the same vocabulary, to save on memory. Supported by 'value' and 'text' keys.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>SchemaKeyDefinition.tokenize</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>defines the tokenizer that is used for tokenizing the values stored in indexed fields. Tokenizer uses same parameters as in bag-of-words feature extractor. Default is english stopword list and no stemmer. Supported by 'text' keys.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~SchemaTimeWindowDefinition"><div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><span class="symbol-name">SchemaTimeWindowDefinition</span><small class="property-type">
            &nbsp;Object</small></h3>
        <p>Stores can have a window, which is used by garbage collector to delete records once they
fall out of the time window. Window can be defined by number of records or by time.
Window defined by parameter window, its value being the number of records to be kept.
<br><b>Important:</b> <a href="module-qm.Base.html#garbageCollect">module:qm.Base#garbageCollect</a> must be called manually to remove records outside time window.</p>

        <section>
        <h4>
            Examples
        </h4>
                <div>
        <p>Define window by number of records</p>
    <pre class="prettyprint"><code>var qm = require(&#x27;qminer&#x27;);// create basevar base = new qm.Base({ mode: &#x27;createClean&#x27; });// create store with windowbase.createStore({    &quot;name&quot;: &quot;TestStore&quot;,    &quot;fields&quot;: [        { &quot;name&quot;: &quot;DateTime&quot;, &quot;type&quot;: &quot;datetime&quot; },        { &quot;name&quot;: &quot;Measurement&quot;, &quot;type&quot;: &quot;float&quot; }    ],    window: 3,});// push 5 records into created storefor (var i = 0; i &lt; 5; i++) {    var rec = {        &quot;DateTime&quot;: new Date().toISOString(),        &quot;Measurement&quot;: i    };    base.store(&quot;TestStore&quot;).push(rec);}// check number of records in storeconsole.log(base.store(&quot;TestStore&quot;).allRecords.length); // 5// clean base with garbage collectorbase.garbageCollect();// check number of records in storeconsole.log(base.store(&quot;TestStore&quot;).allRecords.length); // 3base.close();</code></pre>
</div>

                <div>
        <p>Define window by time</p>
    <pre class="prettyprint"><code>var qm = require(&#x27;qminer&#x27;);// create basevar base = new qm.Base({ mode: &#x27;createClean&#x27; });// create store with windowbase.createStore({    &quot;name&quot;: &quot;TestStore&quot;,    &quot;fields&quot;: [        { &quot;name&quot;: &quot;DateTime&quot;, &quot;type&quot;: &quot;datetime&quot; },        { &quot;name&quot;: &quot;Measurement&quot;, &quot;type&quot;: &quot;float&quot; }    ],    timeWindow: {        duration: 2,        unit: &quot;hour&quot;,        field: &quot;DateTime&quot;    }});// push 5 records into created storefor (var i = 0; i &lt; 5; i++) {    var rec = {        &quot;DateTime&quot;: new Date(new Date().getTime() + i * 60 * 60 * 1001).toISOString(),        &quot;Measurement&quot;: i    };    base.store(&quot;TestStore&quot;).push(rec);}// check number of records in storeconsole.log(base.store(&quot;TestStore&quot;).allRecords.length); // 5// clean base with garbage collectorbase.garbageCollect();// check number of records in storeconsole.log(base.store(&quot;TestStore&quot;).allRecords.length); // 2base.close();</code></pre>
</div>

    </section>

    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>SchemaTimeWindowDefinition.duration</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>the size of the time window (in number of units).</p>
        </td>
</tr>

                <tr>
        <td>
            <p>SchemaTimeWindowDefinition.unit</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>defines in which units the window size is specified. Possible values are <b>second</b>, <b>minute</b>, <b>hour</b>, <b>day</b>, <b>week</b> or <b>month</b>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>SchemaTimeWindowDefinition.field</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>name of the datetime filed, which defines the time of the record. In case it is not given, the insert time is used in its place.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~StreamAggregateEMA"><div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><span class="symbol-name">StreamAggregateEMA</span><small class="property-type">
            &nbsp;module:qmStreamAggr</small></h3>
        <p>This stream aggregator represents the exponential moving average window buffer. It calculates the weighted moving average 
of the values in the connected stream aggregator, where the weights are exponentially decreasing.  It implements the following methods:
<br><a href="module-qm.StreamAggr.html#getFloat">module:qm.StreamAggr#getFloat</a> returns the exponentional average of the values in it's buffer window.
<br><a href="module-qm.StreamAggr.html#getTimestamp">module:qm.StreamAggr#getTimestamp</a> returns the timestamp of the newest record in it's buffer window.</p>

        <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import the qm modulevar qm = require(&#x27;qminer&#x27;);// create a base with a simple storevar base = new qm.Base({   mode: &quot;createClean&quot;,   schema: [   {       name: &quot;Heat&quot;,       fields: [           { name: &quot;Celcius&quot;, type: &quot;float&quot; },           { name: &quot;Time&quot;, type: &quot;datetime&quot; }       ]   }]});// create a new time series tick stream aggregator for the &#x27;Heat&#x27; store, that takes the values from the &#x27;Celcius&#x27; field// and the timestamp from the &#x27;Time&#x27; field. The size of the window should be 1 hour.var timeser = {   name: &#x27;TimeSeriesAggr&#x27;,   type: &#x27;timeSeriesTick&#x27;,   store: &#x27;Heat&#x27;,   timestamp: &#x27;Time&#x27;,   value: &#x27;Celcius&#x27;,   winsize: 3600000};var timeSeries = base.store(&quot;Heat&quot;).addStreamAggr(timeser);// add an exponentional moving average aggregator, that is connected with the &#x27;TimeSeriesAggr&#x27; aggregator.// It should interpolate with the previous value, the decay should be 3 seconds and the initWindow should be 2 seconds.var ema = {   name: &#x27;emaAggr&#x27;,   type: &#x27;ema&#x27;,   store: &#x27;Heat&#x27;,   inAggr: &#x27;TimeSeriesAggr&#x27;,   emaType: &#x27;previous&#x27;,   interval: 3000,   initWindow: 2000};var expoMovingAverage = base.store(&quot;Heat&quot;).addStreamAggr(ema);base.close();</code></pre>
</div>

    </section>

    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>StreamAggregateEMA.name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The given name for the stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateEMA.type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the stream aggregator. It must be equal to <b>'ema'</b>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateEMA.store</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store from which it takes the data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateEMA.inAggr</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the stream aggregator to which it connects and gets data. 
It <b>cannot</b> connect to the module:qm~StreamAggr_TimeSeriesWindow.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateEMA.emaType</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of interpolation. The choices are 'previous', 'linear' and 'next'.
<br> Type 'previous' interpolates with the previous value. 
<br> Type 'next' interpolates with the next value.
<br> Type 'linear' makes a linear interpolation.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateEMA.interval</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The time interval defining the decay. It must be greater than initWindow.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateEMA.initWindow</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The time window of required values for initialization.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~StreamAggregateHistogram"><div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><span class="symbol-name">StreamAggregateHistogram</span><small class="property-type">
            &nbsp;<a href="module-qm.StreamAggr.html">module:qm.StreamAggr</a></small></h3>
        <p>This stream aggregator represents an online histogram. It can connect to a buffered aggregate (such as <a href="module-qm.html#~StreamAggregateTimeSeriesWindow">module:qm~StreamAggregateTimeSeriesWindow</a>)
or a time series (such as <a href="module-qm.html#~StreamAggregateEMA">module:qm~StreamAggregateEMA</a>).
The aggregate defines an ordered set of points p(0), ..., p(n) that define n bins. Infinites at both ends are allowed.
A new measurement is tested for inclusion in the left-closed right-opened intervals [p(i), p(i+1)) and the corresponding
bin counter is increased for the appropriate bin (or decreased if the point is outgoing from the buffer).
It implements the following methods:
<br><a href="module-qm.StreamAggr.html#getFloatLength">module:qm.StreamAggr#getFloatLength</a> returns the number of bins.
<br><a href="module-qm.StreamAggr.html#getFloatAt">module:qm.StreamAggr#getFloatAt</a> returns the count for a bin index.
<br><a href="module-qm.StreamAggr.html#getFloatVector">module:qm.StreamAggr#getFloatVector</a> returns the vector of counts, the length is equal to the number of bins.</p>

        <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import the qm modulevar qm = require(&#x27;qminer&#x27;);// create a base with a simple storevar base = new qm.Base({   mode: &quot;createClean&quot;,   schema: [   {       name: &quot;Heat&quot;,       fields: [           { name: &quot;Celcius&quot;, type: &quot;float&quot; },           { name: &quot;Time&quot;, type: &quot;datetime&quot; }       ]   }]});// create a new time series stream aggregator for the &#x27;Heat&#x27; store, that takes the values from the &#x27;Celcius&#x27; field// and the timestamp from the &#x27;Time&#x27; field. The size of the window is 1 day.var timeser = {   name: &#x27;TimeSeriesBuffer&#x27;,   type: &#x27;timeSeriesWinBuf&#x27;,   store: &#x27;Heat&#x27;,   timestamp: &#x27;Time&#x27;,   value: &#x27;Celcius&#x27;,   winsize: 86400000 // one day in miliseconds};var timeSeries = base.store(&quot;Heat&quot;).addStreamAggr(timeser);// add a histogram aggregator, that is connected with the &#x27;TimeSeriesAggr&#x27; aggregatorvar aggrJson = {   name: &#x27;Histogram&#x27;,   type: &#x27;onlineHistogram&#x27;,   store: &#x27;Heat&#x27;,   inAggr: &#x27;TimeSeriesBuffer&#x27;,   lowerBound: 0,   upperBound: 10,   bins: 5,   addNegInf: false,   addPosInf: false};var hist = base.store(&quot;Heat&quot;).addStreamAggr(aggrJson);base.close();</code></pre>
</div>

    </section>

    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The given name of the stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type for the stream aggregator. It must be equal to <b>'onlineHistogram'</b>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>store</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store from which it takes the data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>inAggr</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the stream aggregator to which it connects and gets data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>lowerBound</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The lowest non-infinite bin point.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>upperBound</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The highest non-infinite bin point.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>bins</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>The number of bins bounded by <code>lowerBound</code> and <code>upperBound</code>.</p>
                <p>Defaults to <code>5</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>addNegInf</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Include a bin [-Inf, lowerBound].</p>
                <p>Defaults to <code>false</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>addPosInf</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Include a bin [upperBound, Inf].</p>
                <p>Defaults to <code>false</code>.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~StreamAggregateMax"><div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><span class="symbol-name">StreamAggregateMax</span><small class="property-type">
            &nbsp;<a href="module-qm.StreamAggr.html">module:qm.StreamAggr</a></small></h3>
        <p>This stream aggregator represents the maximum moving window buffer. It monitors the maximal value in the connected stream aggregator. 
It implements the following methods:
<br><a href="module-qm.StreamAggr.html#getFloat">module:qm.StreamAggr#getFloat</a> returns the maximal value of the records in the it's buffer window.
<br><a href="module-qm.StreamAggr.html#getTimestamp">module:qm.StreamAggr#getTimestamp</a> returns the timestamp of the newest record in it's buffer window.</p>

        <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import the qm modulevar qm = require(&#x27;qminer&#x27;);// create a base with a simple storevar base = new qm.Base({   mode: &quot;createClean&quot;,   schema: [   {       name: &quot;Heat&quot;,       fields: [           { name: &quot;Celcius&quot;, type: &quot;float&quot; },           { name: &quot;Time&quot;, type: &quot;datetime&quot; }       ]   }]});// create a new time series stream aggregator for the &#x27;Heat&#x27; store, that takes the values from the &#x27;Celcius&#x27; field// and the timestamp from the &#x27;Time&#x27; field. The size of the window is 1 day.var timeser = {   name: &#x27;TimeSeriesAggr&#x27;,   type: &#x27;timeSeriesWinBuf&#x27;,   store: &#x27;Heat&#x27;,   timestamp: &#x27;Time&#x27;,   value: &#x27;Celcius&#x27;,   winsize: 86400000 // one day in miliseconds};var timeSeries = base.store(&quot;Heat&quot;).addStreamAggr(timeser);// add a max aggregator, that is connected with the &#x27;TimeSeriesAggr&#x27; aggregatorvar max = {   name: &#x27;MaxAggr&#x27;,   type: &#x27;winBufMax&#x27;,   store: &#x27;Heat&#x27;,   inAggr: &#x27;TimeSeriesAggr&#x27;};var maximal = base.store(&quot;Heat&quot;).addStreamAggr(max);base.close();</code></pre>
</div>

    </section>

    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>StreamAggregateMax.name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The given name of the stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateMax.type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type for the stream aggregator. It must be equal to <b>'winBufMax'</b>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateMax.store</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store from which it takes the data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateMax.inAggr</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the stream aggregator to which it connects and gets data.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~StreamAggregateMerger"><div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><span class="symbol-name">StreamAggregateMerger</span><small class="property-type">
            &nbsp;<a href="module-qm.StreamAggr.html">module:qm.StreamAggr</a></small></h3>
        <p>This stream aggregator represents the merger aggregator. It merges records from two or more stores into a new store
depending on the timestamp. No methods are implemented for this aggregator.</p>
<image src="pictures/merger.gif" alt="Merger Animation">

        <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import the qm modulevar qm = require(&#x27;qminer&#x27;);// create a base with a simple storevar base = new qm.Base({   mode: &quot;createClean&quot;,   schema: [   {       name: &quot;Cars&quot;,       fields: [           { name: &quot;NumberOfCars&quot;, type: &quot;float&quot; },           { name: &quot;Time&quot;, type: &quot;datetime&quot; }       ]   },   {       name: &quot;Temperature&quot;,       fields: [           { name: &quot;Celcius&quot;, type: &quot;float&quot; },           { name: &quot;Time&quot;, type: &quot;datetime&quot; }       ]   },   {       name: &quot;Merged&quot;,       fields: [           { name: &quot;NumberOfCars&quot;, type: &quot;float&quot; },           { name: &quot;Celcius&quot;, type: &quot;float&quot; },           { name: &quot;Time&quot;, type: &quot;datetime&quot; }       ]   }]});// create a new merger stream aggregator that mergers the records of the &#x27;Cars&#x27; and &#x27;Temperature&#x27; stores.// The records are interpolated linearly and stored in the &#x27;Merged&#x27; store.var mer = {   name: &#x27;MergerAggr&#x27;,   type: &#x27;stmerger&#x27;,   outStore: &#x27;Merged&#x27;,   createStore: false,   timestamp: &#x27;Time&#x27;,   fields: [       { source: &#x27;Cars&#x27;, inField: &#x27;NumberOfCars&#x27;, outField: &#x27;NumberOfCars&#x27;, interpolation: &#x27;linear&#x27;, timestamp: &#x27;Time&#x27; },       { source: &#x27;Temperature&#x27;, inField: &#x27;Celcius&#x27;, outField: &#x27;Celcius&#x27;, interpolation: &#x27;linear&#x27;, timestamp: &#x27;Time&#x27; }   ]};var merger = new qm.StreamAggr(base, mer);base.close();</code></pre>
</div>

    </section>

    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>StreamAggregateMerger.name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The given name for the stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateMerger.type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the stream aggregator. It must be equal to <b>'stmerger'</b>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateMerger.outStore</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store where it saves the merged records.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateMerger.createStore</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>If the outStore must be created.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateMerger.timestamp</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The store field of outStore, where the timestamp is saved.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateMerger.fields</p>
        </td>
        <td>
                <p>Array of Object</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>An array of json objects. The json objects contain:
<br> source (string) - The name of the store, from which it takes the values.
<br> inField (string) - The field name of source, from which it takes the values.
<br> outField (string) - The field name of outStore, into which it saves the values.
<br> interpolation (string) - The type of the interpolation. The options are: 'previous', 'next' and 'linear'.
<br> timestamp (string) - The field name of source, where the timestamp is saved.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~StreamAggregateMin"><div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><span class="symbol-name">StreamAggregateMin</span><small class="property-type">
            &nbsp;<a href="module-qm.StreamAggr.html">module:qm.StreamAggr</a></small></h3>
        <p>This stream aggregator represents the minimum moving window buffer. It monitors the minimal value in the connected stream aggregator.
It implements the following methods:
<br><a href="module-qm.StreamAggr.html#getFloat">module:qm.StreamAggr#getFloat</a> returns the minimal value of the records in it's buffer window.
<br><a href="module-qm.StreamAggr.html#getTimestamp">module:qm.StreamAggr#getTimestamp</a> returns the timestamp of the newest record in it's buffer window.</p>

        <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import the qm modulevar qm = require(&#x27;qminer&#x27;);// create a base with a simple storevar base = new qm.Base({   mode: &quot;createClean&quot;,   schema: [   {       name: &quot;Heat&quot;,       fields: [           { name: &quot;Celcius&quot;, type: &quot;float&quot; },           { name: &quot;Time&quot;, type: &quot;datetime&quot; }       ]   }]});// create a new time series stream aggregator for the &#x27;Heat&#x27; store, that takes the values from the &#x27;Celcius&#x27; field// and the timestamp from the &#x27;Time&#x27; field. The size of the window is 1 day.var timeser = {   name: &#x27;TimeSeriesAggr&#x27;,   type: &#x27;timeSeriesWinBuf&#x27;,   store: &#x27;Heat&#x27;,   timestamp: &#x27;Time&#x27;,   value: &#x27;Celcius&#x27;,   winsize: 86400000 // 1 day in miliseconds};var timeSeries = base.store(&quot;Heat&quot;).addStreamAggr(timeser);// add a min aggregator, that is connected with the &#x27;TimeSeriesAggr&#x27; aggregatorvar min = {   name: &#x27;MinAggr&#x27;,   type: &#x27;winBufMin&#x27;,   store: &#x27;Heat&#x27;,   inAggr: &#x27;TimeSeriesAggr&#x27;};var minimal = base.store(&quot;Heat&quot;).addStreamAggr(min);base.close();</code></pre>
</div>

    </section>

    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>StreamAggregateMin.name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The given name of the stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateMin.type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the stream aggregator. It must be equal to <b>'winBufMin'</b>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateMin.store</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store from which it takes the data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateMin.inAggr</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the stream aggregator to which it connects and gets data.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~StreamAggregateMovingAverage"><div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><span class="symbol-name">StreamAggregateMovingAverage</span><small class="property-type">
            &nbsp;module:qmStreamAggr</small></h3>
        <p>This stream aggregator represents the moving average window buffer. It calculates the moving average value of the connected stream aggregator values.
It implements the following methods:
<br><a href="module-qm.StreamAggr.html#getFloat">module:qm.StreamAggr#getFloat</a> returns the average of the values in it's buffer window.
<br><a href="module-qm.StreamAggr.html#getTimestamp">module:qm.StreamAggr#getTimestamp</a> returns the timestamp of the newest record in it's buffer window.</p>

        <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import the qm modulevar qm = require(&#x27;qminer&#x27;);// create a base with a simple storevar base = new qm.Base({   mode: &quot;createClean&quot;,   schema: [   {       name: &quot;Heat&quot;,       fields: [           { name: &quot;Celcius&quot;, type: &quot;float&quot; },           { name: &quot;Time&quot;, type: &quot;datetime&quot; }       ]   }]});// create a new time series stream aggregator for the &#x27;Heat&#x27; store, that takes the values from the &#x27;Celcius&#x27; field// and the timestamp from the &#x27;Time&#x27; field. The size of the window should be 1 day.var timeser = {   name: &#x27;TimeSeriesAggr&#x27;,   type: &#x27;timeSeriesWinBuf&#x27;,   store: &#x27;Heat&#x27;,   timestamp: &#x27;Time&#x27;,   value: &#x27;Celcius&#x27;,   winsize: 86400000};var timeSeries = base.store(&quot;Heat&quot;).addStreamAggr(timeser);// add a moving average aggregator, that is connected with the &#x27;TimeSeriesAggr&#x27; aggregatorvar ma = {   name: &#x27;movingAverageAggr&#x27;,   type: &#x27;ma&#x27;,   store: &#x27;Heat&#x27;,   inAggr: &#x27;TimeSeriesAggr&#x27;};var movingAverage = base.store(&quot;Heat&quot;).addStreamAggr(ma);base.close();</code></pre>
</div>

    </section>

    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>StreamAggregateMovingAverage.name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The given name of the stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateMovingAverage.type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the stream aggregator. It must be equal to <b>'ma'</b>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateMovingAverage.store</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store from which it takes the data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateMovingAverage.inAggr</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the stream aggregator to which it connects and gets data.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~StreamAggregateMovingCorrelation"><div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><span class="symbol-name">StreamAggregateMovingCorrelation</span><small class="property-type">
            &nbsp;<a href="module-qm.StreamAggr.html">module:qm.StreamAggr</a></small></h3>
        <p>This stream aggregator represents the moving covariance window buffer. It calculates the moving correlation of the three stream aggregators,
that it's connected to. It implements the following methods:
<br><a href="module-qm.StreamAggr.html#getFloat">module:qm.StreamAggr#getFloat</a> returns the correlation of the values in it's buffer window.
<br><a href="module-qm.StreamAggr.html#getTimestamp">module:qm.StreamAggr#getTimestamp</a> returns the timestamp of the newest record in it's buffer window.</p>

        <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import the qm modulevar qm = require(&#x27;qminer&#x27;);// create a base with a simple storevar base = new qm.Base({   mode: &quot;createClean&quot;,   schema: [   {       name: &quot;Heat&quot;,       fields: [           { name: &quot;Celcius&quot;, type: &quot;float&quot; },           { name: &quot;WaterConsumption&quot;, type: &quot;float&quot; },           { name: &quot;Time&quot;, type: &quot;datetime&quot; }       ]   }]});// create a new time series stream aggregator for the &#x27;Heat&#x27; store, that takes the values from the &#x27;Celcius&#x27; field// and the timestamp from the &#x27;Time&#x27; field. The size of the window is 1 day.var celcius = {   name: &#x27;CelciusAggr&#x27;,   type: &#x27;timeSeriesWinBuf&#x27;,   store: &#x27;Heat&#x27;,   timestamp: &#x27;Time&#x27;,   value: &#x27;Celcius&#x27;,   winsize: 86400000}; base.store(&quot;Heat&quot;).addStreamAggr(celcius);// create a new time series stream aggregator for the &#x27;Heat&#x27; store, that takes the values from the &#x27;WaterConsumption&#x27; field// and the timestamp from the &#x27;Time&#x27; field. The size of the window is 1 day.var water = {   name: &#x27;WaterAggr&#x27;,   type: &#x27;timeSeriesWinBuf&#x27;,   store: &#x27;Heat&#x27;,   timestamp: &#x27;Time&#x27;,   value: &#x27;WaterConsumption&#x27;,   winsize: 86400000}; base.store(&quot;Heat&quot;).addStreamAggr(water);// add a covariance aggregator, that is connected with the &#x27;CelciusAggr&#x27; and &#x27;WaterAggr&#x27; aggregatorsvar covariance = {   name: &#x27;covarianceAggr&#x27;,   type: &#x27;covariance&#x27;,   store: &#x27;Heat&#x27;,   inAggrX: &#x27;CelciusAggr&#x27;,   inAggrY: &#x27;WaterAggr&#x27;}; base.store(&quot;Heat&quot;).addStreamAggr(covariance);// add the two variance aggregators, that take from the &#x27;Celcius&#x27; and &#x27;WaterConsumption&#x27; fields, respectively.var celVar = {   name: &#x27;celciusVarAggr&#x27;,   type: &#x27;variance&#x27;,   store: &#x27;Heat&#x27;,   inAggr: &#x27;CelciusAggr&#x27;}; base.store(&quot;Heat&quot;).addStreamAggr(celVar);var waterVar = {   name: &#x27;waterVarAggr&#x27;,   type: &#x27;variance&#x27;,   store: &#x27;Heat&#x27;,   inAggr: &#x27;WaterAggr&#x27;}; base.store(&quot;Heat&quot;).addStreamAggr(waterVar);// add a correlation aggregator, that is connected to &#x27;CovarianceAggr&#x27;, &#x27;CelciusVarAggr&#x27; and &#x27;WaterValAggr&#x27; aggregatorsvar corr = {   name: &#x27;corrAggr&#x27;,   type: &#x27;correlation&#x27;,   store: &#x27;Heat&#x27;,   inAggrCov: &#x27;covarianceAggr&#x27;,   inAggrVarX: &#x27;celciusVarAggr&#x27;,   inAggrVarY: &#x27;waterVarAggr&#x27;};var correlation = base.store(&quot;Heat&quot;).addStreamAggr(corr);base.close();</code></pre>
</div>

    </section>

    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>StreamAggregateMovingCorrelation.name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The given name for the stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateMovingCorrelation.type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the stream aggregator. It must be equal to <b>'correlation'</b>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateMovingCorrelation.store</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store from which it takes the data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateMovingCorrelation.inAggrCov</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the covariance stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateMovingCorrelation.inAggrVarX</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the first variance stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateMovingCorrelation.inAggrVarY</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the second variance stream aggregator.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~StreamAggregateMovingCovariance"><div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><span class="symbol-name">StreamAggregateMovingCovariance</span><small class="property-type">
            &nbsp;<a href="module-qm.StreamAggr.html">module:qm.StreamAggr</a></small></h3>
        <p>This stream aggregator represents the moving covariance window buffer. It calculates the moving covariance of the two stream aggregators, that it's connected to.
It implements the following methods:
<br><a href="module-qm.StreamAggr.html#getFloat">module:qm.StreamAggr#getFloat</a> returns the covariance of the values in it's buffer window.
<br><a href="module-qm.StreamAggr.html#getTimestamp">module:qm.StreamAggr#getTimestamp</a> returns the timestamp of the newest record in it's buffer window.</p>

        <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import the qm modulevar qm = require(&#x27;qminer&#x27;);// create a base with a simple storevar base = new qm.Base({   mode: &quot;createClean&quot;,   schema: [   {       name: &quot;Heat&quot;,       fields: [           { name: &quot;Celcius&quot;, type: &quot;float&quot; },           { name: &quot;WaterConsumption&quot;, type: &quot;float&quot; },           { name: &quot;Time&quot;, type: &quot;datetime&quot; }       ]   }]});// create a new time series stream aggregator for the &#x27;Heat&#x27; store, that takes the values from the &#x27;Celcius&#x27; field// and the timestamp from the &#x27;Time&#x27; field. The size of the window is 1 day.var celcius = {   name: &#x27;CelciusAggr&#x27;,   type: &#x27;timeSeriesWinBuf&#x27;,   store: &#x27;Heat&#x27;,   timestamp: &#x27;Time&#x27;,   value: &#x27;Celcius&#x27;,   winsize: 86400000}; base.store(&quot;Heat&quot;).addStreamAggr(celcius);// create a new time series stream aggregator for the &#x27;Heat&#x27; store, that takes the values from the &#x27;WaterConsumption&#x27; field// and the timestamp from the &#x27;Time&#x27; field. The size of the window is 1 day.var water = {   name: &#x27;WaterAggr&#x27;,   type: &#x27;timeSeriesWinBuf&#x27;,   store: &#x27;Heat&#x27;,   timestamp: &#x27;Time&#x27;,   value: &#x27;WaterConsumption&#x27;,   winsize: 86400000}; base.store(&quot;Heat&quot;).addStreamAggr(water);// add a covariance aggregator, that is connected with the &#x27;CelciusAggr&#x27; and &#x27;WaterAggr&#x27; stream aggregatorsvar covariance = {   name: &#x27;covAggr&#x27;,   type: &#x27;covariance&#x27;,   store: &#x27;Heat&#x27;,   inAggrX: &#x27;CelciusAggr&#x27;,   inAggrY: &#x27;WaterAggr&#x27;};var covarianceAggr = base.store(&quot;Heat&quot;).addStreamAggr(covariance);base.close();</code></pre>
</div>

    </section>

    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>StreamAggregateMovingCovariance.name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The given name for the stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateMovingCovariance.type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the stream aggregator. It must be equal to <b>'covariance'</b>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateMovingCovariance.store</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store from which it takes the data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateMovingCovariance.inAggrX</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the first stream aggregator to which it connects and gets data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateMovingCovariance.inAggrY</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the recond stream aggregator to which it connects and gets data.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~StreamAggregateMovingVariance"><div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><span class="symbol-name">StreamAggregateMovingVariance</span><small class="property-type">
            &nbsp;<a href="module-qm.StreamAggr.html">module:qm.StreamAggr</a></small></h3>
        <p>This stream aggregator represents the moving variance window buffer. It calculates the moving variance of the stream aggregator, that it's connected to. 
It implements the following methods:
<br><a href="module-qm.StreamAggr.html#getFloat">module:qm.StreamAggr#getFloat</a> returns the variance of the values in it's buffer window.
<br><a href="module-qm.StreamAggr.html#getTimestamp">module:qm.StreamAggr#getTimestamp</a> returns the timestamp of the newest record in it's buffer window.</p>

        <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import the qm modulevar qm = require(&#x27;qminer&#x27;);// create a base with a simple storevar base = new qm.Base({   mode: &quot;createClean&quot;,   schema: [   {       name: &quot;Heat&quot;,       fields: [           { name: &quot;Celcius&quot;, type: &quot;float&quot; },           { name: &quot;Time&quot;, type: &quot;datetime&quot; }       ]   }]});// create a new time series stream aggregator for the &#x27;Heat&#x27; store, that takes the values from the &#x27;Celcius&#x27; field// and the timestamp from the &#x27;Time&#x27; field. The size of the window is 1 day.var timeser = {   name: &#x27;TimeSeriesAggr&#x27;,   type: &#x27;timeSeriesWinBuf&#x27;,   store: &#x27;Heat&#x27;,   timestamp: &#x27;Time&#x27;,   value: &#x27;Celcius&#x27;,   winsize: 86400000};var timeSeries = base.store(&quot;Heat&quot;).addStreamAggr(timeser);// add a variance aggregator, that is connected with the &#x27;TimeSeriesAggr&#x27; aggregatorvar variance = {   name: &#x27;varAggr&#x27;,   type: &#x27;variance&#x27;,   store: &#x27;Heat&#x27;,   inAggr: &#x27;TimeSeriesAggr&#x27;};var varianceAggr = base.store(&quot;Heat&quot;).addStreamAggr(variance);base.close();</code></pre>
</div>

    </section>

    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>StreamAggregateMovingVariance.name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The given name for the stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateMovingVariance.type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the stream aggregator. It must be equal to <b>'variance'</b>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateMovingVariance.store</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store from which it takes the data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateMovingVariance.inAggr</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the stream aggregator to which it connects and gets data.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~StreamAggregateRecordBuffer"><div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><span class="symbol-name">StreamAggregateRecordBuffer</span><small class="property-type">
            &nbsp;<a href="module-qm.StreamAggr.html">module:qm.StreamAggr</a></small></h3>
        <p>This stream aggregator represents record buffer. It stores the values inside a moving window.
It implements all the methods of <b>except</b> <a href="module-qm.StreamAggr.html#getFloat">module:qm.StreamAggr#getFloat</a>, <a href="module-qm.StreamAggr.html#getTimestamp">module:qm.StreamAggr#getTimestamp</a>.</p>

        <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import the qm modulevar qm = require(&#x27;qminer&#x27;);// create a base with a simple storevar base = new qm.Base({   mode: &quot;createClean&quot;,   schema: [   {       name: &quot;Heat&quot;,       fields: [           { name: &quot;Celcius&quot;, type: &quot;float&quot; },           { name: &quot;Time&quot;, type: &quot;datetime&quot; }       ]   }]});// create a new time series stream aggregator for the &#x27;Heat&#x27; store. The size of the window is 3 records.var aggr = {   name: &#x27;Delay&#x27;,   type: &#x27;recordBuffer&#x27;,   size: 3};base.store(&quot;Heat&quot;).addStreamAggr(aggr);base.close();</code></pre>
</div>

    </section>

    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>StreamAggregateTimeSeriesWindow.name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The given name of the stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateTimeSeriesWindow.type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the stream aggregator. It must be equal to <b>'recordBuffer'</b>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateTimeSeriesWindow.size</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The size of the window.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~StreamAggregateResampler"><div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><span class="symbol-name">StreamAggregateResampler</span><small class="property-type">
            &nbsp;<a href="module-qm.StreamAggr.html">module:qm.StreamAggr</a></small></h3>
        <p>This stream aggregator represents the resampler window buffer. It creates new values that are interpolated by using the values from an existing store.
No methods are implemented for this aggregator.</p>

        <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import the qm modulevar qm = require(&#x27;qminer&#x27;);// create a base with a simple storevar base = new qm.Base({   mode: &quot;createClean&quot;,   schema: [   {       name: &quot;Heat&quot;,       fields: [           { name: &quot;Celcius&quot;, type: &quot;float&quot; },           { name: &quot;Time&quot;, type: &quot;datetime&quot; }       ]   },   {       name: &quot;interpolatedValues&quot;,       fields: [           { name: &quot;Value&quot;, type: &quot;float&quot; },           { name: &quot;Time&quot;, type: &quot;datetime&quot; }       ]   }]});// create a new resampler stream aggregator for the &#x27;Heat&#x27; store, that takes the values from the &#x27;Celcius&#x27; field// and the timestamp from the &#x27;Time&#x27; field. The interpolated values are stored in the &#x27;interpolatedValues&#x27; store.// The interpolation should be linear and the interval should be 2 seconds.var res = {   name: &#x27;resamplerAggr&#x27;,   type: &#x27;resampler&#x27;,   store: &#x27;Heat&#x27;,   outStore: &#x27;interpolatedValues&#x27;,   timestamp: &#x27;Time&#x27;,   fields: [{       name: &#x27;Celcius&#x27;,       interpolator: &#x27;linear&#x27;   }],   createStore: false,   interval: 2000};var resampler = base.store(&quot;Heat&quot;).addStreamAggr(res);base.close();</code></pre>
</div>

    </section>

    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>StreamAggregateResampler.name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The given name for the stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateResampler.type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the stream aggregator. It must be equal to <b>'resampler'</b>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateResampler.store</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store from which it takes the data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateResampler.outStore</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The store in which the samples are stored.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateResampler.timestamp</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The store field from which it takes the timestamps.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateResampler.fields</p>
        </td>
        <td>
                <p>Object</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The json, which contains:
<br> name (string) - the store field from which it takes the values.
<br> interpolator (string) - the type of the interpolation. The options are 'previous', 'next' and 'linear'.
<br> The 'previous' type interpolates with the previous value.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateResampler.createStore</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>If the outStore must be created.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateResampler.interval</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The size/frequency the interpolated values should be given.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~StreamAggregateSlottedHistogram"><div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><span class="symbol-name">StreamAggregateSlottedHistogram</span><small class="property-type">
            &nbsp;<a href="module-qm.StreamAggr.html">module:qm.StreamAggr</a></small></h3>
        <p>This stream aggregator represents an online slotted histogram. It can connect to a buffered aggregate (such as <a href="module-qm.html#~StreamAggregateTimeSeriesWindow">module:qm~StreamAggregateTimeSeriesWindow</a>)
or a time series (such as <a href="module-qm.html#~StreamAggregateEMA">module:qm~StreamAggregateEMA</a>). 
It maps historical values into single period (e.g. into hours of the week). 
The aggregate defines an ordered set of points p(0), ..., p(n) that define n bins. Infinites at both ends are NOT allowed.
A new measurement is tested for inclusion in the left-closed right-opened intervals [p(i), p(i+1)) and the corresponding
bin counter is increased for the appropriate bin (or decreased if the point is outgoing from the buffer).
It implements the following methods:
<br><a href="module-qm.StreamAggr.html#getFloatLength">module:qm.StreamAggr#getFloatLength</a> returns the number of bins.
<br><a href="module-qm.StreamAggr.html#getFloatAt">module:qm.StreamAggr#getFloatAt</a> returns the count for a bin index.
<br><a href="module-qm.StreamAggr.html#getFloatVector">module:qm.StreamAggr#getFloatVector</a> returns the vector of counts, the length is equal to the number of bins.</p>

        <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import the qm modulevar qm = require(&#x27;qminer&#x27;);// create a base with a simple storevar base = new qm.Base({   mode: &quot;createClean&quot;,   schema: [   {       name: &quot;Heat&quot;,       fields: [           { name: &quot;Celcius&quot;, type: &quot;float&quot; },           { name: &quot;Time&quot;, type: &quot;datetime&quot; }       ]   }]});// create a new time series stream aggregator for the &#x27;Heat&#x27; store, that takes the values from the &#x27;Celcius&#x27; field// and the timestamp from the &#x27;Time&#x27; field. The size of the window is 4 weeks.var timeser = {   name: &#x27;TimeSeriesBuffer&#x27;,   type: &#x27;timeSeriesWinBuf&#x27;,   store: &#x27;Heat&#x27;,   timestamp: &#x27;Time&#x27;,   value: &#x27;Celcius&#x27;,   winsize: 2419200000 // 4 weeks};var timeSeries = base.store(&quot;Heat&quot;).addStreamAggr(timeser);// add a slotted-histogram aggregator, that is connected with the &#x27;TimeSeriesAggr&#x27; aggregator// it will present accumulated histogram for the last 2 hours (window) of the week (period) for the last 4 weeks (see aggregate above)var aggrJson = {   name: &#x27;Histogram&#x27;,   type: &#x27;onlineSlottedHistogram&#x27;,   store: &#x27;Heat&#x27;,   inAggr: &#x27;TimeSeriesBuffer&#x27;,   period: 604800000, // 1 week   window: 7200000, // 2h   bins: 5, // 5 possible clusters   granularity: 300000  // 5 min};var hist = base.store(&quot;Heat&quot;).addStreamAggr(aggrJson);base.close();</code></pre>
</div>

    </section>

    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The given name of the stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type for the stream aggregator. It must be equal to <b>'onlineHistogram'</b>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>store</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store from which it takes the data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>inAggr</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the stream aggregator to which it connects and gets data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>period</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>Cycle length in msec.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>window</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>Window length that is reported when aggregate is queried.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>bins</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The number of bins - input data is expected to be withing interval [0, bins-1].</p>
        </td>
</tr>

                <tr>
        <td>
            <p>granularity</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>Storage granularity in msec. History is stored in slots with this length. Number of slots=period/granularity</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~StreamAggregateSum"><div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><span class="symbol-name">StreamAggregateSum</span><small class="property-type">
            &nbsp;<a href="module-qm.StreamAggr.html">module:qm.StreamAggr</a></small></h3>
        <p>This stream aggregator represents the sum moving window buffer. It sums all the values, that are in the connected stream aggregator.
It implements the following methods:
<br><a href="module-qm.StreamAggr.html#getFloat">module:qm.StreamAggr#getFloat</a> returns the sum of the values of the records in the it's buffer window.
<br><a href="module-qm.StreamAggr.html#getTimestamp">module:qm.StreamAggr#getTimestamp</a> returns the timestamp of the newest record in it's buffer window.</p>

        <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import the qm modulevar qm = require(&#x27;qminer&#x27;);// create a base with a simple storevar base = new qm.Base({   mode: &quot;createClean&quot;,   schema: [   {       name: &quot;Income&quot;,       fields: [           { name: &quot;Amount&quot;, type: &quot;float&quot; },           { name: &quot;Time&quot;, type: &quot;datetime&quot; }       ]   }]});// create a new time series stream aggregator for the &#x27;Income&#x27; store, that takes the values from the &#x27;Amount&#x27; field// and the timestamp from the &#x27;Time&#x27; field. The size of the window should 1 week.var timeser = {   name: &#x27;TimeSeriesAggr&#x27;,   type: &#x27;timeSeriesWinBuf&#x27;,   store: &#x27;Income&#x27;,   timestamp: &#x27;Time&#x27;,   value: &#x27;Amount&#x27;,   winsize: 604800000 // 7 days in miliseconds};var timeSeries = base.store(&quot;Income&quot;).addStreamAggr(timeser);// add a sum aggregator, that is connected with the &#x27;TimeSeriesAggr&#x27; aggregatorvar sum = {   name: &#x27;SumAggr&#x27;,   type: &#x27;winBufSum&#x27;,   store: &#x27;Heat&#x27;,   inAggr: &#x27;TimeSeriesAggr&#x27;};var sumAggr = base.store(&quot;Income&quot;).addStreamAggr(sum);base.close();</code></pre>
</div>

    </section>

    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>StreamAggregateSum.name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The given name of the stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateSum.type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the stream aggregator. It must be equal to <b>'winBufSum'</b>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateSum.store</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store from which it takes the data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateSum.inAggr</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the stream aggregator to which it connects and gets data.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~StreamAggregateTimeSeriesTick"><div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><span class="symbol-name">StreamAggregateTimeSeriesTick</span><small class="property-type">
            &nbsp;<a href="module-qm.StreamAggr.html">module:qm.StreamAggr</a></small></h3>
        <p>This stream aggregator represents the time series tick window buffer. It exposes the data to other stream aggregators 
(similar to module:qm~StreamAggr_TimeSeriesWindow). It implements the following methods:
<br><a href="module-qm.StreamAggr.html#getFloat">module:qm.StreamAggr#getFloat</a> returns the last value added in it's buffer.
<br><a href="module-qm.StreamAggr.html#getTimestamp">module:qm.StreamAggr#getTimestamp</a> returns the timestamp of the newest record in it's buffer.</p>

        <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import the qm modulevar qm = require(&#x27;qminer&#x27;);// create a base with a simple storevar base = new qm.Base({   mode: &quot;createClean&quot;,   schema: [   {       name: &quot;Students&quot;,       fields: [           { name: &quot;Id&quot;, type: &quot;float&quot; },           { name: &quot;TimeOfGraduation&quot;, type: &quot;datetime&quot; }       ]   }]});// create a new time series tick stream aggregator for the &#x27;Students&#x27; store, that takes the values from the &#x27;Id&#x27; field// and the timestamp from the &#x27;TimeOfGraduation&#x27; field.var tick = {   name: &#x27;TimeSeriesTickAggr&#x27;,   type: &#x27;timeSeriesTick&#x27;,   store: &#x27;Students&#x27;,   timestamp: &#x27;TimeOfGraduation&#x27;,   value: &#x27;Id&#x27;,};var timeSeriesTick = base.store(&quot;Students&quot;).addStreamAggr(tick);base.close();</code></pre>
</div>

    </section>

    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>StreamAggregateTimeSeriesTick.name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The given name for the stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateTimeSeriesTick.type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the stream aggregator. It must be equal to <b>'timeSeriesTick'</b>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateTimeSeriesTick.store</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store from which it takes the data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateTimeSeriesTick.value</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store field, from which it takes the values.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateTimeSeriesTick.timestamp</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store field, from which it takes the timestamp.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~StreamAggregateTimeSeriesWindow"><div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><span class="symbol-name">StreamAggregateTimeSeriesWindow</span><small class="property-type">
            &nbsp;<a href="module-qm.StreamAggr.html">module:qm.StreamAggr</a></small></h3>
        <p>This stream aggregator represents the time series window buffer. It stores the values inside a moving window. 
It implements all the methods of <b>except</b> <a href="module-qm.StreamAggr.html#getFloat">module:qm.StreamAggr#getFloat</a>, <a href="module-qm.StreamAggr.html#getTimestamp">module:qm.StreamAggr#getTimestamp</a>.</p>

        <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import the qm modulevar qm = require(&#x27;qminer&#x27;);// create a base with a simple storevar base = new qm.Base({   mode: &quot;createClean&quot;,   schema: [   {       name: &quot;Heat&quot;,       fields: [           { name: &quot;Celcius&quot;, type: &quot;float&quot; },           { name: &quot;Time&quot;, type: &quot;datetime&quot; }       ]   }]});// create a new time series stream aggregator for the &#x27;Heat&#x27; store, that takes the values from the &#x27;Celcius&#x27; field// and the timestamp from the &#x27;Time&#x27; field. The size of the window is 2 seconds (2000ms).var aggr = {   name: &#x27;TimeSeriesAggr&#x27;,   type: &#x27;timeSeriesWinBuf&#x27;,   store: &#x27;Heat&#x27;,   timestamp: &#x27;Time&#x27;,   value: &#x27;Celcius&#x27;,   winsize: 2000};base.store(&quot;Heat&quot;).addStreamAggr(aggr); base.close();</code></pre>
</div>

    </section>

    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>StreamAggregateTimeSeriesWindow.name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The given name of the stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateTimeSeriesWindow.type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the stream aggregator. It must be equal to <b>'timeSeriesWinBuf'</b>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateTimeSeriesWindow.store</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store from which to takes the data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateTimeSeriesWindow.timestamp</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The field of the store, where it takes the timestamp.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateTimeSeriesWindow.value</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The field of the store, where it takes the values.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateTimeSeriesWindow.winsize</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The size of the window, in milliseconds.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>StreamAggregateTimeSeriesWindow.delay</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>Delay in milliseconds.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~StreamAggregateVecDiff"><div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><span class="symbol-name">StreamAggregateVecDiff</span><small class="property-type">
            &nbsp;<a href="module-qm.StreamAggr.html">module:qm.StreamAggr</a></small></h3>
        <p>This stream aggregator represents difference between two vectors (e.g. online histograms). </p>
<p>It implements the following methods:
<br><a href="module-qm.StreamAggr.html#getFloatLength">module:qm.StreamAggr#getFloatLength</a> returns the number of bins.
<br><a href="module-qm.StreamAggr.html#getFloatAt">module:qm.StreamAggr#getFloatAt</a> returns the count for a bin index.
<br><a href="module-qm.StreamAggr.html#getFloatVector">module:qm.StreamAggr#getFloatVector</a> returns the vector of counts, the length is equal to the number of bins.</p>

        <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import the qm modulevar qm = require(&#x27;qminer&#x27;);// create a base with a simple store// the store records results of clusteringvar base = new qm.Base({mode: &quot;createClean&quot;,schema: [{	name: &quot;Rpm&quot;,	fields: [		{ name: &quot;ClusterId&quot;, type: &quot;float&quot; },		{ name: &quot;Time&quot;, type: &quot;datetime&quot; }	]}]});		var store = base.store(&#x27;Rpm&#x27;);// create a new time series stream aggregator for the &#x27;Rpm&#x27; store that takes the recorded cluster id// and the timestamp from the &#x27;Time&#x27; field. The size of the window is 4 weeks.var timeser1 = {	name: &#x27;TimeSeries1&#x27;,	type: &#x27;timeSeriesWinBuf&#x27;,	store: &#x27;Rpm&#x27;,	timestamp: &#x27;Time&#x27;,	value: &#x27;ClusterId&#x27;,	winsize: 7200000 // 2 hours};var timeSeries1 = base.store(&quot;Rpm&quot;).addStreamAggr(timeser1);// add a histogram aggregator, that is connected with the &#x27;TimeSeries1&#x27; aggregatorvar aggrJson1 = {	name: &#x27;Histogram1&#x27;,	type: &#x27;onlineHistogram&#x27;,	store: &#x27;Rpm&#x27;,	inAggr: &#x27;TimeSeries1&#x27;,	lowerBound: 0,	upperBound: 5,	bins: 5,	addNegInf: false,	addPosInf: false};var hist1 = base.store(&quot;Rpm&quot;).addStreamAggr(aggrJson1);// create a new time series stream aggregator for the &#x27;Rpm&#x27; store that takes the recorded cluster id// and the timestamp from the &#x27;Time&#x27; field. var timeser2 = {	name: &#x27;TimeSeries2&#x27;,	type: &#x27;timeSeriesWinBuf&#x27;,	store: &#x27;Rpm&#x27;,	timestamp: &#x27;Time&#x27;,	value: &#x27;ClusterId&#x27;,	winsize: 21600000 // 6 hours};var timeSeries2 = base.store(&quot;Rpm&quot;).addStreamAggr(timeser2);// add a histogram aggregator, that is connected with the &#x27;TimeSeries1&#x27; aggregatorvar aggrJson2 = {	name: &#x27;Histogram2&#x27;,	type: &#x27;onlineHistogram&#x27;,	store: &#x27;Rpm&#x27;,	inAggr: &#x27;TimeSeries2&#x27;,	lowerBound: 0,	upperBound: 5,	bins: 5,	addNegInf: false,	addPosInf: false};var hist2 = base.store(&quot;Rpm&quot;).addStreamAggr(aggrJson2);// add diff aggregator that subtracts Histogram1 with 2h window from Histogram2 with 6h windowvar aggrJson3 = {	name: &#x27;DiffAggr&#x27;,	type: &#x27;onlineVecDiff&#x27;,	storeX: &#x27;Rpm&#x27;,	storeY: &#x27;Rpm&#x27;,	inAggrX: &#x27;Histogram2&#x27;,	inAggrY: &#x27;Histogram1&#x27;}var diff = store.addStreamAggr(aggrJson3);base.close();</code></pre>
</div>

    </section>

    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The given name of the stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type for the stream aggregator. It must be equal to <b>'onlineVecDiff'</b>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>storeX</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store from which it takes the data for the first vector.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>storeY</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store from which it takes the data for the second vector.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>inAggrX</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the first stream aggregator to which it connects and gets data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>inAggrY</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the second stream aggregator to which it connects and gets data.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

                <h3 id="~StreamAggregators"><div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><span class="symbol-name">StreamAggregators</span><small class="property-type">
            &nbsp;<a href="module-qm.StreamAggr.html">module:qm.StreamAggr</a></small></h3>
        <p>Stream aggregator types.</p>

    
    
        <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>timeSeries</p>
        </td>
        <td>
                <p><a href="module-qm.html#~StreamAggregateTimeSeriesWindow">module:qm~StreamAggregateTimeSeriesWindow</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The time series type.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>recordBuffer</p>
        </td>
        <td>
                <p><a href="module-qm.html#~StreamAggregateRecordBuffer">module:qm~StreamAggregateRecordBuffer</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The record buffer type.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>sum</p>
        </td>
        <td>
                <p><a href="module-qm.html#~StreamAggregateSum">module:qm~StreamAggregateSum</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The sum type.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>min</p>
        </td>
        <td>
                <p><a href="module-qm.html#~StreamAggregateMin">module:qm~StreamAggregateMin</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The minimal type.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>max</p>
        </td>
        <td>
                <p><a href="module-qm.html#~StreamAggregateMax">module:qm~StreamAggregateMax</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The maximal type.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>tick</p>
        </td>
        <td>
                <p><a href="module-qm.html#~StreamAggregateTimeSeriesTick">module:qm~StreamAggregateTimeSeriesTick</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The time series tick type.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>ma</p>
        </td>
        <td>
                <p><a href="module-qm.html#~StreamAggregateMovingAverage">module:qm~StreamAggregateMovingAverage</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The moving average type.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>ema</p>
        </td>
        <td>
                <p><a href="module-qm.html#~StreamAggregateEMA">module:qm~StreamAggregateEMA</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The exponental moving average type.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>var</p>
        </td>
        <td>
                <p><a href="module-qm.html#~StreamAggregateMovingVariance">module:qm~StreamAggregateMovingVariance</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The moving variance type.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>cov</p>
        </td>
        <td>
                <p><a href="module-qm.html#~StreamAggregateMovingCovariance">module:qm~StreamAggregateMovingCovariance</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The moving covariance type.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>cor</p>
        </td>
        <td>
                <p><a href="module-qm.html#~StreamAggregateMovingCorrelation">module:qm~StreamAggregateMovingCorrelation</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The moving correlation type.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>res</p>
        </td>
        <td>
                <p><a href="module-qm.html#~StreamAggregateResampler">module:qm~StreamAggregateResampler</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The resampler type.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>mer</p>
        </td>
        <td>
                <p><a href="module-qm.html#~StreamAggregateMerger">module:qm~StreamAggregateMerger</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The merger type.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>hist</p>
        </td>
        <td>
                <p><a href="module-qm.html#~StreamAggregateHistogram">module:qm~StreamAggregateHistogram</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The online histogram type.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>slotted-hist</p>
        </td>
        <td>
                <p><a href="module-qm.html#~StreamAggregateSlottedHistogram">module:qm~StreamAggregateSlottedHistogram</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The online slotted-histogram type.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>vec-diff</p>
        </td>
        <td>
                <p><a href="module-qm.html#~StreamAggregateVecDiff">module:qm~StreamAggregateVecDiff</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The difference of two vectors (e.g. online histograms) type.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


    <dl class="dl-compact">
        
        














        
        
        
        
        
        
    </dl>

    </section>


            
</section>

                                        </div>
                                </div>
                                <nav id="jsdoc-toc-nav" role="navigation"></nav>
                        </div>
                </div>
                    <footer id="jsdoc-footer" class="jsdoc-footer">
                            <div id="jsdoc-footer-container">
                                    <p>
                                      
                                    </p>
                            </div>
                    </footer>
                <script src="scripts/jquery.min.js"></script>
                <script src="scripts/jquery.cookie.js"></script>
                <script src="scripts/tree.jquery.js"></script>
                <script src="scripts/prettify.js"></script>
                <script src="scripts/jsdoc-toc.js"></script>
                <script src="scripts/linenumber.js"></script>
                <script src="scripts/scrollanchor.js"></script>
        </body>
</html>
