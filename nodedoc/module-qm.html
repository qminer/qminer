<!doctype html>
<html>
        <head>
                <meta name="generator" content="JSDoc 3">
                <meta charset="utf-8">
                <title>Module: qm</title>
                <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Karla:400,400i,700,700i" type="text/css">
                <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Noto+Serif:400,400i,700,700i" type="text/css">
                <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Inconsolata:500" type="text/css">
                <link href="css/baseline.css" rel="stylesheet">
        </head>
        <body onload="prettyPrint()">
                <nav id="jsdoc-navbar" role="navigation" class="jsdoc-navbar">
    <div id="jsdoc-navbar-container">
        <div id="jsdoc-navbar-content">
            <a href="index.html" class="jsdoc-navbar-package-name">QMiner JavaScript API v9.3.1</a>
        </div>
    </div>
</nav>

                <div id="jsdoc-body-container">
                        <div id="jsdoc-content">
                                <div id="jsdoc-content-container">
                                        <div id="jsdoc-main" role="main">
                    <header class="page-header">
<div class="symbol-detail-labels"><span class="label label-kind">module</span></div><h1><small></small><span class="symbol-name">qm</span></h1>        <p class="source-link">Source: <a href="qminerdoc.js.html#source-line-8">qminerdoc.<wbr>js:8</a></p>
                <div class="symbol-description">
                        <p>QMiner module.</p>

                </div>
                <section>
        <h2>
            Example
        </h2>
                <div>
    <pre class="prettyprint"><code>// import module
var qm &#x3D; require(&#x27;qminer&#x27;);</code></pre>
</div>

    </section>

        <dl class="dl-compact">
            
            
            
        </dl>
</header>


    <section id="summary">
                

                    <div class="summary-callout">
            <h2 class="summary-callout-heading">Child classes</h2>
        <div class="summary-content">
                    <div class="summary-column">
        <dl class="dl-summary-callout">
                <dt><a href="module-qm.Base.html">Base(paramObj)</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.CircularRecordBuffer.html">CircularRecordBuffer([params])</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.FeatureSpace.html">FeatureSpace(base, arg)</a></dt>
                <dd>
                </dd>
        </dl>
</div>

                    <div class="summary-column">
        <dl class="dl-summary-callout">
                <dt><a href="module-qm.Iterator.html">Iterator()</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.Record.html">Record()</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.RecordSet.html">RecordSet()</a></dt>
                <dd>
                </dd>
        </dl>
</div>

                    <div class="summary-column">
        <dl class="dl-summary-callout">
                <dt><a href="module-qm.RecordVector.html">RecordVector(base[, fin])</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.Store.html">Store()</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.StreamAggr.html">StreamAggr(base, arg[, storeName])</a></dt>
                <dd>
                </dd>
        </dl>
</div>

        </div>
    </div>


                

                

                    <div class="summary-callout">
            <h2 class="summary-callout-heading">Properties</h2>
        <div class="summary-content">
                    <div class="summary-column">
        <dl class="dl-summary-callout">
                <dt><a href="module-qm.html#.flags">flags</a></dt>
                <dd>
                </dd>
        </dl>
</div>

                    <div class="summary-column">
        <dl class="dl-summary-callout">
                <dt><a href="module-qm.html#.version">version</a></dt>
                <dd>
                </dd>
        </dl>
</div>

                    <div class="summary-column">
</div>

        </div>
    </div>


                    <div class="summary-callout">
            <h2 class="summary-callout-heading">Methods</h2>
        <div class="summary-content">
                    <div class="summary-column">
        <dl class="dl-summary-callout">
                <dt><a href="module-qm.html#.config">config([configPath][, overwrite][, portN][, cacheSize])</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#.create">create([configPath][, schemaPath][, clear])</a></dt>
                <dd>
                </dd>
        </dl>
</div>

                    <div class="summary-column">
        <dl class="dl-summary-callout">
                <dt><a href="module-qm.html#.open">open([configPath][, readOnly])</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#.stats">stats()</a></dt>
                <dd>
                </dd>
        </dl>
</div>

                    <div class="summary-column">
        <dl class="dl-summary-callout">
                <dt><a href="module-qm.html#.verbosity">verbosity([level])</a></dt>
                <dd>
                </dd>
        </dl>
</div>

        </div>
    </div>


                    <div class="summary-callout">
            <h2 class="summary-callout-heading">Abstract types</h2>
        <div class="summary-content">
                    <div class="summary-column">
        <dl class="dl-summary-callout">
                <dt><a href="module-qm.html#~BaseConstructorParam">BaseConstructorParam</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~BaseLoadCSVParam">BaseLoadCSVParam</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~DetailKeyObject">DetailKeyObject</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~FeatureExtractor">FeatureExtractor</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~FeatureExtractorCategorical">FeatureExtractorCategorical</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~FeatureExtractorConstant">FeatureExtractorConstant</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~FeatureExtractorDateWindow">FeatureExtractorDateWindow</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~FeatureExtractorJoin">FeatureExtractorJoin</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~FeatureExtractorJsfunc">FeatureExtractorJsfunc</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~FeatureExtractorMultinomial">FeatureExtractorMultinomial</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~FeatureExtractorNumeric">FeatureExtractorNumeric</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~FeatureExtractorPair">FeatureExtractorPair</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~FeatureExtractorRandom">FeatureExtractorRandom</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~FeatureExtractorSparseVector">FeatureExtractorSparseVector</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~FeatureExtractorText">FeatureExtractorText</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~FeatureTokenizer">FeatureTokenizer</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~PerformanceStat">PerformanceStat</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~PerformanceStatBase">PerformanceStatBase</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~PerformanceStatStore">PerformanceStatStore</a></dt>
                <dd>
                </dd>
        </dl>
</div>

                    <div class="summary-column">
        <dl class="dl-summary-callout">
                <dt><a href="module-qm.html#~QMinerFlags">QMinerFlags</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~QueryObject">QueryObject</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~SchemaDef">SchemaDef</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~SchemaFieldDef">SchemaFieldDef</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~SchemaJoinDef">SchemaJoinDef</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~SchemaKeyDef">SchemaKeyDef</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~SchemaTimeWindowDef">SchemaTimeWindowDef</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggrAggrResampler">StreamAggrAggrResampler</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggrAnomalyDetectorNN">StreamAggrAnomalyDetectorNN</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggregator">StreamAggregator</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggrEMA">StreamAggrEMA</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggrEMASpVec">StreamAggrEMASpVec</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggrFeatureSpace">StreamAggrFeatureSpace</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggrHistogram">StreamAggrHistogram</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggrMax">StreamAggrMax</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggrMerger">StreamAggrMerger</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggrMin">StreamAggrMin</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggrMovingAverage">StreamAggrMovingAverage</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggrMovingCorrelation">StreamAggrMovingCorrelation</a></dt>
                <dd>
                </dd>
        </dl>
</div>

                    <div class="summary-column">
        <dl class="dl-summary-callout">
                <dt><a href="module-qm.html#~StreamAggrMovingCovariance">StreamAggrMovingCovariance</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggrMovingVariance">StreamAggrMovingVariance</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggrPageHinkley">StreamAggrPageHinkley</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggrRecordBuffer">StreamAggrRecordBuffer</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggrRecordSwitch">StreamAggrRecordSwitch</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggrResampler">StreamAggrResampler</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggrSimpleLinearRegression">StreamAggrSimpleLinearRegression</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggrSimpleLinearRegressionResult">StreamAggrSimpleLinearRegressionResult</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggrSlottedHistogram">StreamAggrSlottedHistogram</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggrSparseVecSum">StreamAggrSparseVecSum</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggrSum">StreamAggrSum</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggrTDigest">StreamAggrTDigest</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggrThreshold">StreamAggrThreshold</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggrTimeSeriesTick">StreamAggrTimeSeriesTick</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggrTimeSeriesWindow">StreamAggrTimeSeriesWindow</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggrTimeSeriesWindowVector">StreamAggrTimeSeriesWindowVector</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggrVecDiff">StreamAggrVecDiff</a></dt>
                <dd>
                </dd>
                <dt><a href="module-qm.html#~StreamAggrWindowQuantiles">StreamAggrWindowQuantiles</a></dt>
                <dd>
                </dd>
        </dl>
</div>

        </div>
    </div>


                
    </section>







            <section>
                <h2>Classes</h2>
    <section id='members-links'>
            <h3><a href="module-qm.Base.html">Base</a></h3>
            
            
            <h3><a href="module-qm.CircularRecordBuffer.html">CircularRecordBuffer</a></h3>
            
            
            <h3><a href="module-qm.FeatureSpace.html">FeatureSpace</a></h3>
            
            
            <h3><a href="module-qm.Iterator.html">Iterator</a></h3>
            
            
            <h3><a href="module-qm.Record.html">Record</a></h3>
            
            
            <h3><a href="module-qm.RecordSet.html">RecordSet</a></h3>
            
            
            <h3><a href="module-qm.RecordVector.html">RecordVector</a></h3>
            
            
            <h3><a href="module-qm.Store.html">Store</a></h3>
            
            
            <h3><a href="module-qm.StreamAggr.html">StreamAggr</a></h3>
            
            
    </section>


            

            

                <h2>Properties</h2>
    <section>
                <div class="symbol-detail-labels"><span class="label label-static">static</span></div><h3 id=".flags"><span class="symbol-name">flags</span></h3>            <p>Returns an object with all compile flags. Type <a href="module-qm.html#~QMinerFlags">module:qm~QMinerFlags</a>.</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// get the compile flags
var flags &#x3D; qm.flags;</code></pre>
</div>

    </section>

        
        

        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-static">static</span></div><h3 id=".version"><span class="symbol-name">version</span></h3>            <p>Returns the module version.</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// get the module version
var version &#x3D; qm.version;</code></pre>
</div>

    </section>

        
        

        <dl class="dl-compact">
            



















    <dt>Returns</dt>
        <dd><p><code>string</code>B The module version.</p></dd>



        </dl>

    </section>


                <h2>Methods</h2>
    <section>
                <div class="symbol-detail-labels"><span class="label label-static">static</span></div><h3 id=".config"><span class="symbol-name">config</span><span class="signature"><span class="signature-params">([configPath][, overwrite][, portN][, cacheSize])</span></span></h3>            <p>Creates a directory structure.</p>

        
            <section>
        <h4>Parameters</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>configPath</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>The path to configuration file.</p>
                <p>Defaults to <code>'qm.conf'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>overwrite</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>If you want to overwrite the configuration file.</p>
                <p>Defaults to <code>false</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>portN</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>The number of the port. Currently not used.</p>
                <p>Defaults to <code>8080</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>cacheSize</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Sets available memory for indexing (in MB).</p>
                <p>Defaults to <code>1024</code>.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>

        

        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-static">static</span></div><h3 id=".create"><span class="symbol-name">create</span><span class="signature"><span class="signature-params">([configPath][, schemaPath][, clear])</span>&nbsp;&rarr; <span class="signature-returns"> <a href="module-qm.Base.html">module:qm.Base</a></span></span></h3>            <p>Creates an empty base.</p>

        
            <section>
        <h4>Parameters</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>configPath</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Configuration file path.</p>
                <p>Defaults to <code>'qm.conf'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>schemaPath</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Schema file path.</p>
                <p>Defaults to <code>''</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>clear</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Clear the existing db folder.</p>
                <p>Defaults to <code>false</code>.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>

        

        <dl class="dl-compact">
            



















    <dt>Returns</dt>
        <dd><p><code><a href="module-qm.Base.html">module:qm.Base</a></code>B The newly created base.</p></dd>



        </dl>

                <div class="symbol-detail-labels"><span class="label label-static">static</span></div><h3 id=".open"><span class="symbol-name">open</span><span class="signature"><span class="signature-params">([configPath][, readOnly])</span>&nbsp;&rarr; <span class="signature-returns"> <a href="module-qm.Base.html">module:qm.Base</a></span></span></h3>            <p>Opens a base.</p>

        
            <section>
        <h4>Parameters</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>configPath</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>The configuration file path.</p>
                <p>Defaults to <code>'qm.conf'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>readOnly</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Open in read-only mode.</p>
                <p>Defaults to <code>false</code>.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>

        

        <dl class="dl-compact">
            



















    <dt>Returns</dt>
        <dd><p><code><a href="module-qm.Base.html">module:qm.Base</a></code>B The loaded base.</p></dd>



        </dl>

                <div class="symbol-detail-labels"><span class="label label-static">static</span></div><h3 id=".stats"><span class="symbol-name">stats</span><span class="signature"><span class="signature-params">()</span></span></h3>            <p>Returns an JSON with two properties: &quot;byClass&quot; and &quot;total&quot;. The &quot;byClass&quot; value is a JSON where
each key is a class ID and each value is of the form { newFromCpp: number, newFromJs: number, destructorCalls: number}
and the value of &quot;total&quot; is of the same form (aggregated over &quot;byClass&quot;)</p>

        
        
        

        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-static">static</span></div><h3 id=".verbosity"><span class="symbol-name">verbosity</span><span class="signature"><span class="signature-params">([level])</span></span></h3>            <p>Set verbosity of QMiner internals.</p>

        
            <section>
        <h4>Parameter</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>level</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>verbosity level. Possible options:
<br>1. <code>0</code> - No output,
<br>2. <code>1</code> - Log output,
<br>3. <code>2</code> - Log and debug output.</p>
                <p>Defaults to <code>0</code>.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>

        

        <dl class="dl-compact">
            






















        </dl>

    </section>


                <h2>Abstract types</h2>
    <section>
                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~BaseConstructorParam"><span class="symbol-name">BaseConstructorParam</span><small class="property-type">
            &nbsp;Object</small></h3>            <p>Base constructor parameter used for <a href="module-qm.Base.html">module:qm.Base</a>.</p>

        
        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>mode</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Base access mode. Can be one of the following:
<br>1. <code>'create'</code> - Sets up the db folder,
<br>2. <code>'createClean'</code> - Cleans db folder and then sets it up,
<br>3. <code>'open'</code> - Opens the db with read/write permissions,
<br>4. <code>'openReadOnly'</code> - Opens the db in read only mode.</p>
                <p>Defaults to <code>'openReadOnly'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>indexCache</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>The ammount of memory reserved for indexing (in MB).</p>
                <p>Defaults to <code>1024</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>storeCache</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>The ammount of memory reserved for store cache (in MB).</p>
                <p>Defaults to <code>1024</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>schemaPath</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>The path to schema definition file.</p>
                <p>Defaults to <code>''</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>schema</p>
        </td>
        <td>
                <p>Array of <a href="module-qm.html#~SchemaDef">module:qm~SchemaDef</a></p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Schema definition object array.</p>
                <p>Defaults to <code>[]</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>dbPath</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>The path to db directory.</p>
                <p>Defaults to <code>'./db/'</code>.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~BaseLoadCSVParam"><span class="symbol-name">BaseLoadCSVParam</span><small class="property-type">
            &nbsp;object</small></h3>            <p>The parameter given to <a href="module-qm.Base.html#loadCSV">module:qm.Base#loadCSV</a>.</p>

        
        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>file</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the input file.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>store</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>Name of the store which will be created.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>base</p>
        </td>
        <td>
                <p><a href="module-qm.Base.html">module:qm.Base</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>QMiner base object that creates the store.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>delimiter</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Optional delimiter.</p>
                <p>Defaults to <code>','</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>quote</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Optional character to escape values that contain a delimiter.</p>
                <p>Defaults to <code>'"'</code>.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~DetailKeyObject"><span class="symbol-name">DetailKeyObject</span><small class="property-type">
            &nbsp;object</small></h3>            <p>The details about the key object used in <a href="module-qm.Store.html#key">module:qm.Store#key</a> and <a href="module-qm.Store.html#keys">module:qm.Store#keys</a>.</p>

        
        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>fq</p>
        </td>
        <td>
                <p><a href="module-la.IntVector.html">module:la.IntVector</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The frequency.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>vocabulary</p>
        </td>
        <td>
                <p><a href="module-la.StrVector.html">module:la.StrVector</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The vocabulary.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The key name.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>store</p>
        </td>
        <td>
                <p><a href="module-qm.Store.html">module:qm.Store</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The store.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~FeatureExtractor"><span class="symbol-name">FeatureExtractor</span><small class="property-type">
            &nbsp;Object</small></h3>            <p>Feature extractor types. Used for constructing <a href="module-qm.FeatureSpace.html">module:qm.FeatureSpace</a> objects.</p>

        
        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>constant</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FeatureExtractorConstant">module:qm~FeatureExtractorConstant</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The constant type. Adds a constant value as a feature.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>random</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FeatureExtractorRandom">module:qm~FeatureExtractorRandom</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The random type. Adds a random value as a feature.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>numeric</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FeatureExtractorNumeric">module:qm~FeatureExtractorNumeric</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The numeric type. Adds the numeric value as a feature.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>categorical</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FeatureExtractorCategorical">module:qm~FeatureExtractorCategorical</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The categorical type.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>multinomial</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FeatureExtractorMultinomial">module:qm~FeatureExtractorMultinomial</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The multinomial type.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>text</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FeatureExtractorText">module:qm~FeatureExtractorText</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The text type. Creates the bag-of-words text representation.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>join</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FeatureExtractorJoin">module:qm~FeatureExtractorJoin</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The join type.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>pair</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FeatureExtractorPair">module:qm~FeatureExtractorPair</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The pair type.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>jsfunc</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FeatureExtractorJsfunc">module:qm~FeatureExtractorJsfunc</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The jsfunc type. Allows creating a custom feature extractor.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>dateWindow</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FeatureExtractorDateWindow">module:qm~FeatureExtractorDateWindow</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The date window type.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>sparseVector</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FeatureExtractorSparseVector">module:qm~FeatureExtractorSparseVector</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The sparse vector type.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~FeatureExtractorCategorical"><span class="symbol-name">FeatureExtractorCategorical</span><small class="property-type">
            &nbsp;Object</small></h3>            <p>The feature extractor of type <code>'categorical'</code>. Used for constructing <a href="module-qm.FeatureSpace.html">module:qm.FeatureSpace</a> objects.</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>var qm &#x3D; require(&#x27;qminer&#x27;);
// create a simple base, where each record contains the student name and it&#x27;s study group
// here we know the student is part of only one study group
var base &#x3D; new qm.Base({
   mode: &#x27;createClean&#x27;,
   schema: [{
      name: &quot;Class&quot;,
      fields: [
         { name: &quot;Name&quot;, type: &quot;string&quot; },
         { name: &quot;StudyGroup&quot;, type: &quot;string&quot; }
      ]
   }]
});
// create a feature space containing the categorical extractor, where it&#x27;s values
// are taken from the field &quot;StudyGroup&quot;: &quot;A&quot;, &quot;B&quot;, &quot;C&quot; and &quot;D&quot;
var ftr &#x3D; new qm.FeatureSpace(base, { type: &quot;categorical&quot;, source: &quot;Class&quot;, field: &quot;StudyGroup&quot; });
// add a few records to the store
base.store(&quot;Class&quot;).push({ Name: &quot;Fred&quot;, StudyGroup: &quot;A&quot; });
base.store(&quot;Class&quot;).push({ Name: &quot;Wilma&quot;, StudyGroup: &quot;B&quot; });
base.store(&quot;Class&quot;).push({ Name: &quot;Barney&quot;, StudyGroup: &quot;C&quot; });
// update the feature space to get the categories
ftr.updateRecords(base.store(&quot;Class&quot;).allRecords);
// get the feature vector for the first record
var vec &#x3D; ftr.extractVector(base.store(&quot;Class&quot;)[0]); // returns vector [1, 0, 0]
base.close();</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the extractor. <b>Important</b>: It must be equal <code>'categorical'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>values</p>
        </td>
        <td>
                <p>Array of Object</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>A fixed set of values, which form a fixed feature set. No dimensionality changes if new values are seen in the upgrades.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>hashDimension</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>A hashing code to set the fixed dimensionality. All values are hashed and divided modulo hasDimension to get the corresponding dimension.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>field</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the field form which to take the values.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>source</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The store name.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~FeatureExtractorConstant"><span class="symbol-name">FeatureExtractorConstant</span><small class="property-type">
            &nbsp;Object</small></h3>            <p>The feature extractor of type <code>'contant'</code>. Used for constructing <a href="module-qm.FeatureSpace.html">module:qm.FeatureSpace</a> objects.</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>var qm &#x3D; require(&#x27;qminer&#x27;);
// create a simple base, where each record contains only a persons name
var base &#x3D; new qm.Base({
  mode: &#x27;createClean&#x27;,
  schema: [{
     name: &quot;Person&quot;,
     fields: [{ name: &quot;Name&quot;, type: &quot;string&quot; }]
  }]
});
// create a feature space containing the constant extractor, where the constant is equal 5
var ftr &#x3D; new qm.FeatureSpace(base, { type: &quot;constant&quot;, source: &quot;Person&quot;, const: 5 });
// add a new record to the base
base.store(&quot;Person&quot;).push({ Name: &quot;Peterson&quot; });
// get the features of the record
var vec &#x3D; ftr.extractVector(base.store(&quot;Person&quot;)[0]); // the vector [5]
base.close();</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the extractor. <b>Important</b>: It must be equal <code>'constant'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>const</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>A constant number.</p>
                <p>Defaults to <code>1.0</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>source</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The store name.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~FeatureExtractorDateWindow"><span class="symbol-name">FeatureExtractorDateWindow</span><small class="property-type">
            &nbsp;Object</small></h3>            <p>The feature extractor of type <code>'dateWindow'</code>. Used for constructing <a href="module-qm.FeatureSpace.html">module:qm.FeatureSpace</a> objects.</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import qm module
var qm &#x3D; require(&#x27;qminer&#x27;);</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the extractor. <b>Important</b>: It must be equal <code>'dateWindow'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>unit</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>How granular is the time window. Possible options are <code>'day'</code>, <code>'week'</code>, <code>'month'</code>, <code>'year'</code>, <code>'12hours'</code>, <code>'6hours'</code>, <code>'4hours'</code>, <code>'2hours'</code>,
<code>'hour'</code>, <code>'30minutes'</code>, <code>'15minutes'</code>, <code>'10minutes'</code>, <code>'minute'</code>, <code>'second'</code>.</p>
                <p>Defaults to <code>'day'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>window</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>The size of the window.</p>
                <p>Defaults to <code>1</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>normalize</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Normalize the resulting vector of the extractor to have L2 norm 1.0.</p>
                <p>Defaults to <code>'false'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>start</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>//TODO</p>
        </td>
</tr>

                <tr>
        <td>
            <p>end</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>//TODO</p>
        </td>
</tr>

                <tr>
        <td>
            <p>source</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The store name.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~FeatureExtractorJoin"><span class="symbol-name">FeatureExtractorJoin</span><small class="property-type">
            &nbsp;Object</small></h3>            <p>The feature extractor of type <code>'join'</code>. Used for constructing <a href="module-qm.FeatureSpace.html">module:qm.FeatureSpace</a> objects.</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import qm module
var qm &#x3D; require(&#x27;qminer&#x27;);</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the extractor. <b>Important</b>: It must be equal <code>'join'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>bucketSize</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>The size of the bucket in which we group consecutive records.</p>
                <p>Defaults to <code>1</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>source</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The store name.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~FeatureExtractorJsfunc"><span class="symbol-name">FeatureExtractorJsfunc</span><small class="property-type">
            &nbsp;Object</small></h3>            <p>The feature extractor of type <code>'jsfunc'</code>. Used for constructing <a href="module-qm.FeatureSpace.html">module:qm.FeatureSpace</a> objects.</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>var qm &#x3D; require(&#x27;qminer&#x27;);
// create a simple base, where each record contains the name of the student and his study groups
// each student is part of multiple study groups
var base &#x3D; new qm.Base({
   mode: &#x27;createClean&#x27;,
   schema: [{
      name: &quot;Class&quot;,
      fields: [
         { name: &quot;Name&quot;, type: &quot;string&quot; },
         { name: &quot;StudyGroups&quot;, type: &quot;string_v&quot; }
      ]
   }]
});
// create a feature space containing the jsfunc extractor, where the function counts the number
// of study groups each student is part of. The functions name is &quot;NumberOFGroups&quot;, it&#x27;s dimension
// is 1 (returns only one value, not an array)
var ftr &#x3D; new qm.FeatureSpace(base, {
    type: &quot;jsfunc&quot;, source: &quot;Class&quot;, name: &quot;NumberOfGroups&quot;, dim: 1,
    fun: function (rec) { return rec.StudyGroups.length; }
});
// add a record to the store
base.store(&quot;Class&quot;).push({ Name: &quot;Gaben&quot;, StudyGroups: [&quot;A&quot;, &quot;B&quot;, &quot;D&quot;] });
// get the feature vector of the record
var vec &#x3D; ftr.extractVector(base.store(&quot;Class&quot;)[0]); // returns vector [3]
base.close();</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the extractor. <b>Important</b>: It must be equal <code>'jsfunc'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The features name.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>fun</p>
        </td>
        <td>
                <p>function()</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The javascript function callback. It takes one parameter:
<br>1. <code>rec</code> - The record. Type <a href="module-qm.Record.html">module:qm.Record</a>.
It returns <code>number</code> or <a href="module-la.Vector.html">module:la.Vector</a>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>dim</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>The dimension of the feature extractor.</p>
                <p>Defaults to <code>1</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>source</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The store name.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~FeatureExtractorMultinomial"><span class="symbol-name">FeatureExtractorMultinomial</span><small class="property-type">
            &nbsp;Object</small></h3>            <p>The feature extractor of type <code>'multinomial'</code>. Used for constructing <a href="module-qm.FeatureSpace.html">module:qm.FeatureSpace</a> objects.</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>var qm &#x3D; require(&#x27;qminer&#x27;);
// create a simple base, where each record contains the student name and an array of study groups
// here we know a student can be part of multiple study groups
var base &#x3D; new qm.Base({
   mode: &#x27;createClean&#x27;,
   schema: [{
      name: &quot;Class&quot;,
      fields: [
         { name: &quot;Name&quot;, type: &quot;string&quot; },
         { name: &quot;StudyGroups&quot;, type: &quot;string_v&quot; }
      ]
   }]
});
// create a feature space containing the multinomial extractor, where the values are normalized,
// and taken from the field &quot;StudyGroup&quot;: &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;
var ftr &#x3D; new qm.FeatureSpace(base, {
    type: &quot;multinomial&quot;, source: &quot;Class&quot;, field: &quot;StudyGroups&quot;, normalize: true
});
// add a few records to the store
base.store(&quot;Class&quot;).push({ Name: &quot;Fred&quot;, StudyGroups: [&quot;A&quot;, &quot;B&quot;] });
base.store(&quot;Class&quot;).push({ Name: &quot;Wilma&quot;, StudyGroups: [&quot;B&quot;, &quot;C&quot;] });
base.store(&quot;Class&quot;).push({ Name: &quot;Barney&quot;, StudyGroups: [&quot;C&quot;, &quot;A&quot;] });
// update the feature space to get the categories
ftr.updateRecords(base.store(&quot;Class&quot;).allRecords);
// get the feature vector for the first record
var vec &#x3D; ftr.extractVector(base.store(&quot;Class&quot;)[0]); // returns vector [0.707, 0.707, 0]
base.close();</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the extractor. <b>Important</b>: It must be equal <code>'multinomial'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>normalize</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Normalize the resulting vector of the extractor to have L2 norm 1.0.</p>
                <p>Defaults to <code>'false'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>transform</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Transformation to apply to each dimension of the feature vector.
<br> Transformation options are:
<br> - 'log' - Compute a logarithm of the frequencies using the following formula: log(1+x)
<br> - 'binary' - Do not compute frequencies, but only a binary indicator whether the category appears</p>
        </td>
</tr>

                <tr>
        <td>
            <p>values</p>
        </td>
        <td>
                <p>Array of Object</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>A fixed set of values, which form a fixed feature set, no dimensionality changes if new values are seen in the updates. Cannot be used the same time as datetime.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>hashDimension</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>A hashing code to set the fixed dimensionality. All values are hashed and divided modulo hashDimension to get the corresponding dimension.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>datetime</p>
        </td>
        <td>
                <p>Object</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Same as <code>'values'</code>, only with predefined values which are extracted from date and time (<code>month</code>, <code>day of month</code>, <code>day of week</code>, <code>time of day</code>, <code>hour</code>).
<br> This fixes the dimensionality of feature extractor at the start, making it not dimension as new dates are seen. Cannot be used the same time as values.</p>
                <p>Defaults to <code>false</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>field</p>
        </td>
        <td>
                <p>(string or Array of String)</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the field from which to take the key value.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>valueField</p>
        </td>
        <td>
                <p>(string or Array of String)</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>The name of the field from which to take the numeric value.
<br> Defaults to 1.0 for non-zero elements in the vector.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>source</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The store name.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~FeatureExtractorNumeric"><span class="symbol-name">FeatureExtractorNumeric</span><small class="property-type">
            &nbsp;Object</small></h3>            <p>The feature extractor of type <code>'numeric'</code>. Used for constructing <a href="module-qm.FeatureSpace.html">module:qm.FeatureSpace</a> objects.</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>var qm &#x3D; require(&#x27;qminer&#x27;);
// create a simple base, where each record contains the student name and it&#x27;s grade
var base &#x3D; new qm.Base({
   mode: &#x27;createClean&#x27;,
   schema: [{
      name: &quot;Class&quot;,
      fields: [
         { name: &quot;Name&quot;, type: &quot;string&quot; },
         { name: &quot;Grade&quot;, type: &quot;int&quot; }
      ]
   }]
});
// create a feature space containing the numeric extractor, where the values are
// normalized, the values are taken from the field &quot;Grade&quot;
var ftr &#x3D; new qm.FeatureSpace(base, { type: &quot;numeric&quot;, source: &quot;Class&quot;, normalize: &quot;scale&quot;, field: &quot;Grade&quot; });
// add a new record to the base
base.store(&quot;Class&quot;).push({ Name: &quot;Peterson&quot;, Grade: 9 });
base.store(&quot;Class&quot;).push({ Name: &quot;Ericsson&quot;, Grade: 8 });
// update the feature space for scaling
ftr.updateRecords(base.store(&quot;Class&quot;).allRecords);
// get the features of the first record
var vec &#x3D; ftr.extractVector(base.store(&quot;Class&quot;)[0]); // the vector with the random value
base.close();</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the extractor. <b>Important</b>: It must be equal <code>'numeric'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>normalize</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Normalize values between 0.0 and 1.0 if set to <code>'scale'</code>. Standardize values to mean = 0 and sdiv = 1 if set to <code>'var'</code>.</p>
                <p>Defaults to <code>'none'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>min</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>The minimal value used to form the normalization.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>max</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>The maximal value used to form the normalization.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>field</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the field from which to take the value.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>source</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The store name.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~FeatureExtractorPair"><span class="symbol-name">FeatureExtractorPair</span><small class="property-type">
            &nbsp;Object</small></h3>            <p>The feature extractor of type <code>'pair'</code>. Used for constructing <a href="module-qm.FeatureSpace.html">module:qm.FeatureSpace</a> objects.</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>var qm &#x3D; require(&#x27;qminer&#x27;);</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the extractor. <b>Important</b>: It must be equal <code>'pair'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>first</p>
        </td>
        <td>
                <p>module:qm~FeatureExtractors</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The first feature extractor.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>second</p>
        </td>
        <td>
                <p>module:qm~FeatureExtractors</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The second feature extractor.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>source</p>
        </td>
        <td>
                <p>source</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The store name.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~FeatureExtractorRandom"><span class="symbol-name">FeatureExtractorRandom</span><small class="property-type">
            &nbsp;Object</small></h3>            <p>The feature extractor of type <code>'random'</code>. Used for constructing <a href="module-qm.FeatureSpace.html">module:qm.FeatureSpace</a> objects.</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>var qm &#x3D; require(&#x27;qminer&#x27;);
// create a simple base, where each record contains only a persons name
var base &#x3D; new qm.Base({
  mode: &#x27;createClean&#x27;,
  schema: [{
     name: &quot;Person&quot;,
     fields: [{ name: &quot;Name&quot;, type: &quot;string&quot; }]
  }]
});
// create a feature space containing the random extractor
var ftr &#x3D; new qm.FeatureSpace(base, { type: &quot;random&quot;, source: &quot;Person&quot; });
// add a new record to the base
base.store(&quot;Person&quot;).push({ Name: &quot;Peterson&quot; });
// get the features of the record
var vec &#x3D; ftr.extractVector(base.store(&quot;Person&quot;)[0]); // the vector with the random value
base.close();</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the extractor. <b>Important</b>: It must be equal <code>'random'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>seed</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>The seed number used to construct the random number.</p>
                <p>Defaults to <code>0</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>source</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The store name.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~FeatureExtractorSparseVector"><span class="symbol-name">FeatureExtractorSparseVector</span><small class="property-type">
            &nbsp;Object</small></h3>            <p>The feature extractor of type <code>'num_sp_v'</code>. Used for constructing <a href="module-qm.FeatureSpace.html">module:qm.FeatureSpace</a> objects.</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>var qm &#x3D; require(&#x27;qminer&#x27;);
// create a simple base, where each record contains the student name and it&#x27;s grade
var base &#x3D; new qm.Base({
   mode: &#x27;createClean&#x27;,
   schema: [{
      &quot;name&quot;: &quot;Class&quot;,
      &quot;fields&quot;: [
         { &quot;name&quot;: &quot;Name&quot;, &quot;type&quot;: &quot;string&quot; },
         { &quot;name&quot;: &quot;Features&quot;, &quot;type&quot;: &quot;num_sp_v&quot; }
      ]
   }]
});
// create a feature space containing the numeric extractor, where the values are
// normalized, the values are taken from the field &quot;Grade&quot;
var ftr &#x3D; new qm.FeatureSpace(base, { type: &quot;num_sp_v&quot;, source: &quot;Class&quot;, normalize: false, field: &quot;Features&quot; });
base.close();</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the extractor. <b>Important</b>: It must be equal <code>'num_sp_v'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>dimension</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Dimensionality of sparse vectors.</p>
                <p>Defaults to <code>0</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>normalize</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Normalize vectors to L2 norm of 1.0.</p>
                <p>Defaults to <code>false</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>field</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the field from which to take the value.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>source</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The store name.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~FeatureExtractorText"><span class="symbol-name">FeatureExtractorText</span><small class="property-type">
            &nbsp;Object</small></h3>            <p>The feature extractor of type <code>'text'</code>. Used for constructing <a href="module-qm.FeatureSpace.html">module:qm.FeatureSpace</a> objects.</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>var qm &#x3D; require(&#x27;qminer&#x27;);
// create a simple base, where each record contains the title of the article and it&#x27;s content
var base &#x3D; new qm.Base({
   mode: &#x27;createClean&#x27;,
   schema: [{
      name: &quot;Articles&quot;,
      fields: [
         { name: &quot;Title&quot;, type: &quot;string&quot; },
         { name: &quot;Text&quot;, type: &quot;string&quot; }
      ]
   }]
});
// create a feature spave containing the text (bag of words) extractor, where the values are normalized,
// weighted with &#x27;tfidf&#x27; and the tokenizer is of &#x27;simple&#x27; type, it uses english stopwords.
var ftr &#x3D; new qm.FeatureSpace(base, {
    type: &quot;text&quot;, source: &quot;Articles&quot;, field: &quot;Text&quot;, normalize: true, weight: &quot;tfidf&quot;,
    tokenizer: { type: &quot;simple&quot;, stopwords: &quot;en&quot;}
});
// add a few records to the store
base.store(&quot;Articles&quot;).push({ Title: &quot;Article1&quot;, Text: &quot;The last time we drew up the league table for bad banks, UBS was on top.&quot; });
base.store(&quot;Articles&quot;).push({ Title: &quot;Article2&quot;, Text: &quot;Barclays dropped a bombshell on its investment bankers last week.&quot; });
// update the feature space to get the the terms for the bag-of-words text representation
ftr.updateRecords(base.store(&quot;Articles&quot;).allRecords);
// extract the feature vector for the first article
var vec &#x3D; ftr.extractSparseVector(base.store(&quot;Articles&quot;)[0]);
base.close();</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the extractor. <b>Important</b>: It must be equal <code>'text'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>normalize</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Normalize the resulting vector of the extractor to have L2 norm 1.0.</p>
                <p>Defaults to <code>'true'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>weight</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Type of weighting used for scoring terms. Possible options are:
<br>1. <code>'none'</code> - Sets 1 if the term occurs and 0 otherwise.
<br>2. <code>'tf'</code> - Sets the term frequency in the document.
<br>3. <code>'idf'</code> - Sets the inverse document frequency in the document.
<br>4. <code>'tfidf'</code> - Sets the product of the <code>tf</code> and <code>idf</code> frequency.</p>
                <p>Defaults to <code>'tfidf'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>hashDimension</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>A hashing code to set the fixed dimensionality. All values are hashed and divided modulo hashDimension to get the corresponding dimension.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>hashTable</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>If true, stores the hash table which is used for for feature naming.</p>
                <p>Defaults to <code>false</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>field</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the field from which to take the value.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>tokenizer</p>
        </td>
        <td>
                <p><a href="module-qm.html#~FeatureTokenizer">module:qm~FeatureTokenizer</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The settings for extraction of text.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>mode</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>How are multi-record cases combined into single vector. Possible options:
<br>1. <code>'concatenate'</code> - Multi-record cases are merged into one document.
<br>2. <code>'centroid'</code> - Treat each case as a seperate document.
<br>3. <code>'tokenized'</code> - use the tokenizer option.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>stream</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Details on forgetting old IDFs when running on stream. Possible options:
<br>1. <code>'field'</code> - Field name which is providing timestamp. If missing, system time is used (<i>optional</i>).
<br>2. <code>'factor'</code> - Forgetting factor, by which the olf IDFs are multiplied after each iteration.
<br>3. <code>'interval'</code> - The time between iterations when the factor is applied, standard JSON time format is used to specify the interval duration.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>source</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The store name.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~FeatureTokenizer"><span class="symbol-name">FeatureTokenizer</span><small class="property-type">
            &nbsp;Object</small></h3>            <p>The settings for extraction of text used in <a href="module-qm.html#~FeatureExtractorText">module:qm~FeatureExtractorText</a>.</p>

        
        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>The type of the encoding text. Possible options:
<br>1. <code>'simple'</code> - The simple encoding.
<br>2. <code>'html'</code> - The html encoding.
<br>3.B2<code>'unicode'</code> - The unicode encoding.</p>
                <p>Defaults to <code>'simple'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>stopwords</p>
        </td>
        <td>
                <p>(string or Array of string)</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>The stopwords used for extraction. Possible options:
<br>1. <code>'none'</code> - No pre-defined stopword list. Type <code>string</code>.
<br>2. <code>'en'</code> - The english pre-defined stopword list. Type <code>string</code>.
<br>3. <code>'si'</code> - The slovene pre-defined stopword list. Type <code>string</code>.
<br>4. <code>'es'</code> - The spanish pre-defined stopword list. Type <code>string</code>.
<br>5. <code>'de'</code> - The german pre-defined stopword list. Type <code>string</code>.
<br>6. <code>array</code> - An array of stopwords. The array must be given as a parameter. Type <code>Array of strings</code>.</p>
                <p>Defaults to <code>'en'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>stemmer</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>The stemmer used for extraction. Possible options:
<br>1. <code>'true'</code> - Using the porter stemmer.
<br>2. <code>'porter'</code> - Using the porter stemmer.
<br>3. <code>'none'</code> - Using no stemmer.</p>
                <p>Defaults to <code>'none'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>uppercase</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Changing all words to uppercase.</p>
                <p>Defaults to <code>'true'</code>.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~PerformanceStat"><span class="symbol-name">PerformanceStat</span><small class="property-type">
            &nbsp;object</small></h3>            <p>The performance statistics used to describe <a href="module-qm.html#~PerformanceStatBase">module:qm~PerformanceStatBase</a> and <a href="module-qm.html#~PerformanceStatStore">module:qm~PerformanceStatStore</a>.</p>

        
        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>alloc_count</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>\ TODO: Add the description</p>
        </td>
</tr>

                <tr>
        <td>
            <p>alloc_size</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>\ TODO: Add the description</p>
        </td>
</tr>

                <tr>
        <td>
            <p>alloc_unused_size</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>\ TODO: Add the description</p>
        </td>
</tr>

                <tr>
        <td>
            <p>avg_get_len</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>\ TODO: Add the description</p>
        </td>
</tr>

                <tr>
        <td>
            <p>avg_put_len</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>\ TODO: Add the description</p>
        </td>
</tr>

                <tr>
        <td>
            <p>avg_get_new_len</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>\ TODO: Add the description</p>
        </td>
</tr>

                <tr>
        <td>
            <p>dels</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>\ TODO: Add the description</p>
        </td>
</tr>

                <tr>
        <td>
            <p>gets</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>\ TODO: Add the description</p>
        </td>
</tr>

                <tr>
        <td>
            <p>puts</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>\ TODO: Add the description</p>
        </td>
</tr>

                <tr>
        <td>
            <p>puts_new</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>\ TODO: Add the description</p>
        </td>
</tr>

                <tr>
        <td>
            <p>released_count</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>\ TODO: Add the description</p>
        </td>
</tr>

                <tr>
        <td>
            <p>released_size</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>\ TODO: Add the description</p>
        </td>
</tr>

                <tr>
        <td>
            <p>size_changes</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>\ TODO: Add the description</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~PerformanceStatBase"><span class="symbol-name">PerformanceStatBase</span><small class="property-type">
            &nbsp;object</small></h3>            <p>The performance statistics that is returned by <a href="module-qm.Base.html#getStats">module:qm.Base#getStats</a>.</p>

        
        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>stores</p>
        </td>
        <td>
                <p>Array of <a href="module-qm.html#~PerformanceStatStore">module:qm~PerformanceStatStore</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The performance statistics of the stores in base. \ TODO: Check if this is right</p>
        </td>
</tr>

                <tr>
        <td>
            <p>gix_stats</p>
        </td>
        <td>
                <p>object</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The statistics of the base. \ TODO: Check if this is right</p>
                <p>Values in <code>gix_stats</code> have the following properties:</p>
                    <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>avg_len</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The average length. \ TODO: Check if this is right</p>
        </td>
</tr>

                <tr>
        <td>
            <p>cache_all</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The number of cache. \ TODO: Check if this is right</p>
        </td>
</tr>

                <tr>
        <td>
            <p>cache_all_loaded_perc</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>\ TODO: Add the description</p>
        </td>
</tr>

                <tr>
        <td>
            <p>cache_dirty</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>\ TODO: Add the description</p>
        </td>
</tr>

                <tr>
        <td>
            <p>cache_dirty_loaded_perc</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>\ TODO: Add the description</p>
        </td>
</tr>

                <tr>
        <td>
            <p>mem_sed</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>\ TODO: Add the description</p>
        </td>
</tr>

        </tbody>
</table>

        </td>
</tr>

                <tr>
        <td>
            <p>gix_blob</p>
        </td>
        <td>
                <p><a href="module-qm.html#~PerformanceStat">module:qm~PerformanceStat</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>\ TODO: Add the description</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~PerformanceStatStore"><span class="symbol-name">PerformanceStatStore</span><small class="property-type">
            &nbsp;object</small></h3>            <p>The performance statistics of the store found in <a href="module-qm.html#~PerformanceStatBase">module:qm~PerformanceStatBase</a>.</p>

        
        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>Store name.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>blob_storage_memory</p>
        </td>
        <td>
                <p><a href="module-qm.html#~PerformanceStat">module:qm~PerformanceStat</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>\ TODO: Add the description</p>
        </td>
</tr>

                <tr>
        <td>
            <p>blob_storage_cache</p>
        </td>
        <td>
                <p><a href="module-qm.html#~PerformanceStat">module:qm~PerformanceStat</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>\ TODO: Add the description</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~QMinerFlags"><span class="symbol-name">QMinerFlags</span><small class="property-type">
            &nbsp;Object</small></h3>            <p>The object containing the QMiner compile flags.</p>

        
        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>buildTime</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The module build time.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>win</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>True, if the module is compiled for Windows.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>linux</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>True, if the module is compiled for Linux.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>darwin</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>True, if the module is compiled for Darwin.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>x86</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>True, if the module is compiled for x86 system.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>x64</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>True, if the module is compiled for x64 system.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>omp</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>True, if the module is compiled for omp.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>debug</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>True, if the module is compiled for debug mode.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>gcc</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>True, if the module is compiled for gcc.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>clang</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>True, if the module is compiled for clang.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>blas</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>True, if the module is compiled with Blas.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>blas_intel</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>True, if the module is compiled with Intel Blas.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>blas_amd</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>True, if the module is compiled with AMD Blas.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>blas_openblas</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>True, if the module is compiled with OpenBLAS.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>lapacke</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>True, if the module is compiled with Lapacke.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~QueryObject"><span class="symbol-name">QueryObject</span><small class="property-type">
            &nbsp;object</small></h3>            <p>The object used for querying records with <a href="module-qm.Base.html#search">module:qm.Base#search</a>.
How to construct a query is found on the <a href="https://github.com/qminer/qminer/wiki/Query-Language">QMiner Wiki page</a>.</p>

        
        
        

        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~SchemaDef"><span class="symbol-name">SchemaDef</span><small class="property-type">
            &nbsp;Object</small></h3>            <p>Store schema definition used in <a href="module-qm.html#~BaseConstructorParam">module:qm~BaseConstructorParam</a>.</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>var qm &#x3D; require(&#x27;qminer&#x27;);
// create a simple movies store, where each record contains only the movie title.
var base &#x3D; new qm.Base({
    mode: &#x27;createClean&#x27;,
    schema: [{
      name: &quot;Movies&quot;,
      fields: [{ name: &quot;title&quot;, type: &quot;string&quot; }]
    }]
});
base.close();</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store. Store name can be composed by from English letters, numbers, _ or $ characters. It can only begin with a character.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>fields</p>
        </td>
        <td>
                <p>Array of <a href="module-qm.html#~SchemaFieldDef">module:qm~SchemaFieldDef</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The array of field descriptors.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>joins</p>
        </td>
        <td>
                <p>Array of <a href="module-qm.html#~SchemaJoinDef">module:qm~SchemaJoinDef</a></p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>The array of join descriptors, used for linking records from different stores.</p>
                <p>Defaults to <code>[]</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>keys</p>
        </td>
        <td>
                <p>Array of <a href="module-qm.html#~SchemaKeyDef">module:qm~SchemaKeyDef</a></p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>The array of key descriptors. Keys define how records are indexed, which is needed for search using the query language.</p>
                <p>Defaults to <code>[]</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>timeWindow</p>
        </td>
        <td>
                <p><a href="module-qm.html#~SchemaTimeWindowDef">module:qm~SchemaTimeWindowDef</a></p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Time window description. Stores can have a window, which is used by garbage collector to delete records once they fall out of the time window. Window can be defined by number of records or by time.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~SchemaFieldDef"><span class="symbol-name">SchemaFieldDef</span><small class="property-type">
            &nbsp;Object</small></h3>            <p>Store schema field definition used in <a href="module-qm.html#~SchemaDef">module:qm~SchemaDef</a>.</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>var qm &#x3D; require(&#x27;qminer&#x27;);
 var base &#x3D; new qm.Base({
     mode: &#x27;createClean&#x27;,
     schema: [
       { name: &#x27;NewsArticles&#x27;,
         fields: [
           { name: &quot;ID&quot;, primary: true, type: &quot;string&quot;, shortstring: true },
           { name: &quot;Source&quot;, type: &quot;string&quot;, codebook: true },
           { name: &quot;DateTime&quot;, type: &quot;datetime&quot; },
           { name: &quot;Title&quot;, type: &quot;string&quot;, store: &quot;cache&quot; },
           { name: &quot;Tokens&quot;, type: &quot;string_v&quot;, store: &quot;cache&quot;, null: true },
           { name: &quot;Vector&quot;, type: &quot;num_sp_v&quot;, store: &quot;cache&quot;, null: true }]
       }
    ]
 });
// add a record:
// - we set the date using the ISO string representation
// - we set the string vector Tokens with an array of strings
// - we set the numeric sparse vector Vector with an array of two element arrays
//   (index, value), see the sparse vector constructor {@link module:la.SparseVector}
base.store(&#x27;NewsArticles&#x27;).push({
  ID: &#x27;t12344&#x27;,
  Source: &#x27;s1234&#x27;,
  DateTime: &#x27;2015-01-01T00:05:00&#x27;,
  Title: &#x27;the title&#x27;,
  Tokens: [&#x27;token1&#x27;, &#x27;token2&#x27;],
  Vector: [[0,1], [1,1]]});
base.close();</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the field.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the field. Possible options:
<br>1. <code>'int'</code> - Signed 32-bit integer,
<br>2. <code>'uint64'</code> - Unsigned 64-bit integer,
<br>3. <code>'int_v'</code> - Array of signed 32-bit integers,
<br>4. <code>'string'</code> - String,
<br>5. <code>'string_v'</code> - Array of strings,
<br>6. <code>'bool'</code> - Boolean,
<br>7. <code>'float'</code> - Double precision flating point number,
<br>8. <code>'float_pair'</code> - A pair of floats, useful for storing geo coordinates,
<br>9. <code>'float_v'</code> - Array of floats,
<br>10. <code>'datetime'</code> - Date and time format, stored in a form of miliseconds since 1600,
<br>11. <code>'num_sp_v'</code> - Array of [<code>int</code>, <code>float</code>] pairs. See constructor array for <a href="module-la.SparseVector.html">module:la.SparseVector</a>,
<br>12. <code>'json'</code> - this field can be an arbitrary object and will be internally serialized into string using JSON notation,
<br>13. <code>'blob'</code> - Binary buffer, used for storing binary data,</p>
        </td>
</tr>

                <tr>
        <td>
            <p>primary</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Field which can be used to identify record. There can be only one primary field in a store. There can be at most one record for each value of the primary field. Currently following fields can be marked as primary: <code>int</code>, <code>uint64</code>, <code>string</code>, <code>float</code>, <code>datetime</code>. Primary fields of type <code>string</code> are also used for record querying using <a href="module-qm.Store.html#recordByName">module:qm.Store#recordByName</a>.</p>
                <p>Defaults to <code>false</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>null</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>When set to true, null is a possible value for a field (allow missing values).</p>
                <p>Defaults to <code>false</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>store</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Defines where to store the field. Possible options
<br>1. <code>'memory'</code> - Stores the values in RAM.
<br>2 <code>'cache'</code> - Stores the values on disk, with a layer of FIFO cache in RAM, storing the most recently used values.</p>
                <p>Defaults to <code>'memory'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>default</p>
        </td>
        <td>
                <p>Object</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Default value for field when not given for a new record.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>codebook</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Useful when many records have only few different values of this field. If set to true, then a separate table of all values is kept, and records only point to this table (replacing variable string field in record serialisation with fixed-length integer). Useful to decrease memory footprint, and faster to update. (STRING FIELD TYPE SPECIFIC).</p>
                <p>Defaults to <code>false</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>shortstring</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Useful for string shorter then 127 characters (STRING FIELD TYPE SPECIFIC).</p>
                <p>Defaults to <code>false</code>.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~SchemaJoinDef"><span class="symbol-name">SchemaJoinDef</span><small class="property-type">
            &nbsp;Object</small></h3>            <p>Store schema join definition used in <a href="module-qm.html#~SchemaDef">module:qm~SchemaDef</a>.</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>var qm &#x3D; require(&#x27;qminer&#x27;);
// Create two stores: People which stores only names of persons and Movies, which stores only titles.
// Each person can direct zero or more movies, so we use an index join named &#x27;directed&#x27; and
// each movie has a single director, so we use a field join &#x27;director&#x27;. The joins are
// inverses of each other. The inverse join simplifies the linking, since only one join needs
// to be specified, and the other direction can be linked automatically (in the example
// below we specify only the &#x27;director&#x27; link and the &#x27;directed&#x27; join is updated automatically).
//
var base &#x3D; new qm.Base({
    mode: &#x27;createClean&#x27;,
    schema: [
      { name: &#x27;People&#x27;,
        fields: [{ name: &#x27;name&#x27;, type: &#x27;string&#x27;, primary: true }],
        joins: [{ name: &#x27;directed&#x27;, &#x27;type&#x27;: &#x27;index&#x27;, &#x27;store&#x27;: &#x27;Movies&#x27;, &#x27;inverse&#x27;: &#x27;director&#x27; }] },
      { name: &#x27;Movies&#x27;,
        fields: [{ name: &#x27;title&#x27;, type: &#x27;string&#x27;, primary: true }],
        joins: [{ name: &#x27;director&#x27;, &#x27;type&#x27;: &#x27;field&#x27;, &#x27;store&#x27;: &#x27;People&#x27;, &#x27;inverse&#x27;: &#x27;directed&#x27; }] }
    ]
});
// Adds a movie, automatically adds &#x27;Jim Jarmusch&#x27; to People, sets the &#x27;director&#x27; join (field join)
// and automatically updates the index join &#x27;directed&#x27;, since it&#x27;s an inverse join of &#x27;director&#x27;
base.store(&#x27;Movies&#x27;).push({ title: &#x27;Broken Flowers&#x27;, director: { name: &#x27;Jim Jarmusch&#x27; } });

// Adds a movie, sets the &#x27;director&#x27; join, updates the index join of &#x27;Jim Jarmusch&#x27;
base.store(&#x27;Movies&#x27;).push({ title: &#x27;Coffee and Cigarettes&#x27;, director: { name: &#x27;Jim Jarmusch&#x27; } });
// Adds movie, automatically adds &#x27;Lars von Trier&#x27; to People, sets the &#x27;director&#x27; join
// and &#x27;directed&#x27; inverse join (automatically)
base.store(&#x27;Movies&#x27;).push({ title: &#x27;Dogville&#x27;, director: { name: &#x27;Lars von Trier&#x27; } });

// Adds a person, sets the &#x27;directed&#x27; join with multiple movies (&#x27;directed&#x27; is of type &#x27;index&#x27;, movies must be given in an array)
base.store(&#x27;People&#x27;).push({ name: &#x27;Christopher Nolan&#x27;, directed: [{ title: &#x27;Inception&#x27; }, { title: &#x27;Interstellar&#x27; }] });

var movie &#x3D; base.store(&#x27;Movies&#x27;)[0]; // get the first movie (Broken Flowers)
// Each movie has a property corresponding to the join name: &#x27;director&#x27;.
// Accessing the property returns a {@link module:qm.Record} from the store People.
var person &#x3D; movie.director; // get the director
var personName &#x3D; person.name; // get person&#x27;s name (&#x27;Jim Jarmusch&#x27;)

// Each person has a property corresponding to the join name: &#x27;directed&#x27;.
// Accessing the property returns a {@link module:qm.RecSet} from the store People.
var movies &#x3D; person.directed; // get all the movies the person directed.
movies.each(function (movie) { var title &#x3D; movie.title; });
// Gets the following titles:
//   &#x27;Broken Flowers&#x27;
//   &#x27;Coffee and Cigarettes&#x27;
base.close();</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the join.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>Join types. Possible options:
<br>1. <code>'field'</code> - Points to zero or one record and is implemented as an additional hidden field of type <code>uint64</code>, which can hold the ID of the record it links to. Accessing the records join returns a record.
<br>2. <code>'index'</code> - Point to any number of records and is implemented using the inverted index, where for each record a list (vector) of linked records is kept. Accessing the records join returns a record set.
<b>Important:</b> The records given to this join field must be in an array.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>store</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The store name from which the linked records are.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~SchemaKeyDef"><span class="symbol-name">SchemaKeyDef</span><small class="property-type">
            &nbsp;Object</small></h3>            <p>Store schema key definition used in <a href="module-qm.html#~SchemaDef">module:qm~SchemaDef</a>.</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>var qm &#x3D; require(&#x27;qminer&#x27;);
// Create a store People which stores only names of persons.
var base &#x3D; new qm.Base({
    mode: &#x27;createClean&#x27;,
    schema: [
        { name: &#x27;People&#x27;,
          fields: [{ name: &#x27;name&#x27;, type: &#x27;string&#x27;, primary: true }],
          keys: [
            { field: &#x27;name&#x27;, type: &#x27;value&#x27;},
            { field: &#x27;name&#x27;, name: &#x27;nameText&#x27;, type: &#x27;text&#x27;}
         ]
       }
    ]
});

base.store(&#x27;People&#x27;).push({name : &#x27;John Smith&#x27;});
base.store(&#x27;People&#x27;).push({name : &#x27;Mary Smith&#x27;});
// search based on indexed values
base.search({$from : &#x27;People&#x27;, name: &#x27;John Smith&#x27;}); // Return the record set containing &#x27;John Smith&#x27;
// search based on indexed values
base.search({$from : &#x27;People&#x27;, name: &#x27;Smith&#x27;}); // Returns the empty record set
// search based on text indexing
base.search({$from : &#x27;People&#x27;, nameText: &#x27;Smith&#x27;}); // Returns both records
base.close();</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>field</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the field that will be indexed.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>Key type. Possible options:
<br>1. <code>'value'</code> - Indexes records using an inverted index using full value of the field (no processing).
The key type supports <code>'string'</code>, <code>'string_v'</code> and <code>'datetime'</code> fields types.
<br>2. <code>'text'</code> - Indexes string fields by using a tokenizer and text processing. Supported by <code>'string'</code> fields.
<br>3. <code>'location'</code>- Indexes records as points on a sphere and enables nearest-neighbour queries. Supported by <code>'float_pair'</code> type fields.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Allows using a different name for the key in search queries. This allows for multiple keys to be put against the same field. Default value is the name of the field.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>vocabulary</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Defines the name of the vocabulary used to store the tokens or values. This can be used indicate to several keys to use the same vocabulary, to save on memory. Supported by <code>'value'</code> and <code>'text'</code> keys.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>tokenize</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Defines the tokenizer that is used for tokenizing the values stored in indexed fields. Tokenizer uses same parameters as in bag-of-words feature extractor. Default is english stopword list and no stemmer. Supported by <code>'text'</code> keys.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~SchemaTimeWindowDef"><span class="symbol-name">SchemaTimeWindowDef</span><small class="property-type">
            &nbsp;Object</small></h3>            <p>Stores can have a window, which is used by garbage collector to delete records once they
fall out of the time window. Window can be defined by number of records or by time.
Window defined by parameter window, its value being the number of records to be kept. Used in <a href="module-qm.html#~SchemaDef">module:qm~SchemaDef</a>.
<br><b>Important:</b> <a href="module-qm.Base.html#garbageCollect">module:qm.Base#garbageCollect</a> must be called manually to remove records outside time window.</p>

            <section>
        <h4>
            Examples
        </h4>
                <div>
        <p>Define window by number of records</p>
    <pre class="prettyprint"><code>var qm &#x3D; require(&#x27;qminer&#x27;);
// create base
var base &#x3D; new qm.Base({ mode: &#x27;createClean&#x27; });
// create store with window
base.createStore({
    &quot;name&quot;: &quot;TestStore&quot;,
    &quot;fields&quot;: [
        { &quot;name&quot;: &quot;DateTime&quot;, &quot;type&quot;: &quot;datetime&quot; },
        { &quot;name&quot;: &quot;Measurement&quot;, &quot;type&quot;: &quot;float&quot; }
    ],
    window: 3,
});

// push 5 records into created store
for (var i &#x3D; 0; i &lt; 5; i++) {
    var rec &#x3D; {
        &quot;DateTime&quot;: new Date().toISOString(),
        &quot;Measurement&quot;: i
    };
    base.store(&quot;TestStore&quot;).push(rec);
}

// check number of records in store
base.store(&quot;TestStore&quot;).allRecords.length; // 5
// clean base with garbage collector
base.garbageCollect();
// check number of records in store
base.store(&quot;TestStore&quot;).allRecords.length; // 3
base.close();</code></pre>
</div>

                <div>
        <p>Define window by time</p>
    <pre class="prettyprint"><code>var qm &#x3D; require(&#x27;qminer&#x27;);
// create base
var base &#x3D; new qm.Base({ mode: &#x27;createClean&#x27; });
// create store with window
base.createStore({
    &quot;name&quot;: &quot;TestStore&quot;,
    &quot;fields&quot;: [
        { &quot;name&quot;: &quot;DateTime&quot;, &quot;type&quot;: &quot;datetime&quot; },
        { &quot;name&quot;: &quot;Measurement&quot;, &quot;type&quot;: &quot;float&quot; }
    ],
    timeWindow: {
        duration: 2,
        unit: &quot;hour&quot;,
        field: &quot;DateTime&quot;
    }
});

// push 5 records into created store
for (var i &#x3D; 0; i &lt; 5; i++) {
    var rec &#x3D; {
        &quot;DateTime&quot;: new Date(new Date().getTime() + i * 60 * 60 * 1001).toISOString(),
        &quot;Measurement&quot;: i
    };
    base.store(&quot;TestStore&quot;).push(rec);
}

// check number of records in store
base.store(&quot;TestStore&quot;).allRecords.length; // 5
// clean base with garbage collector
base.garbageCollect();
// check number of records in store
base.store(&quot;TestStore&quot;).allRecords.length; // 2
base.close();</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>duration</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The size of the time window (in number of units).</p>
        </td>
</tr>

                <tr>
        <td>
            <p>unit</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>Defines in which units the window size is specified. Possible options are <code>'second'</code>, <code>'minute'</code>, <code>'hour'</code>, <code>'day'</code>, <code>'week'</code> or <code>'month'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>field</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Name of the datetime field, which defines the time of the record. In case it is not given, the insert time is used in its place.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~StreamAggrAggrResampler"><span class="symbol-name">StreamAggrAggrResampler</span><small class="property-type">
            &nbsp;<a href="module-qm.StreamAggr.html">module:qm.StreamAggr</a></small></h3>            <p>This stream aggregate resamples an input time series to a new time seris
of equally spaced measurements. Each new measurement corresponds to an
aggregate (sum,avg,min,max) computed over an interval. The aggregate
exposes the following methods.
<br>1. <a href="module-qm.StreamAggr.html#getFloat">module:qm.StreamAggr#getFloat</a> returns the last resampled value.
<br>2. <a href="module-qm.StreamAggr.html#getTimestamp">module:qm.StreamAggr#getTimestamp</a> returns the timestamp of the last resampled value.
<br>3. <a href="module-qm.StreamAggr.html#onStep">module:qm.StreamAggr#onStep</a> reads from an input aggregate and tries to resample.
<br>4. <a href="module-qm.StreamAggr.html#onTime">module:qm.StreamAggr#onTime</a> updates the current time (no data has arrived, but time has passed) and tries to resample.
<br>5. <a href="module-qm.StreamAggr.html#getParams">module:qm.StreamAggr#getParams</a> returns a parameter object.
<br>6. <a href="module-qm.StreamAggr.html#setParams">module:qm.StreamAggr#setParams</a> used primarily for setting the out-aggregate.
<br>The stream aggregate exposes its results through <code>getFloat</code> and <code>getTimestamp</code> methods (itself represents timeseries).
The resampler has an input time-series aggregate (supports <code>getFloat</code> and <code>getTimestamp</code>), from where it reads time series values.
The reading and resampling occourrs wehen resamplers <code>onStep()</code> or <code>onTime()</code> methods are called.
When resampling succeeds (all the data needed for the computation becomes available), the resampler
will trigger the <code>onStep()</code> method of an output stream aggregate that will read the resamplers state through <code>getFloat</code> and <code>getTime</code>.</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>var qm &#x3D; require(&#x27;qminer&#x27;);
// create a base with a simple timeseries store
var base &#x3D; new qm.Base({
    mode: &#x27;createClean&#x27;,
    schema: [{
        name: &#x27;default&#x27;,
        fields: [
            { name: &#x27;timestamp&#x27;, type: &#x27;datetime&#x27; },
            { name: &#x27;value&#x27;, type: &#x27;float&#x27; }
        ]
    }]
});
var store &#x3D; base.store(&#x27;default&#x27;);
// the tick aggregate reads from the store (provides time series input to other aggregates)
var raw &#x3D; store.addStreamAggr({
    type: &#x27;timeSeriesTick&#x27;,
    timestamp: &#x27;timestamp&#x27;,
    value: &#x27;value&#x27;
});

// will compute sums over 1 second intervals
var resampler &#x3D; store.addStreamAggr({
    type: &#x27;aggrResample&#x27;,
    inAggr: raw.name,
    start: &#x27;1970-01-01T00:00:00.000&#x27;,
    defaultValue: 0,
    aggType: &#x27;sum&#x27;,
    interval: 1000
});

// will print out resampler state on each resample
var resamplerOutput &#x3D; new qm.StreamAggr(base, new function () {
    this.onStep &#x3D; function () {
        console.log(&#x27;Resampler emitted the sum: &#x27; + resampler.getFloat() +
            &#x27; for the interval [&#x27; + new Date(resampler.getTimestamp()).toISOString() +
            &#x27; - &#x27; + new Date(resampler.getTimestamp() + resampler.getParams().interval).toISOString() + &#x27;)&#x27;);
    }
});

// IMPORTANT. After the output exists, connect it to resampler
resampler.setParams({ outAggr: resamplerOutput.name });

store.push({ timestamp:  1, value: 1 });
store.push({ timestamp: 10, value: 10 });
store.push({ timestamp: 500, value: 100 });
store.push({ timestamp: 2000, value: 1000 }); // triggers two resampling steps (two intervals complete)
// // three measurements for the first interval
// Resampler emitted the sum: 111 for the interval [1970-01-01T00:00:00.000Z - 1970-01-01T00:00:01.000Z)
// // zero measurements for the second interval (does not skip empty)
// Resampler emitted the sum: 0 for the interval [1970-01-01T00:00:01.000Z - 1970-01-01T00:00:02.000Z)
store.push({ timestamp: 2001, value: 10000 });
store.push({ timestamp: 3000, value: 100000 }); // triggers one resampling step (one interval complete)
// // one measurement for the third interval
// Resampler emitted the sum: 11000 for the interval [1970-01-01T00:00:02.000Z - 1970-01-01T00:00:03.000Z)

base.close();</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the stream aggregator. <b>Important:</b> It must be equal to <code>'aggrResampler'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>interval</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>Interval size in milliseconds</p>
        </td>
</tr>

                <tr>
        <td>
            <p>aggType</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>Must be one of the values: <code>&quot;sum&quot;</code>, <code>&quot;avg&quot;</code>, <code>&quot;min&quot;</code> or <code>&quot;max&quot;</code> - represents the function executed on the data values in the interval.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>inAggr</p>
        </td>
        <td>
                <p>(string or <a href="module-qm.StreamAggr.html">module:qm.StreamAggr</a>)</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the input stream aggregate which must implement <code>getFloat()</code> and <code>getTimestamp()</code> methods.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>start</p>
        </td>
        <td>
                <p>(string or number)</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Start time (linux timestamp or a web log date string like <code>1970-01-01T00:00:00.000</code>)</p>
        </td>
</tr>

                <tr>
        <td>
            <p>roundStart</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Must be one of the values: <code>'h'</code>, <code>'m'</code> or <code>'s'</code> - represents rounding of the start time when it must be determined by the first observed record. <code>'h'</code> will clip minutes, seconds and milliseconds, <code>'m'</code> will clip seconds and milliseconds and <code>'s'</code> will clip only milliseconds.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>defaultValue</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>default value for empty intervals (no data available).</p>
                <p>Defaults to <code>0</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>skipEmpty</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>If true, the resampler will not call the <code>onStep</code> method of the out-aggregate when the interval is empty (for example, average of an empty set is not defined).</p>
                <p>Defaults to <code>false</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>The given name for the stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>outAggr</p>
        </td>
        <td>
                <p>(string or <a href="module-qm.StreamAggr.html">module:qm.StreamAggr</a>)</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>The name of the output stream aggregate. Only useful when the <code>outAggr</code> is a javascript stream aggregate, otherwise the output must be set by calling <code>setParam({outAggr: outAggregateName})</code>.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~StreamAggrAnomalyDetectorNN"><span class="symbol-name">StreamAggrAnomalyDetectorNN</span><small class="property-type">
            &nbsp;module:qmStreamAggr</small></h3>            <p>This stream aggregator represents the anomaly detector using the Nearest Neighbor algorithm. It calculates the
new incoming point's distance from its nearest neighbor and, depending on the input threshold values, it
classifies the severity of the alarm. It implements the following methods:
<br>1. <a href="module-qm.StreamAggr.html#getInteger">module:qm.StreamAggr#getInteger</a> returns the severity of the alarm.
<br>2. <a href="module-qm.StreamAggr.html#getTimestamp">module:qm.StreamAggr#getTimestamp</a> returns the timestamp of the latest alarm.
<br>3. <a href="module-qm.StreamAggr.html#saveJson">module:qm.StreamAggr#saveJson</a> returns the Json with the description and explanation of the alarm.</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import the qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a base with a simple store named Cars with 4 fields
var base &#x3D; new qm.Base({
    mode: &#x27;createClean&#x27;,
    schema: [{
        name: &#x27;Cars&#x27;,
        fields: [
            { name: &#x27;NumberOfCars&#x27;, type: &#x27;float&#x27; },
            { name: &#x27;Temperature&#x27;, type: &#x27;float&#x27; },
            { name: &#x27;Precipitation&#x27;, type: &#x27;float&#x27; },
            { name: &#x27;Time&#x27;, type: &#x27;datetime&#x27; }
        ]
    }]
});
// create the store
var store &#x3D; base.store(&#x27;Cars&#x27;);
// define a feature space aggregator on the Cars store which needs at least 2 records to be initialized. Use three of the
// four fields of the store to create feature vectors with normalized values.
var aggr &#x3D; {
   name: &quot;ftrSpaceAggr&quot;,
   type: &quot;featureSpace&quot;,
   initCount: 2,
   update: true, full: false, sparse: true,
   featureSpace: [
       { type: &quot;numeric&quot;, source: &quot;Cars&quot;, field: &quot;NumberOfCars&quot;, normalize: &quot;var&quot; },
       { type: &quot;numeric&quot;, source: &quot;Cars&quot;, field: &quot;Temperature&quot;, normalize: &quot;var&quot; },
       { type: &quot;numeric&quot;, source: &quot;Cars&quot;, field: &quot;Precipitation&quot;, normalize: &quot;var&quot; }
   ]
};
//create the feature space aggregator
var ftrSpaceAggr &#x3D; base.store(&#x27;Cars&#x27;).addStreamAggr(aggr);
// define a new time series tick stream aggregator for the &#x27;Cars&#x27; store, that takes the values from the &#x27;NumberOfCars&#x27; field
// and the timestamp from the &#x27;Time&#x27; field.
var aggr &#x3D; {
    name: &quot;tickAggr&quot;,
    type: &quot;timeSeriesTick&quot;,
    store: &quot;Cars&quot;,
    timestamp: &quot;Time&quot;,
    value: &quot;NumberOfCars&quot;
};
//create the tick aggregator
var tickAggr &#x3D; base.store(&#x27;Cars&#x27;).addStreamAggr(aggr);

//define an anomaly detection aggregator using nearest neighbor on the cars store that takes as input timestamped features.
// The time stamp is provided by the tick aggregator while the feature vector is provided by the feature space aggregator.
var aggr &#x3D; {
    name: &#x27;AnomalyDetectorAggr&#x27;,
    type: &#x27;nnAnomalyDetector&#x27;,
    inAggrSpV: &#x27;ftrSpaceAggr&#x27;,
    inAggrTm: &#x27;tickAggr&#x27;,
    rate: [0.7, 0.5, 0.15],
    windowSize: 2
};
//create the anomaly detection aggregator
var anomaly &#x3D; base.store(&#x27;Cars&#x27;).addStreamAggr(aggr);
base.close();</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The given name for the stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the stream aggregator. <b>Important:</b> It must be equal to <code>'nnAnomalyDetector'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>store</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store from which it takes the data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>inAggr</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the stream aggregator to which it connects and gets data.
It <b>cannot</b> be connect to the <a href="module-qm.html#~StreamAggrTimeSeriesWindow">module:qm~StreamAggrTimeSeriesWindow</a>.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~StreamAggregator"><span class="symbol-name">StreamAggregator</span><small class="property-type">
            &nbsp;<a href="module-qm.StreamAggr.html">module:qm.StreamAggr</a></small></h3>            <p>Stream aggregator types.</p>

        
        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>timeSeries</p>
        </td>
        <td>
                <p><a href="module-qm.html#~StreamAggrTimeSeriesWindow">module:qm~StreamAggrTimeSeriesWindow</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The time series type.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>timeSeriesBufferVector</p>
        </td>
        <td>
                <p><a href="module-qm.html#~StreamAggrTimeSeriesWindowVector">module:qm~StreamAggrTimeSeriesWindowVector</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The time series buffer vector type.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>tick</p>
        </td>
        <td>
                <p><a href="module-qm.html#~StreamAggrTimeSeriesTick">module:qm~StreamAggrTimeSeriesTick</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The time series tick type.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>record-buffer</p>
        </td>
        <td>
                <p><a href="module-qm.html#~StreamAggrRecordBuffer">module:qm~StreamAggrRecordBuffer</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The record buffer type.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>ftr-space</p>
        </td>
        <td>
                <p><a href="module-qm.html#~StreamAggrFeatureSpace">module:qm~StreamAggrFeatureSpace</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The feature space type.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>sum</p>
        </td>
        <td>
                <p><a href="module-qm.html#~StreamAggrSum">module:qm~StreamAggrSum</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The sum type. Calculates the sum of values.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>min</p>
        </td>
        <td>
                <p><a href="module-qm.html#~StreamAggrMin">module:qm~StreamAggrMin</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The minimal type. Saves the minimal value in the buffer.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>max</p>
        </td>
        <td>
                <p><a href="module-qm.html#~StreamAggrMax">module:qm~StreamAggrMax</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The maximal type. Saves the maximal value in the buffer.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>sparse-vec-sum</p>
        </td>
        <td>
                <p><a href="module-qm.html#~StreamAggrSparseVecSum">module:qm~StreamAggrSparseVecSum</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The sparse-vector-sum type.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>ma</p>
        </td>
        <td>
                <p><a href="module-qm.html#~StreamAggrMovingAverage">module:qm~StreamAggrMovingAverage</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The moving average type. Calculates the average within the window.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>ema</p>
        </td>
        <td>
                <p><a href="module-qm.html#~StreamAggrEMA">module:qm~StreamAggrEMA</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The exponental moving average type. Calculates the exponental average of the values.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>ema-sp-vec</p>
        </td>
        <td>
                <p><a href="module-qm.html#~StreamAggrEMASpVec">module:qm~StreamAggrEMASpVec</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The exponental moving average for sparse vectors type.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>var</p>
        </td>
        <td>
                <p><a href="module-qm.html#~StreamAggrMovingVariance">module:qm~StreamAggrMovingVariance</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The moving variance type. Calculates the variance of values within the window.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>cov</p>
        </td>
        <td>
                <p><a href="module-qm.html#~StreamAggrMovingCovariance">module:qm~StreamAggrMovingCovariance</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The moving covariance type. Calculates the covariance of values within the window.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>cor</p>
        </td>
        <td>
                <p><a href="module-qm.html#~StreamAggrMovingCorrelation">module:qm~StreamAggrMovingCorrelation</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The moving correlation type. Calculates the correlation of values within the window.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>res</p>
        </td>
        <td>
                <p><a href="module-qm.html#~StreamAggrResampler">module:qm~StreamAggrResampler</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The resampler type. Resamples the records so that they come in in the same time interval.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>aggr-res</p>
        </td>
        <td>
                <p><a href="module-qm.html#~StreamAggrAggrResampler">module:qm~StreamAggrAggrResampler</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The aggregating (avg/sum) resampler type. Resamplers the records so that it takes the
records in the time window and returns one sample.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>mer</p>
        </td>
        <td>
                <p><a href="module-qm.html#~StreamAggrMerger">module:qm~StreamAggrMerger</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The merger type. Merges the records from two stream series.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>hist</p>
        </td>
        <td>
                <p><a href="module-qm.html#~StreamAggrHistogram">module:qm~StreamAggrHistogram</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The online histogram type.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>slotted-hist</p>
        </td>
        <td>
                <p><a href="module-qm.html#~StreamAggrSlottedHistogram">module:qm~StreamAggrSlottedHistogram</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The online slotted-histogram type.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>vec-diff</p>
        </td>
        <td>
                <p><a href="module-qm.html#~StreamAggrVecDiff">module:qm~StreamAggrVecDiff</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The difference of two vectors (e.g. online histograms) type.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>lin-reg</p>
        </td>
        <td>
                <p><a href="module-qm.html#~StreamAggrSimpleLinearRegression">module:qm~StreamAggrSimpleLinearRegression</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The linear regressor type.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>detector-nn</p>
        </td>
        <td>
                <p><a href="module-qm.html#~StreamAggrAnomalyDetectorNN">module:qm~StreamAggrAnomalyDetectorNN</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The anomaly detector type. Detects anomalies using the k nearest neighbour algorithm.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>treshold</p>
        </td>
        <td>
                <p><a href="module-qm.html#~StreamAggrThreshold">module:qm~StreamAggrThreshold</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The threshold indicator type.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>tdigest</p>
        </td>
        <td>
                <p><a href="module-qm.html#~StreamAggrTDigest">module:qm~StreamAggrTDigest</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The quantile estimator type. It estimates the quantiles of the given data using <a href="module-analytics.TDigest.html">TDigest</a>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>record-switch-aggr</p>
        </td>
        <td>
                <p><a href="module-qm.html#~StreamAggrRecordSwitch">module:qm~StreamAggrRecordSwitch</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The record switch type.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>pagehinkley</p>
        </td>
        <td>
                <p><a href="module-qm.html#~StreamAggrPageHinkley">module:qm~StreamAggrPageHinkley</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The Page-Hinkley test for concept drift detection type.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~StreamAggrEMA"><span class="symbol-name">StreamAggrEMA</span><small class="property-type">
            &nbsp;module:qmStreamAggr</small></h3>            <p>This stream aggregator represents the exponential moving average window buffer. It calculates the weighted moving average
of the values in the connected stream aggregator, where the weights are exponentially decreasing.  It implements the following methods:
<br>1. <a href="module-qm.StreamAggr.html#getFloat">module:qm.StreamAggr#getFloat</a> returns the exponentional average of the values in its buffer window.
<br>2. <a href="module-qm.StreamAggr.html#getTimestamp">module:qm.StreamAggr#getTimestamp</a> returns the timestamp of the newest record in its buffer window.</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import the qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a base with a simple store
var base &#x3D; new qm.Base({
   mode: &quot;createClean&quot;,
   schema: [
   {
       name: &quot;Heat&quot;,
       fields: [
           { name: &quot;Celsius&quot;, type: &quot;float&quot; },
           { name: &quot;Time&quot;, type: &quot;datetime&quot; }
       ]
   }]
});

// create a new time series tick stream aggregator for the &#x27;Heat&#x27; store, that takes the values from the &#x27;Celsius&#x27; field
// and the timestamp from the &#x27;Time&#x27; field. The size of the window should be 1 hour.
var timeser &#x3D; {
   name: &#x27;TimeSeriesAggr&#x27;,
   type: &#x27;timeSeriesTick&#x27;,
   store: &#x27;Heat&#x27;,
   timestamp: &#x27;Time&#x27;,
   value: &#x27;Celsius&#x27;
};
var timeSeries &#x3D; base.store(&quot;Heat&quot;).addStreamAggr(timeser);

// add an exponentional moving average aggregator, that is connected with the &#x27;TimeSeriesAggr&#x27; aggregator.
// It should interpolate with the previous value, the decay should be 3 seconds and the initWindow should be 2 seconds.
var ema &#x3D; {
   name: &#x27;emaAggr&#x27;,
   type: &#x27;ema&#x27;,
   store: &#x27;Heat&#x27;,
   inAggr: &#x27;TimeSeriesAggr&#x27;,
   emaType: &#x27;previous&#x27;,
   interval: 3000,
   initWindow: 2000
};
var expoMovingAverage &#x3D; base.store(&quot;Heat&quot;).addStreamAggr(ema);
base.close();</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The given name for the stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the stream aggregator. <b>Important:</b> It must be equal to <code>'ema'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>store</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store from which it takes the data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>inAggr</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the stream aggregator to which it connects and gets data.
It <b>cannot</b> be connect to the <a href="module-qm.html#~StreamAggrTimeSeriesWindow">module:qm~StreamAggrTimeSeriesWindow</a>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>emaType</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of interpolation. Possible options are:
<br>1. <code>'previous'</code> - Interpolates with the previous value.
<br>2. <code>'next'</code> - Interpolates with the next value.
<br>3. <code>'linear'</code> - Makes a linear interpolation.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>interval</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The time interval defining the decay. It must be greater than <code>initWindow</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>initWindow</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The time window of required values for initialization.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~StreamAggrEMASpVec"><span class="symbol-name">StreamAggrEMASpVec</span><small class="property-type">
            &nbsp;module:qmStreamAggr</small></h3>            <p>This stream aggregator represents the exponential moving average window buffer for sparse vectors. It calculates the weighted moving average
of the values in the connected stream aggregator, where the weights are exponentially decreasing. It implements the following methods:
<br>1. <a href="module-qm.StreamAggr.html#getValueVector">module:qm.StreamAggr#getValueVector</a> returns the exponentional average of the sparse vector values in its buffer window.
<br>2. <a href="module-qm.StreamAggr.html#getTimestamp">module:qm.StreamAggr#getTimestamp</a> returns the timestamp of the newest record in its buffer window.</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import the qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a base with a simple store
var base &#x3D; new qm.Base({
   mode: &quot;createClean&quot;,
   schema: [
   {
       name: &quot;Data&quot;,
       fields: [
           { name: &quot;Text&quot;, type: &quot;string&quot; },
           { name: &quot;Time&quot;, type: &quot;datetime&quot; }
       ]
   }]
});
var store &#x3D; base.store(&quot;Data&quot;);
// create a new time series that emits data as sparse vector, based on text
var aggr &#x3D; {
   name: &#x27;featureSpaceWindow&#x27;,
   type: &#x27;timeSeriesWinBufFeatureSpace&#x27;,
   store: store.name,
   timestamp: &#x27;Time&#x27;,
   featureSpace: {
      type: &quot;categorical&quot;,
      source: store.name,
      field: &quot;Text&quot;
   },
   winsize: 1 // keep only most recent value in window
};
// attach sum
var sa &#x3D; store.addStreamAggr(aggr);
var aggr2 &#x3D; {
   name: &#x27;sparseVectorSum&#x27;,
   type: &#x27;winBufSpVecSum&#x27;,
   store: store.name,
   inAggr: aggr.name // this means that sum is equal to the most recent data
};
// ok, now attach EMA
var sa2 &#x3D; store.addStreamAggr(aggr2);
var ema_def &#x3D; {
   name: &#x27;sparseVectorEma&#x27;,
   type: &#x27;emaSpVec&#x27;,
   store: store.name,
   inAggr: aggr2.name,
   emaType: &quot;next&quot;,
   interval: 2000,
   initWindow: 0
};
var ema &#x3D; store.addStreamAggr(ema_def);
// add some data
store.push({ Time: 1000, Text: &#x27;a&#x27; });
store.push({ Time: 2000, Text: &#x27;b&#x27; });
store.push({ Time: 3000, Text: &#x27;c&#x27; });
// display EMA data
ema.getValueVector().print();
base.close();</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The given name for the stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the stream aggregator. <b>Important:</b> It must be equal to <code>'ema'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>store</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store from which it takes the data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>inAggr</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the stream aggregator to which it connects and gets data.
It <b>cannot</b> be connect to the <a href="module-qm.html#~StreamAggrTimeSeriesWindow">module:qm~StreamAggrTimeSeriesWindow</a>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>emaType</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of interpolation. Possible options:
<br>1. <code>'previous'</code> - Interpolates with the previous value.
<br>2. <code>'next'</code> - Interpolates with the next value.
<br>3. <code>'linear'</code> - Makes a linear interpolation.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>interval</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The time interval defining the decay. It must be greater than <code>initWindow</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>initWindow</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>The time window of required values for initialization.</p>
                <p>Defaults to <code>0</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>cuttof</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Minimal value for any dimension. If value of certain dimension falls bellow this value, the dimension is pruned from average.</p>
                <p>Defaults to <code>0.001</code>.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~StreamAggrFeatureSpace"><span class="symbol-name">StreamAggrFeatureSpace</span><small class="property-type">
            &nbsp;module:qmStreamAggr</small></h3>            <p>This stream aggregator creates the feature space and stores the specified features of the last input. It implements the following methods:
<br>1. <a href="module-qm.StreamAggr.html#getFloatVector">module:qm.StreamAggr#getFloatVector</a> returns the dense feature vectors.
<br>2. <a href="module-qm.StreamAggr.html#getFeatureSpace">module:qm.StreamAggr#getFeatureSpace</a> returns the feature space.</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import the qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a base with a simple store named Cars with 4 fields
var base &#x3D; new qm.Base({
    mode: &#x27;createClean&#x27;,
    schema: [{
        name: &#x27;Cars&#x27;,
        fields: [
            { name: &#x27;NumberOfCars&#x27;, type: &#x27;float&#x27; },
            { name: &#x27;Temperature&#x27;, type: &#x27;float&#x27; },
            { name: &#x27;Precipitation&#x27;, type: &#x27;float&#x27; },
            { name: &#x27;Time&#x27;, type: &#x27;datetime&#x27; }
        ]
    }]
});
// create the store
var store &#x3D; base.store(&#x27;Cars&#x27;);
// define a feature space aggregator on the Cars store which needs at least 2 records to be initialized. Use three of the
// four fields of the store to create feature vectors with normalized values.
var aggr &#x3D; {
   name: &quot;ftrSpaceAggr&quot;,
   type: &quot;featureSpace&quot;,
   initCount: 2,
   update: true, full: false, sparse: true,
   featureSpace: [
       { type: &quot;numeric&quot;, source: &quot;Cars&quot;, field: &quot;NumberOfCars&quot;, normalize: &quot;var&quot; },
       { type: &quot;numeric&quot;, source: &quot;Cars&quot;, field: &quot;Temperature&quot;, normalize: &quot;var&quot; },
       { type: &quot;numeric&quot;, source: &quot;Cars&quot;, field: &quot;Precipitation&quot;, normalize: &quot;var&quot; }
   ]
};
//create the feature space aggregator
var ftrSpaceAggr &#x3D; base.store(&#x27;Cars&#x27;).addStreamAggr(aggr);
base.close();</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The given name for the stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the stream aggregator. <b>Important:</b> It must be equal to <code>'featureSpace'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>store</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store from which it takes the data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>initCount</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The number of records needed before it initializes.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>update</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>If true, updates the feature space.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>full</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>If true, saves the full vector of features.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>sparse</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>If true, saves the sparse vector of features.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>FeatureSpace</p>
        </td>
        <td>
                <p>Array of <a href="module-qm.html#~FeatureExtractor">module:qm~FeatureExtractor</a></p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>Array of feature extractors.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~StreamAggrHistogram"><span class="symbol-name">StreamAggrHistogram</span><small class="property-type">
            &nbsp;<a href="module-qm.StreamAggr.html">module:qm.StreamAggr</a></small></h3>            <p>This stream aggregator represents an online histogram. It can connect to a buffered aggregate (such as <a href="module-qm.html#~StreamAggrTimeSeriesWindow">module:qm~StreamAggrTimeSeriesWindow</a>)
or a time series (such as module:qm~StreamAggregateEMA).
The aggregate defines an ordered set of points <code>p(0), ..., p(n)</code> that define n bins. Infinites at both ends are allowed.
A new measurement is tested for inclusion in the left-closed right-opened intervals <code>[p(i), p(i+1))</code> and the corresponding
bin counter is increased for the appropriate bin (or decreased if the point is outgoing from the buffer).
It implements the following methods:
<br>1. <a href="module-qm.StreamAggr.html#getFloatLength">module:qm.StreamAggr#getFloatLength</a> returns the number of bins.
<br>2. <a href="module-qm.StreamAggr.html#getFloatAt">module:qm.StreamAggr#getFloatAt</a> returns the count for a bin index.
<br>3. <a href="module-qm.StreamAggr.html#getFloatVector">module:qm.StreamAggr#getFloatVector</a> returns the vector of counts, the length is equal to the number of bins.</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import the qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a base with a simple store
var base &#x3D; new qm.Base({
   mode: &quot;createClean&quot;,
   schema: [
   {
       name: &quot;Heat&quot;,
       fields: [
           { name: &quot;Celsius&quot;, type: &quot;float&quot; },
           { name: &quot;Time&quot;, type: &quot;datetime&quot; }
       ]
   }]
});

// create a new time series stream aggregator for the &#x27;Heat&#x27; store, that takes the values from the &#x27;Celsius&#x27; field
// and the timestamp from the &#x27;Time&#x27; field. The size of the window is 1 day.
var timeser &#x3D; {
   name: &#x27;TimeSeriesBuffer&#x27;,
   type: &#x27;timeSeriesWinBuf&#x27;,
   store: &#x27;Heat&#x27;,
   timestamp: &#x27;Time&#x27;,
   value: &#x27;Celsius&#x27;,
   winsize: 86400000 // one day in miliseconds
};
var timeSeries &#x3D; base.store(&quot;Heat&quot;).addStreamAggr(timeser);

// add a histogram aggregator, that is connected with the &#x27;TimeSeriesAggr&#x27; aggregator
var aggrJson &#x3D; {
   name: &#x27;Histogram&#x27;,
   type: &#x27;onlineHistogram&#x27;,
   store: &#x27;Heat&#x27;,
   inAggr: &#x27;TimeSeriesBuffer&#x27;,
   lowerBound: 0,
   upperBound: 10,
   bins: 5,
   addNegInf: false,
   addPosInf: false
};
var hist &#x3D; base.store(&quot;Heat&quot;).addStreamAggr(aggrJson);
base.close();</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The given name of the stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type for the stream aggregator. <b>Important:</b> It must be equal to <code>'onlineHistogram'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>store</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store from which it takes the data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>inAggr</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the stream aggregator to which it connects and gets data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>lowerBound</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The lowest non-infinite bin point.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>upperBound</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The highest non-infinite bin point.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>bins</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>The number of bins bounded by <code>lowerBound</code> and <code>upperBound</code>.</p>
                <p>Defaults to <code>5</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>addNegInf</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Include a bin <code>[-Inf, lowerBound]</code>.</p>
                <p>Defaults to <code>false</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>addPosInf</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Include a bin <code>[upperBound, Inf]</code>.</p>
                <p>Defaults to <code>false</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>autoResize</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>The histogram will be empty at the beginning and double its size on demand (resize only when incrementing counts). The unbounded bins are guaranteed to stay between lowerBound and upperBound and in all cases the bin size equals (upperBound - lowerBound)/bins.</p>
                <p>Defaults to <code>false</code>.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~StreamAggrMax"><span class="symbol-name">StreamAggrMax</span><small class="property-type">
            &nbsp;<a href="module-qm.StreamAggr.html">module:qm.StreamAggr</a></small></h3>            <p>This stream aggregator represents the maximum moving window buffer. It monitors the maximal value in the connected stream aggregator.
It implements the following methods:
<br>1. <a href="module-qm.StreamAggr.html#getFloat">module:qm.StreamAggr#getFloat</a> returns the maximal value of the records in its buffer window.
<br>2. <a href="module-qm.StreamAggr.html#getTimestamp">module:qm.StreamAggr#getTimestamp</a> returns the timestamp of the newest record in its buffer window.</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import the qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a base with a simple store
var base &#x3D; new qm.Base({
   mode: &quot;createClean&quot;,
   schema: [
   {
       name: &quot;Heat&quot;,
       fields: [
           { name: &quot;Celsius&quot;, type: &quot;float&quot; },
           { name: &quot;Time&quot;, type: &quot;datetime&quot; }
       ]
   }]
});

// create a new time series stream aggregator for the &#x27;Heat&#x27; store, that takes the values from the &#x27;Celsius&#x27; field
// and the timestamp from the &#x27;Time&#x27; field. The size of the window is 1 day.
var timeser &#x3D; {
   name: &#x27;TimeSeriesAggr&#x27;,
   type: &#x27;timeSeriesWinBuf&#x27;,
   store: &#x27;Heat&#x27;,
   timestamp: &#x27;Time&#x27;,
   value: &#x27;Celsius&#x27;,
   winsize: 86400000 // one day in miliseconds
};
var timeSeries &#x3D; base.store(&quot;Heat&quot;).addStreamAggr(timeser);

// add a max aggregator, that is connected with the &#x27;TimeSeriesAggr&#x27; aggregator
var max &#x3D; {
   name: &#x27;MaxAggr&#x27;,
   type: &#x27;winBufMax&#x27;,
   store: &#x27;Heat&#x27;,
   inAggr: &#x27;TimeSeriesAggr&#x27;
};
var maximal &#x3D; base.store(&quot;Heat&quot;).addStreamAggr(max);
base.close();</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The given name of the stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type for the stream aggregator. <b>Important:</b> It must be equal to <code>'winBufMax'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>store</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store from which it takes the data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>inAggr</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the stream aggregator to which it connects and gets data.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~StreamAggrMerger"><span class="symbol-name">StreamAggrMerger</span><small class="property-type">
            &nbsp;<a href="module-qm.StreamAggr.html">module:qm.StreamAggr</a></small></h3>            <p>This stream aggregator represents the merger aggregator. It merges records from two or more stores into a new store
depending on the timestamp. No methods are implemented for this aggregator.
<image src="pictures/merger.gif" alt="Merger Animation"></p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import the qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a base with a simple store
var base &#x3D; new qm.Base({
   mode: &quot;createClean&quot;,
   schema: [
   {
       name: &quot;Cars&quot;,
       fields: [
           { name: &quot;NumberOfCars&quot;, type: &quot;float&quot; },
           { name: &quot;Time&quot;, type: &quot;datetime&quot; }
       ]
   },
   {
       name: &quot;Temperature&quot;,
       fields: [
           { name: &quot;Celsius&quot;, type: &quot;float&quot; },
           { name: &quot;Time&quot;, type: &quot;datetime&quot; }
       ]
   },
   {
       name: &quot;Merged&quot;,
       fields: [
           { name: &quot;NumberOfCars&quot;, type: &quot;float&quot; },
           { name: &quot;Celsius&quot;, type: &quot;float&quot; },
           { name: &quot;Time&quot;, type: &quot;datetime&quot; }
       ]
   }]
});
// create a new merger stream aggregator that mergers the records of the &#x27;Cars&#x27; and &#x27;Temperature&#x27; stores.
// The records are interpolated linearly and stored in the &#x27;Merged&#x27; store.
var mer &#x3D; {
   name: &#x27;MergerAggr&#x27;,
   type: &#x27;merger&#x27;,
   outStore: &#x27;Merged&#x27;,
   createStore: false,
   timestamp: &#x27;Time&#x27;,
   fields: [
       { source: &#x27;Cars&#x27;, inField: &#x27;NumberOfCars&#x27;, outField: &#x27;NumberOfCars&#x27;, interpolation: &#x27;linear&#x27;, timestamp: &#x27;Time&#x27; },
       { source: &#x27;Temperature&#x27;, inField: &#x27;Celsius&#x27;, outField: &#x27;Celsius&#x27;, interpolation: &#x27;linear&#x27;, timestamp: &#x27;Time&#x27; }
   ]
};
var merger &#x3D; new qm.StreamAggr(base, mer);
base.close();</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The given name for the stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the stream aggregator. <b>Important:</b> It must be equal to <code>'merger'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>outStore</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store where it saves the merged records.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>createStore</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>If the outStore must be created.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>timestamp</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The store field of outStore, where the timestamp is saved.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>fields</p>
        </td>
        <td>
                <p>Array of Object</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>An array of <code>field</code> objects. The <code>field</code> object contain the properties:
<br><code>field.source</code> - The name of the store, from which it takes the values. Type <code>string</code>.
<br><code>field.inField</code> - The field name of source, from which it takes the values. Type <code>string</code>.
<br><code>field.outField</code> - The field name of outStore, into which it saves the values. Type <code>string</code>.
<br><code>field.interpolation</code> - The type of the interpolation. The options are: <code>'previous'</code>, <code>'next'</code> and <code>'linear'</code>. Type <code>string</code>.
<br><code>field.timestamp</code> - The field name of source, where the timestamp is saved. Type <code>string</code>.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~StreamAggrMin"><span class="symbol-name">StreamAggrMin</span><small class="property-type">
            &nbsp;<a href="module-qm.StreamAggr.html">module:qm.StreamAggr</a></small></h3>            <p>This stream aggregator represents the minimum moving window buffer. It monitors the minimal value in the connected stream aggregator.
It implements the following methods:
<br>1. <a href="module-qm.StreamAggr.html#getFloat">module:qm.StreamAggr#getFloat</a> returns the minimal value of the records in its buffer window.
<br>2. <a href="module-qm.StreamAggr.html#getTimestamp">module:qm.StreamAggr#getTimestamp</a> returns the timestamp of the newest record in its buffer window.</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import the qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a base with a simple store
var base &#x3D; new qm.Base({
   mode: &quot;createClean&quot;,
   schema: [
   {
       name: &quot;Heat&quot;,
       fields: [
           { name: &quot;Celsius&quot;, type: &quot;float&quot; },
           { name: &quot;Time&quot;, type: &quot;datetime&quot; }
       ]
   }]
});

// create a new time series stream aggregator for the &#x27;Heat&#x27; store, that takes the values from the &#x27;Celsius&#x27; field
// and the timestamp from the &#x27;Time&#x27; field. The size of the window is 1 day.
var timeser &#x3D; {
   name: &#x27;TimeSeriesAggr&#x27;,
   type: &#x27;timeSeriesWinBuf&#x27;,
   store: &#x27;Heat&#x27;,
   timestamp: &#x27;Time&#x27;,
   value: &#x27;Celsius&#x27;,
   winsize: 86400000 // 1 day in miliseconds
};
var timeSeries &#x3D; base.store(&quot;Heat&quot;).addStreamAggr(timeser);

// add a min aggregator, that is connected with the &#x27;TimeSeriesAggr&#x27; aggregator
var min &#x3D; {
   name: &#x27;MinAggr&#x27;,
   type: &#x27;winBufMin&#x27;,
   store: &#x27;Heat&#x27;,
   inAggr: &#x27;TimeSeriesAggr&#x27;
};
var minimal &#x3D; base.store(&quot;Heat&quot;).addStreamAggr(min);
base.close();</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The given name of the stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the stream aggregator. <b>Important:</b> It must be equal to <code>'winBufMin'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>store</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store from which it takes the data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>inAggr</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the stream aggregator to which it connects and gets data.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~StreamAggrMovingAverage"><span class="symbol-name">StreamAggrMovingAverage</span><small class="property-type">
            &nbsp;module:qmStreamAggr</small></h3>            <p>This stream aggregator represents the moving average window buffer. It calculates the moving average value of the connected stream aggregator values.
It implements the following methods:
<br>1. <a href="module-qm.StreamAggr.html#getFloat">module:qm.StreamAggr#getFloat</a> returns the average of the values in its buffer window.
<br>2. <a href="module-qm.StreamAggr.html#getTimestamp">module:qm.StreamAggr#getTimestamp</a> returns the timestamp of the newest record in its buffer window.</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import the qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a base with a simple store
var base &#x3D; new qm.Base({
   mode: &quot;createClean&quot;,
   schema: [
   {
       name: &quot;Heat&quot;,
       fields: [
           { name: &quot;Celsius&quot;, type: &quot;float&quot; },
           { name: &quot;Time&quot;, type: &quot;datetime&quot; }
       ]
   }]
});

// create a new time series stream aggregator for the &#x27;Heat&#x27; store, that takes the values from the &#x27;Celsius&#x27; field
// and the timestamp from the &#x27;Time&#x27; field. The size of the window should be 1 day.
var timeser &#x3D; {
   name: &#x27;TimeSeriesAggr&#x27;,
   type: &#x27;timeSeriesWinBuf&#x27;,
   store: &#x27;Heat&#x27;,
   timestamp: &#x27;Time&#x27;,
   value: &#x27;Celsius&#x27;,
   winsize: 86400000
};
var timeSeries &#x3D; base.store(&quot;Heat&quot;).addStreamAggr(timeser);

// add a moving average aggregator, that is connected with the &#x27;TimeSeriesAggr&#x27; aggregator
var ma &#x3D; {
   name: &#x27;movingAverageAggr&#x27;,
   type: &#x27;ma&#x27;,
   store: &#x27;Heat&#x27;,
   inAggr: &#x27;TimeSeriesAggr&#x27;
};
var movingAverage &#x3D; base.store(&quot;Heat&quot;).addStreamAggr(ma);
base.close();</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The given name of the stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the stream aggregator. <b>Important:</b> It must be equal to <code>'ma'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>store</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store from which it takes the data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>inAggr</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the stream aggregator to which it connects and gets data.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~StreamAggrMovingCorrelation"><span class="symbol-name">StreamAggrMovingCorrelation</span><small class="property-type">
            &nbsp;<a href="module-qm.StreamAggr.html">module:qm.StreamAggr</a></small></h3>            <p>This stream aggregator represents the moving covariance window buffer. It calculates the moving correlation of the three stream aggregators,
that it's connected to. It implements the following methods:
<br>1. <a href="module-qm.StreamAggr.html#getFloat">module:qm.StreamAggr#getFloat</a> returns the correlation of the values in it's buffer window.
<br>2. <a href="module-qm.StreamAggr.html#getTimestamp">module:qm.StreamAggr#getTimestamp</a> returns the timestamp of the newest record in it's buffer window.</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import the qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a base with a simple store
var base &#x3D; new qm.Base({
   mode: &quot;createClean&quot;,
   schema: [
   {
       name: &quot;Heat&quot;,
       fields: [
           { name: &quot;Celsius&quot;, type: &quot;float&quot; },
           { name: &quot;WaterConsumption&quot;, type: &quot;float&quot; },
           { name: &quot;Time&quot;, type: &quot;datetime&quot; }
       ]
   }]
});

// create a new time series stream aggregator for the &#x27;Heat&#x27; store, that takes the values from the &#x27;Celsius&#x27; field
// and the timestamp from the &#x27;Time&#x27; field. The size of the window is 1 day
var Celsius &#x3D; {
   name: &#x27;CelsiusAggr&#x27;,
   type: &#x27;timeSeriesWinBuf&#x27;,
   store: &#x27;Heat&#x27;,
   timestamp: &#x27;Time&#x27;,
   value: &#x27;Celsius&#x27;,
   winsize: 86400000
}; base.store(&quot;Heat&quot;).addStreamAggr(Celsius);

// create a new time series stream aggregator for the &#x27;Heat&#x27; store, that takes the values from the &#x27;WaterConsumption&#x27; field
// and the timestamp from the &#x27;Time&#x27; field. The size of the window is 1 day
var water &#x3D; {
   name: &#x27;WaterAggr&#x27;,
   type: &#x27;timeSeriesWinBuf&#x27;,
   store: &#x27;Heat&#x27;,
   timestamp: &#x27;Time&#x27;,
   value: &#x27;WaterConsumption&#x27;,
   winsize: 86400000
}; base.store(&quot;Heat&quot;).addStreamAggr(water);

// add a covariance aggregator, that is connected with the &#x27;CelsiusAggr&#x27; and &#x27;WaterAggr&#x27; aggregators
var covariance &#x3D; {
   name: &#x27;covarianceAggr&#x27;,
   type: &#x27;covariance&#x27;,
   store: &#x27;Heat&#x27;,
   inAggrX: &#x27;CelsiusAggr&#x27;,
   inAggrY: &#x27;WaterAggr&#x27;
}; base.store(&quot;Heat&quot;).addStreamAggr(covariance);

// add the two variance aggregators, that take from the &#x27;Celsius&#x27; and &#x27;WaterConsumption&#x27; fields, respectively
var celVar &#x3D; {
   name: &#x27;CelsiusVarAggr&#x27;,
   type: &#x27;variance&#x27;,
   store: &#x27;Heat&#x27;,
   inAggr: &#x27;CelsiusAggr&#x27;
}; base.store(&quot;Heat&quot;).addStreamAggr(celVar);

var waterVar &#x3D; {
   name: &#x27;waterVarAggr&#x27;,
   type: &#x27;variance&#x27;,
   store: &#x27;Heat&#x27;,
   inAggr: &#x27;WaterAggr&#x27;
}; base.store(&quot;Heat&quot;).addStreamAggr(waterVar);

// add a correlation aggregator, that is connected to &#x27;CovarianceAggr&#x27;, &#x27;CelsiusVarAggr&#x27; and &#x27;WaterValAggr&#x27; aggregators
var corr &#x3D; {
   name: &#x27;corrAggr&#x27;,
   type: &#x27;correlation&#x27;,
   store: &#x27;Heat&#x27;,
   inAggrCov: &#x27;covarianceAggr&#x27;,
   inAggrVarX: &#x27;CelsiusVarAggr&#x27;,
   inAggrVarY: &#x27;waterVarAggr&#x27;
};
var correlation &#x3D; base.store(&quot;Heat&quot;).addStreamAggr(corr);
base.close();</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The given name for the stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the stream aggregator. <b>Important:</b> It must be equal to <code>'correlation'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>store</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store from which it takes the data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>inAggrCov</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the covariance stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>inAggrVarX</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the first variance stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>inAggrVarY</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the second variance stream aggregator.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~StreamAggrMovingCovariance"><span class="symbol-name">StreamAggrMovingCovariance</span><small class="property-type">
            &nbsp;<a href="module-qm.StreamAggr.html">module:qm.StreamAggr</a></small></h3>            <p>This stream aggregator represents the moving covariance window buffer. It calculates the moving covariance of the two stream aggregators, that it's connected to.
It implements the following methods:
<br>1. <a href="module-qm.StreamAggr.html#getFloat">module:qm.StreamAggr#getFloat</a> returns the covariance of the values in its buffer window.
<br>2. <a href="module-qm.StreamAggr.html#getTimestamp">module:qm.StreamAggr#getTimestamp</a> returns the timestamp of the newest record in its buffer window.</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import the qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a base with a simple store
var base &#x3D; new qm.Base({
   mode: &quot;createClean&quot;,
   schema: [
   {
       name: &quot;Heat&quot;,
       fields: [
           { name: &quot;Celsius&quot;, type: &quot;float&quot; },
           { name: &quot;WaterConsumption&quot;, type: &quot;float&quot; },
           { name: &quot;Time&quot;, type: &quot;datetime&quot; }
       ]
   }]
});

// create a new time series stream aggregator for the &#x27;Heat&#x27; store, that takes the values from the &#x27;Celsius&#x27; field
// and the timestamp from the &#x27;Time&#x27; field. The size of the window is 1 day.
var Celsius &#x3D; {
   name: &#x27;CelsiusAggr&#x27;,
   type: &#x27;timeSeriesWinBuf&#x27;,
   store: &#x27;Heat&#x27;,
   timestamp: &#x27;Time&#x27;,
   value: &#x27;Celsius&#x27;,
   winsize: 86400000
}; base.store(&quot;Heat&quot;).addStreamAggr(Celsius);

// create a new time series stream aggregator for the &#x27;Heat&#x27; store, that takes the values from the &#x27;WaterConsumption&#x27; field
// and the timestamp from the &#x27;Time&#x27; field. The size of the window is 1 day.
var water &#x3D; {
   name: &#x27;WaterAggr&#x27;,
   type: &#x27;timeSeriesWinBuf&#x27;,
   store: &#x27;Heat&#x27;,
   timestamp: &#x27;Time&#x27;,
   value: &#x27;WaterConsumption&#x27;,
   winsize: 86400000
}; base.store(&quot;Heat&quot;).addStreamAggr(water);

// add a covariance aggregator, that is connected with the &#x27;CelsiusAggr&#x27; and &#x27;WaterAggr&#x27; stream aggregators
var covariance &#x3D; {
   name: &#x27;covAggr&#x27;,
   type: &#x27;covariance&#x27;,
   store: &#x27;Heat&#x27;,
   inAggrX: &#x27;CelsiusAggr&#x27;,
   inAggrY: &#x27;WaterAggr&#x27;
};
var covarianceAggr &#x3D; base.store(&quot;Heat&quot;).addStreamAggr(covariance);
base.close();</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The given name for the stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the stream aggregator. <b>Important:</b> It must be equal to <code>'covariance'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>store</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store from which it takes the data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>inAggrX</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the first stream aggregator to which it connects and gets data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>inAggrY</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the recond stream aggregator to which it connects and gets data.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~StreamAggrMovingVariance"><span class="symbol-name">StreamAggrMovingVariance</span><small class="property-type">
            &nbsp;<a href="module-qm.StreamAggr.html">module:qm.StreamAggr</a></small></h3>            <p>This stream aggregator represents the moving variance window buffer. It calculates the moving variance of the stream aggregator, that it's connected to.
It implements the following methods:
<br>1. <a href="module-qm.StreamAggr.html#getFloat">module:qm.StreamAggr#getFloat</a> returns the variance of the values in its buffer window.
<br>2. <a href="module-qm.StreamAggr.html#getTimestamp">module:qm.StreamAggr#getTimestamp</a> returns the timestamp of the newest record in its buffer window.</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import the qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a base with a simple store
var base &#x3D; new qm.Base({
   mode: &quot;createClean&quot;,
   schema: [
   {
       name: &quot;Heat&quot;,
       fields: [
           { name: &quot;Celsius&quot;, type: &quot;float&quot; },
           { name: &quot;Time&quot;, type: &quot;datetime&quot; }
       ]
   }]
});

// create a new time series stream aggregator for the &#x27;Heat&#x27; store, that takes the values from the &#x27;Celsius&#x27; field
// and the timestamp from the &#x27;Time&#x27; field. The size of the window is 1 day
var timeser &#x3D; {
   name: &#x27;TimeSeriesAggr&#x27;,
   type: &#x27;timeSeriesWinBuf&#x27;,
   store: &#x27;Heat&#x27;,
   timestamp: &#x27;Time&#x27;,
   value: &#x27;Celsius&#x27;,
   winsize: 86400000
};
var timeSeries &#x3D; base.store(&quot;Heat&quot;).addStreamAggr(timeser);

// add a variance aggregator, that is connected with the &#x27;TimeSeriesAggr&#x27; aggregator
var variance &#x3D; {
   name: &#x27;varAggr&#x27;,
   type: &#x27;variance&#x27;,
   store: &#x27;Heat&#x27;,
   inAggr: &#x27;TimeSeriesAggr&#x27;
};
var varianceAggr &#x3D; base.store(&quot;Heat&quot;).addStreamAggr(variance);
base.close();</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The given name for the stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the stream aggregator. <b>Important:</b> It must be equal to <code>'variance'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>store</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store from which it takes the data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>inAggr</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the stream aggregator to which it connects and gets data.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~StreamAggrPageHinkley"><span class="symbol-name">StreamAggrPageHinkley</span><small class="property-type">
            &nbsp;<a href="module-qm.StreamAggr.html">module:qm.StreamAggr</a></small></h3>            <p>This stream aggregate enables detecting concept drift based on Page-Hinkley test
on a stream of numeric data. It is based on the book
Gamma, Knowledge Discovery from Data Streams, 2013, pp. 76
<br>1. <a href="module-qm.StreamAggr.html#getInteger">module:qm.StreamAggr#getInteger</a> takes a string input (either <code>'drift'</code> or <code>'driftOffset'</code>)
and returns returns the value of the property or <code>null</code> if it's unknown. <code>'drift'</code> is set to 1 if the drift
has been detected in this step, otherise to 0. <code>'drift</code>' is always set to 0 in the next step. <code>'driftOffset'</code>
monitors the offset (number of onStep calls) since last concept drift was detected.
<br>2. <a href="module-qm.StreamAggr.html#getParams">module:qm.StreamAggr#getParams</a> returns a parameter object.
<br>3. <a href="module-qm.StreamAggr.html#setParams">module:qm.StreamAggr#setParams</a> used for changing Page-Hinkley test parameters</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// main library
let qm &#x3D; require(&#x27;qminer&#x27;);

// create a base with a simple store
// the store records results of clustering
base &#x3D; new qm.Base({
    mode: &quot;createClean&quot;,
    schema: [{
        name: &quot;Store&quot;,
        fields: [
            { name: &quot;Value&quot;, type: &quot;float&quot; },
            { name: &quot;Time&quot;, type: &quot;datetime&quot; }
        ]
    }]
});

// create a new time series stream aggregator for the &#x27;Store&#x27; store that takes the recorded cluster id
// and the timestamp from the &#x27;Time&#x27; field. The size of the window is 2 hours.
let timeser &#x3D; {
    name: &#x27;seriesTick1&#x27;,
    type: &#x27;timeSeriesTick&#x27;,
    store: &#x27;Store&#x27;,
    timestamp: &#x27;Time&#x27;,
    value: &#x27;Value&#x27;
};
let timeSeries1 &#x3D; base.store(&quot;Store&quot;).addStreamAggr(timeser);
// add a histogram aggregator, that is connected with the &#x27;TimeSeries1&#x27; aggregator
let aggrPHT &#x3D; {
    name: &#x27;PageHinkley&#x27;,
    type: &#x27;pagehinkley&#x27;,
    store: &#x27;Store&#x27;,
    inAggr: &#x27;seriesTick1&#x27;,
    minInstances: 1,
    delta: 0.005,
    lambda: 50,
    alpha: 0.9999
};
store &#x3D; base.store(&quot;Store&quot;);
pht &#x3D; store.addStreamAggr(aggrPHT);

// creating start time
let time &#x3D; new Date();
let changes &#x3D; 0;

// simulating concept drift at element 1000 in a time series
for (let i &#x3D; 0; i &lt; 2000; i++) {
    // add one second to the timestamp and create an ISO string
    time.setSeconds(time.getSeconds() + 1);
    let timeStr &#x3D; time.toISOString();
    // create value
    let value &#x3D; Math.random() * 1;
    if (i &gt; 1000) {
        value &#x3D; Math.random() * 2 + 1;
    }
    // adding values to the signal store
    store.push({ Time: timeStr, Value: value });
    // counting changes
    if (pht.saveJson().drift &#x3D;&#x3D; 1) {
        changes++;
    }
}

// checking if drift has been correctly detected
if (changes &gt;&#x3D; 1) { console.log(&quot;Last concept drift was detected &quot; + pht.val.driftOffset + &quot; samples ago.&quot;); }
else { console.log(&quot;No concept drift was detected!&quot;); }

// clean up
base.close();</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>The given name of the stream aggregator (autogenerated by default).</p>
        </td>
</tr>

                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type for the stream aggregator. <b>Important:</b> It must be equal to <code>'pagehinkley'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>store</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store consistent with the records that it processes.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>inAggr</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the stream aggregate used for input (i.e. module:qm.StreamAggrTimeSeriesTick).</p>
        </td>
</tr>

                <tr>
        <td>
            <p>minInstances</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>Minimal number of instances needed for initialization of the aggregator (when can first concept drift be initialized?).</p>
        </td>
</tr>

                <tr>
        <td>
            <p>delta</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The delta factor for the Page Hinkley test.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>lambda</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The change detection threshold.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>alpha</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The forgetting factor, used to weight the observed value and the mean.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~StreamAggrRecordBuffer"><span class="symbol-name">StreamAggrRecordBuffer</span><small class="property-type">
            &nbsp;<a href="module-qm.StreamAggr.html">module:qm.StreamAggr</a></small></h3>            <p>This stream aggregator represents record buffer. It stores the values inside a moving window.
It implements all the stream aggregate methods <b>except</b> <a href="module-qm.StreamAggr.html#getFloat">module:qm.StreamAggr#getFloat</a> and <a href="module-qm.StreamAggr.html#getTimestamp">module:qm.StreamAggr#getTimestamp</a>.</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import the qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a base with a simple store
var base &#x3D; new qm.Base({
   mode: &quot;createClean&quot;,
   schema: [
   {
       name: &quot;Heat&quot;,
       fields: [
           { name: &quot;Celsius&quot;, type: &quot;float&quot; },
           { name: &quot;Time&quot;, type: &quot;datetime&quot; }
       ]
   }]
});

// create a new time series stream aggregator for the &#x27;Heat&#x27; store. The size of the window is 3 records.
var aggr &#x3D; {
   name: &#x27;Delay&#x27;,
   type: &#x27;recordBuffer&#x27;,
   size: 3
};
base.store(&quot;Heat&quot;).addStreamAggr(aggr);
base.close();</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The given name of the stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the stream aggregator. <b>Important:</b> It must be equal to <code>'recordBuffer'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>size</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The size of the window.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~StreamAggrRecordSwitch"><span class="symbol-name">StreamAggrRecordSwitch</span><small class="property-type">
            &nbsp;<a href="module-qm.StreamAggr.html">module:qm.StreamAggr</a></small></h3>            <p>This stream aggregate enables switching control flow between stream aggregates based
on string keys. It is based on a hash table from keys (strings read from records) to
stream aggregates. When OnAdd of a record switch is called, the aggregate looks for
an appropriate target aggregate and triggers its onAdd. The aggregate
exposes the following methods.
<br>1. <a href="module-qm.StreamAggr.html#getInteger">module:qm.StreamAggr#getInteger</a> takes a string input and returns returns 1 if the string is a known key and <code>null</code> if it's unknown.
<br>2. <a href="module-qm.StreamAggr.html#onAdd">module:qm.StreamAggr#onAdd</a> reads the appropriate field as a key and triggers the onAdd of a target aggregate if the key is known.
<br>3. <a href="module-qm.StreamAggr.html#getParams">module:qm.StreamAggr#getParams</a> returns a parameter object.
<br>4. <a href="module-qm.StreamAggr.html#setParams">module:qm.StreamAggr#setParams</a> used primarily for adding (using $add) new targets or seting  (using $set) the internal hashmap with new targets.</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// main library
var qm &#x3D; require(&#x27;qminer&#x27;);

// create a store
var base &#x3D; new qm.Base({
    mode: &#x27;createClean&#x27;,
    schema: [{
        name: &#x27;testStore&#x27;,
        fields: [
            { name: &#x27;switchField&#x27;, type: &#x27;string&#x27; }
        ]
    }]
});
// select store
var store &#x3D; base.store(&#x27;testStore&#x27;);

// first JS aggregate
var outAggr1 &#x3D; new qm.StreamAggr(base, new function () {
    this.onAdd &#x3D; function (rec) {
        console.log(&#x27;first&#x27;);
    }
});

// second JS aggregate
var outAggr2 &#x3D; new qm.StreamAggr(base, new function () {
    this.onAdd &#x3D; function (rec) {
        console.log(&#x27;second&#x27;);
    }
});

// switcher aggregate: calls outAggr1 when rec.switchField &#x3D;&#x3D; &#x27;a&#x27; and outAggr2 when rec.switchField &#x3D;&#x3D; &#x27;b&#x27;
var switcher &#x3D; store.addStreamAggr({
    type: &#x27;recordSwitchAggr&#x27;,
    store: &#x27;testStore&#x27;,
    fieldName: &#x27;switchField&#x27;,
    $set: [{ key: &#x27;a&#x27;, aggrName: outAggr1.name },
           { key: &#x27;b&#x27;, aggrName: outAggr2.name }],
    throwMissing: false
});

store.push({ switchField: &#x27;a&#x27; });
// outAggr1 prints &#x60;first&#x60;
store.push({ switchField: &#x27;b&#x27; });
// outAggr2 prints &#x60;second&#x60;
store.push({ switchField: &#x27;b&#x27; });
// outAggr2 prints &#x60;second&#x60;
store.push({ switchField: &#x27;c&#x27; });
// nothing happens
store.push({ switchField: &#x27;a&#x27; });
// outAggr1 prints &#x60;first&#x60;

// clean up
base.close();</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>The given name of the stream aggregator (autogenerated by default).</p>
        </td>
</tr>

                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type for the stream aggregator. <b>Important:</b> It must be equal to <code>'recordSwitchAggr'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>store</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store consistent with the records that it processes.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>fieldName</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the field whose values are used for switching</p>
        </td>
</tr>

                <tr>
        <td>
            <p>throwMissing</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>If true, the aggregate will throw an exception when the record's key is not recognized (no appropirate target aggregate exists).</p>
                <p>Defaults to <code>false</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>$set</p>
        </td>
        <td>
                <p>Array of Object</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>An array with objects like <code>{'key': string, 'aggrName': string}</code>. Each object is a switch key and the name of the target aggregate.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~StreamAggrResampler"><span class="symbol-name">StreamAggrResampler</span><small class="property-type">
            &nbsp;<a href="module-qm.StreamAggr.html">module:qm.StreamAggr</a></small></h3>            <p>This stream aggregator represents the resampler window buffer. It creates new values that are interpolated by using the values from an existing store.
No methods are implemented for this aggregator.</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import the qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a base with a simple store
var base &#x3D; new qm.Base({
   mode: &quot;createClean&quot;,
   schema: [
   {
       name: &quot;Heat&quot;,
       fields: [
           { name: &quot;Celsius&quot;, type: &quot;float&quot; },
           { name: &quot;Time&quot;, type: &quot;datetime&quot; }
       ]
   },
   {
       name: &quot;interpolatedValues&quot;,
       fields: [
           { name: &quot;Value&quot;, type: &quot;float&quot; },
           { name: &quot;Time&quot;, type: &quot;datetime&quot; }
       ]
   }]
});
// create a new resampler stream aggregator for the &#x27;Heat&#x27; store, that takes the values from the &#x27;Celsius&#x27; field
// and the timestamp from the &#x27;Time&#x27; field. The interpolated values are stored in the &#x27;interpolatedValues&#x27; store.
// The interpolation should be linear and the interval should be 2 seconds
var res &#x3D; {
   name: &#x27;resamplerAggr&#x27;,
   type: &#x27;resampler&#x27;,
   store: &#x27;Heat&#x27;,
   outStore: &#x27;interpolatedValues&#x27;,
   timestamp: &#x27;Time&#x27;,
   fields: [{
       name: &#x27;Celsius&#x27;,
       interpolator: &#x27;linear&#x27;
   }],
   createStore: false,
   interval: 2000
};
var resampler &#x3D; base.store(&quot;Heat&quot;).addStreamAggr(res);
base.close();</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The given name for the stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the stream aggregator. <b>Important:</b> It must be equal to <code>'resampler'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>store</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store from which it takes the data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>outStore</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The store in which the samples are stored.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>timestamp</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The store field from which it takes the timestamps.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>fields</p>
        </td>
        <td>
                <p>Array of Object</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The array off <code>field</code> objects from which it takes the values. The <code>field</code> object contain the properties:
<br><code>field.name</code> - The store field from which it takes the values. Type <code>string</code>.
<br><code>field.interpolator</code> - The type of the interpolation. The options are <code>'previous'</code>, <code>'next'</code> and <code>'linear'</code>. Type <code>string</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>createStore</p>
        </td>
        <td>
                <p>boolean</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>If true, <code>outStore</code> must be created.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>interval</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The interval size. The frequency on which it makes the interpolated values.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~StreamAggrSimpleLinearRegression"><span class="symbol-name">StreamAggrSimpleLinearRegression</span><small class="property-type">
            &nbsp;<a href="module-qm.StreamAggr.html">module:qm.StreamAggr</a></small></h3>            <p>This stream aggregator computes a simple linear regression given two stream aggregates
that support the <a href="module-qm.StreamAggr.html#getFloatVector">module:qm.StreamAggr#getFloatVector</a> method and represent variates (input) and covariates (output).
Optionally the aggregate computes quantile bands: for each quantile <code>q</code> a parallel line to the fitted
line is found, so that <code>q</code> fraction of <code>(x,y)</code> datapoints fall below the line. For example, under Gaussian noise,
if <code>Y = a + k X + N(0,sig)</code> then the 0.95 quantile band will equal <code>a + 2 sig</code>. This means that 95% of <code>(x,y)</code> pairs
lie below the line <code>Y = a + 2 sig + k X</code>.
The results are returned as a JSON by calling <a href="module-qm.StreamAggr.html#saveJson">module:qm.StreamAggr#saveJson</a> and are of type <a href="module-qm.html#~StreamAggrSimpleLinearRegressionResult">module:qm~StreamAggrSimpleLinearRegressionResult</a>.</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import the qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a base with X,Y measurements
var base &#x3D; new qm.Base({
    mode: &#x27;createClean&#x27;,
    schema: [{
        name: &#x27;Function&#x27;,
        fields: [
            { name: &#x27;Time&#x27;, type: &#x27;datetime&#x27; },
            { name: &#x27;X&#x27;, type: &#x27;float&#x27; },
            { name: &#x27;Y&#x27;, type: &#x27;float&#x27; }
        ]
    }]
});

var store &#x3D; base.store(&#x27;Function&#x27;);

// 1 second buffer for X values
var winX &#x3D; store.addStreamAggr({
    type: &#x27;timeSeriesWinBuf&#x27;,
    timestamp: &#x27;Time&#x27;,
    value: &#x27;X&#x27;,
    winsize: 1000
});
// 1 second buffer for Y values
var winY &#x3D; store.addStreamAggr({
    type: &#x27;timeSeriesWinBuf&#x27;,
    timestamp: &#x27;Time&#x27;,
    value: &#x27;Y&#x27;,
    winsize: 1000
});

// the will find regression line, as well as two parallel quartile lines
var linReg &#x3D; store.addStreamAggr({
    type: &#x27;simpleLinearRegression&#x27;,
    inAggrX: winX.name,
    inAggrY: winY.name,
    storeX: &quot;Function&quot;,
    storeY: &quot;Function&quot;,
    quantiles: [0.25, 0.75]
});

store.push({ Time: &#x27;2015-06-10T14:13:32.001&#x27;, X: 0, Y: -2 });
store.push({ Time: &#x27;2015-06-10T14:13:32.002&#x27;, X: 0, Y: -1 });
store.push({ Time: &#x27;2015-06-10T14:13:32.003&#x27;, X: 0, Y: 1 });
store.push({ Time: &#x27;2015-06-10T14:13:32.004&#x27;, X: 0, Y: 2 });
store.push({ Time: &#x27;2015-06-10T14:13:32.005&#x27;, X: 1, Y: -1 });
store.push({ Time: &#x27;2015-06-10T14:13:32.006&#x27;, X: 1, Y: -0 });
store.push({ Time: &#x27;2015-06-10T14:13:32.007&#x27;, X: 1, Y: 2 });
store.push({ Time: &#x27;2015-06-10T14:13:32.008&#x27;, X: 1, Y: 3 });

var res &#x3D; linReg.saveJson();
res.bands[0]; // -1.5
res.bands[1]; // 1.5

base.close();</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The given name of the stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type for the stream aggregator. <b>Important:</b> It must be equal to <code>'onlineVecDiff'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>storeX</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store from which it takes the data for the first vector.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>storeY</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store from which it takes the data for the second vector.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>inAggrX</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the first stream aggregator to which it connects and gets data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>inAggrY</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the second stream aggregator to which it connects and gets data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>quantiles</p>
        </td>
        <td>
                <p>Array of number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>An array of numbers between 0 and 1 for which the quantile bands will be computed.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~StreamAggrSimpleLinearRegressionResult"><span class="symbol-name">StreamAggrSimpleLinearRegressionResult</span><small class="property-type">
            &nbsp;Object</small></h3>            <p>Simple linear regression result JSON returned by <a href="module-qm.html#~StreamAggrSimpleLinearRegression">module:qm~StreamAggrSimpleLinearRegression</a>.</p>

        
        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>intercept</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>Regressor intercept.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>slope</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>Regressor slope.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>quantiles</p>
        </td>
        <td>
                <p>Array of number</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Quantiles for which bands will be computed.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>bands</p>
        </td>
        <td>
                <p>Array of number</p>
        </td>
        <td>
                <p>Yes</p>
        </td>
        <td>
                <p>Computed band intercepts.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~StreamAggrSlottedHistogram"><span class="symbol-name">StreamAggrSlottedHistogram</span><small class="property-type">
            &nbsp;<a href="module-qm.StreamAggr.html">module:qm.StreamAggr</a></small></h3>            <p>This stream aggregator represents an online slotted histogram. It can connect to a buffered aggregate (such as <a href="module-qm.html#~StreamAggrTimeSeriesWindow">module:qm~StreamAggrTimeSeriesWindow</a>)
or a time series (such as module:qm~StreamAggregateEMA).
It maps historical values into single period (e.g. into hours of the week).
The aggregate defines an ordered set of points <code>p(0), ..., p(n)</code> that define n bins. Infinites at both ends are NOT allowed.
A new measurement is tested for inclusion in the left-closed right-opened intervals <code>[p(i), p(i+1))</code> and the corresponding
bin counter is increased for the appropriate bin (or decreased if the point is outgoing from the buffer).
It implements the following methods:
<br>1. <a href="module-qm.StreamAggr.html#getFloatLength">module:qm.StreamAggr#getFloatLength</a> returns the number of bins.
<br>2. <a href="module-qm.StreamAggr.html#getFloatAt">module:qm.StreamAggr#getFloatAt</a> returns the count for a bin index.
<br>3. <a href="module-qm.StreamAggr.html#getFloatVector">module:qm.StreamAggr#getFloatVector</a> returns the vector of counts, the length is equal to the number of bins.</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import the qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a base with a simple store
var base &#x3D; new qm.Base({
   mode: &quot;createClean&quot;,
   schema: [
   {
       name: &quot;Heat&quot;,
       fields: [
           { name: &quot;Celsius&quot;, type: &quot;float&quot; },
           { name: &quot;Time&quot;, type: &quot;datetime&quot; }
       ]
   }]
});

// create a new time series stream aggregator for the &#x27;Heat&#x27; store, that takes the values from the &#x27;Celsius&#x27; field
// and the timestamp from the &#x27;Time&#x27; field. The size of the window is 4 weeks
var timeser &#x3D; {
   name: &#x27;TimeSeriesBuffer&#x27;,
   type: &#x27;timeSeriesWinBuf&#x27;,
   store: &#x27;Heat&#x27;,
   timestamp: &#x27;Time&#x27;,
   value: &#x27;Celsius&#x27;,
   winsize: 2419200000 // 4 weeks
};
var timeSeries &#x3D; base.store(&quot;Heat&quot;).addStreamAggr(timeser);

// add a slotted-histogram aggregator, that is connected with the &#x27;TimeSeriesAggr&#x27; aggregator
// it will present accumulated histogram for the last 2 hours (window) of the week (period) for the last 4 weeks (see aggregate above)
var aggrJson &#x3D; {
   name: &#x27;Histogram&#x27;,
   type: &#x27;onlineSlottedHistogram&#x27;,
   store: &#x27;Heat&#x27;,
   inAggr: &#x27;TimeSeriesBuffer&#x27;,
   period: 604800000, // 1 week
   window: 7200000, // 2h
   bins: 5, // 5 possible clusters
   granularity: 300000  // 5 min
};
var hist &#x3D; base.store(&quot;Heat&quot;).addStreamAggr(aggrJson);
base.close();</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The given name of the stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type for the stream aggregator. <b>Important:</b> It must be equal to <code>'onlineHistogram'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>store</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store from which it takes the data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>inAggr</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the stream aggregator to which it connects and gets data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>period</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>Cycle length in miliseconds.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>window</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>Window length that is reported when aggregate is queried.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>bins</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The number of bins - input data is expected to be withing interval <code>[0, bins-1]</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>granularity</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>Storage granularity in miliseconds. History is stored in slots with this length. Number of slots is equal to period/granularity.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~StreamAggrSparseVecSum"><span class="symbol-name">StreamAggrSparseVecSum</span><small class="property-type">
            &nbsp;<a href="module-qm.StreamAggr.html">module:qm.StreamAggr</a></small></h3>            <p>This stream aggregator represents the sparse-vector-sum moving window buffer. It sums all the sparse-vector values, that are in the connected stream aggregator.
It implements the following methods:
<br>1. <a href="module-qm.StreamAggr.html#getValueVector">module:qm.StreamAggr#getValueVector</a> returns the sum of the values of the records in its buffer window.
<br>2. <a href="module-qm.StreamAggr.html#getTimestamp">module:qm.StreamAggr#getTimestamp</a> returns the timestamp of the newest record in its buffer window.</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>var qm &#x3D; require(&#x27;qminer&#x27;);
var base &#x3D; new qm.Base({
  mode: &#x27;createClean&#x27;,
  schema: [{
      name: &#x27;Docs&#x27;,
      fields: [
          { name: &#x27;Time&#x27;, type: &#x27;datetime&#x27; },
          { name: &#x27;Text&#x27;, type: &#x27;string&#x27; }
      ]
  }]
});
var store &#x3D; base.store(&#x27;Docs&#x27;);

var aggr &#x3D; {
  name: &#x27;featureSpaceWindow&#x27;,
  type: &#x27;timeSeriesWinBufFeatureSpace&#x27;,
  store: &#x27;Docs&#x27;,
  timestamp: &#x27;Time&#x27;,
  featureSpace: {
      type: &quot;categorical&quot;,
      source: &quot;Docs&quot;,
      field: &quot;Text&quot;
  },
  winsize: 1000
};
var sa &#x3D; store.addStreamAggr(aggr);

var aggr2 &#x3D; {
  name: &#x27;sparseVectorSum&#x27;,
  type: &#x27;winBufSpVecSum&#x27;,
  store: &#x27;Docs&#x27;,
  inAggr: &#x27;featureSpaceWindow&#x27;
};
var sa2 &#x3D; store.addStreamAggr(aggr2);

store.push({ Time: &#x27;2015-06-10T14:13:32.0&#x27;, Text: &#x27;a&#x27; }); // 0
store.push({ Time: &#x27;2015-06-10T14:13:33.0&#x27;, Text: &#x27;b&#x27; }); // 1
store.push({ Time: &#x27;2015-06-10T14:14:34.0&#x27;, Text: &#x27;c&#x27; }); // 2
store.push({ Time: &#x27;2015-06-10T14:15:35.0&#x27;, Text: &#x27;d&#x27; }); // 3
store.push({ Time: &#x27;2015-06-10T14:15:36.0&#x27;, Text: &#x27;e&#x27; }); // 4
store.push({ Time: &#x27;2015-06-10T14:15:37.0&#x27;, Text: &#x27;f&#x27; }); // 5

var valVec2 &#x3D; sa2.getValueVector(); // [0, 0, 0, 0, 1, 1] - only vectors 4 and 5 remain in window

base.close();</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The given name of the stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the stream aggregator. <b>Important:</b> It must be equal to <code>'winBufSpVecSum'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>store</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store from which it takes the data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>inAggr</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the stream aggregator to which it connects and gets data.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~StreamAggrSum"><span class="symbol-name">StreamAggrSum</span><small class="property-type">
            &nbsp;<a href="module-qm.StreamAggr.html">module:qm.StreamAggr</a></small></h3>            <p>This stream aggregator represents the sum moving window buffer. It sums all the values, that are in the connected stream aggregator.
It implements the following methods:
<br>1. <a href="module-qm.StreamAggr.html#getFloat">module:qm.StreamAggr#getFloat</a> returns the sum of the values of the records in its buffer window.
<br>2. <a href="module-qm.StreamAggr.html#getTimestamp">module:qm.StreamAggr#getTimestamp</a> returns the timestamp of the newest record in its buffer window.</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import the qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a base with a simple store
var base &#x3D; new qm.Base({
   mode: &quot;createClean&quot;,
   schema: [
   {
       name: &quot;Income&quot;,
       fields: [
           { name: &quot;Amount&quot;, type: &quot;float&quot; },
           { name: &quot;Time&quot;, type: &quot;datetime&quot; }
       ]
   }]
});

// create a new time series stream aggregator for the &#x27;Income&#x27; store, that takes the values from the &#x27;Amount&#x27; field
// and the timestamp from the &#x27;Time&#x27; field. The size of the window should 1 week.
var timeser &#x3D; {
   name: &#x27;TimeSeriesAggr&#x27;,
   type: &#x27;timeSeriesWinBuf&#x27;,
   store: &#x27;Income&#x27;,
   timestamp: &#x27;Time&#x27;,
   value: &#x27;Amount&#x27;,
   winsize: 604800000 // 7 days in miliseconds
};
var timeSeries &#x3D; base.store(&quot;Income&quot;).addStreamAggr(timeser);

// add a sum aggregator, that is connected with the &#x27;TimeSeriesAggr&#x27; aggregator
var sum &#x3D; {
   name: &#x27;SumAggr&#x27;,
   type: &#x27;winBufSum&#x27;,
   store: &#x27;Heat&#x27;,
   inAggr: &#x27;TimeSeriesAggr&#x27;
};
var sumAggr &#x3D; base.store(&quot;Income&quot;).addStreamAggr(sum);
base.close();</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The given name of the stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the stream aggregator. <b>Important:</b> It must be equal to <code>'winBufSum'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>store</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store from which it takes the data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>inAggr</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the stream aggregator to which it connects and gets data.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~StreamAggrTDigest"><span class="symbol-name">StreamAggrTDigest</span><small class="property-type">
            &nbsp;<a href="module-qm.StreamAggr.html">module:qm.StreamAggr</a></small></h3>            <p>This stream aggregator computes the quantile estimators using the <a href="module-analytics.TDigest.html">TDigest</a> algorithm.
The quantile values are returned using <a href="module-qm.StreamAggr.html#getFloatVector">module:qm.StreamAggr#getFloatVector</a>.</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import the qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a base with the Time and Value fields
var base &#x3D; new qm.Base({
   mode: &quot;createClean&quot;,
   schema: [
   {
       name: &quot;Processor&quot;,
       fields: [
           { name: &quot;Value&quot;, type: &quot;float&quot; },
           { name: &quot;Time&quot;, type: &quot;datetime&quot; }
       ]
   }]
});
var store &#x3D; base.store(&#x27;Processor&#x27;);

// create a new time series stream aggregator for the &#x27;Processor&#x27; store, that takes the value of the processor
// and the timestamp from the &#x27;Time&#x27; field. The size of the window is 1 second.
var tick &#x3D; {
    name: &#x27;TickAggr&#x27;,
    type: &#x27;timeSeriesTick&#x27;,
    store: &#x27;Processor&#x27;,
    timestamp: &#x27;Time&#x27;,
    value: &#x27;Value&#x27;,
    winsize: 1000 // one day in miliseconds
};
var timeSeries &#x3D; store.addStreamAggr(tick);

// create the TDigest stream aggregator
var aggr &#x3D; {
    name: &#x27;TDigest&#x27;,
    type: &#x27;tdigest&#x27;,
    store: &#x27;Processor&#x27;,
    inAggr: &#x27;TickAggr&#x27;,
    quantiles: [0.90, 0.95, 0.99, 0.999],
    minCount: 5
};
// add the stream aggregator to the &#x27;Processor&#x27; store
var td &#x3D; store.addStreamAggr(aggr);
store.push({ Time: &#x27;2015-12-01T14:20:32.0&#x27;, Value: 0.9948628368 });
store.push({ Time: &#x27;2015-12-01T14:20:33.0&#x27;, Value: 0.1077458826 });
store.push({ Time: &#x27;2015-12-01T14:20:34.0&#x27;, Value: 0.9855685823 });
store.push({ Time: &#x27;2015-12-01T14:20:35.0&#x27;, Value: 0.7796449082 });
// with this record the aggregator will initialize becuase it is the 5th record
store.push({ Time: &#x27;2015-12-01T14:20:36.0&#x27;, Value: 0.0844943286 });

store.push({ Time: &#x27;2015-12-01T14:20:37.0&#x27;, Value: 0.187490856 });
store.push({ Time: &#x27;2015-12-01T14:20:38.0&#x27;, Value: 0.0779815107 });
store.push({ Time: &#x27;2015-12-01T14:20:39.0&#x27;, Value: 0.8945312691 });
store.push({ Time: &#x27;2015-12-01T14:20:40.0&#x27;, Value: 0.5574567409 });

// get the quantile estimations
var result &#x3D; td.getFloatVector();
base.close();</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The given name of the stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type for the stream aggregator. <b>Important:</b> It must be equal to <code>'tdigest'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>store</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store from which it takes the data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>inAggr</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the stream aggregator to which it connects and gets data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>quantiles</p>
        </td>
        <td>
                <p>Array of number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>An array of numbers between 0 and 1 for which the quantile bands will be computed.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>minCount</p>
        </td>
        <td>
                <p>Number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The minimal number of values given before it start to compute the quantiles.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~StreamAggrThreshold"><span class="symbol-name">StreamAggrThreshold</span><small class="property-type">
            &nbsp;module:qmStreamAggr</small></h3>            <p>This stream aggregator represents a threshold indicator. It outputs 1 if the current value in the data streams is
above the threshold and 0 otherwise. It implements the following methods:
<br>1. <a href="module-qm.StreamAggr.html#getFloat">module:qm.StreamAggr#getFloat</a> returns the exponentional average of the values in its buffer window.
<br>2. <a href="module-qm.StreamAggr.html#getTimestamp">module:qm.StreamAggr#getTimestamp</a> returns the timestamp of the newest record in its buffer window.</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import the qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a base with a simple store
var base &#x3D; new qm.Base({
   mode: &quot;createClean&quot;,
   schema: [
   {
       name: &quot;Heat&quot;,
       fields: [
           { name: &quot;Celsius&quot;, type: &quot;float&quot; },
           { name: &quot;Time&quot;, type: &quot;datetime&quot; }
       ]
   }]
});

// create a new time series tick stream aggregator for the &#x27;Heat&#x27; store, that takes the values from the &#x27;Celsius&#x27; field
// and the timestamp from the &#x27;Time&#x27; field. The size of the window should be 1 hour.
var timeser &#x3D; {
   name: &#x27;TimeSeriesTickAggr&#x27;,
   type: &#x27;timeSeriesTick&#x27;,
   store: &#x27;Heat&#x27;,
   timestamp: &#x27;Time&#x27;,
   value: &#x27;Celsius&#x27;
};
var timeSeries &#x3D; base.store(&quot;Heat&quot;).addStreamAggr(timeser);

// a threshold aggregator, that is connected wit hthe &#x27;TimeSeriesAggr&#x27; aggregator.
// It should output 1 when the temperature is over 3 degrees Celsius and 0 otherwise
var thresholdAggr &#x3D; {
   name: &#x27;thresholdAggr1&#x27;,
   type: &#x27;threshold&#x27;,
   store: &#x27;Heat&#x27;,
   inAggr: &#x27;TimeSeriesTickAggr&#x27;,
   threshold: 3
};
var expoMovingAverage &#x3D; base.store(&quot;Heat&quot;).addStreamAggr(thresholdAggr);
base.close();</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The given name for the stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the stream aggregator. <b>Important:</b> It must be equal to <code>'ema'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>store</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store from which it takes the data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>inAggr</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the stream aggregator to which it connects and gets data.
It <b>cannot</b> be connect to the <a href="module-qm.html#~StreamAggrTimeSeriesWindow">module:qm~StreamAggrTimeSeriesWindow</a>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>threshold</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The threshold mentioned above.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~StreamAggrTimeSeriesTick"><span class="symbol-name">StreamAggrTimeSeriesTick</span><small class="property-type">
            &nbsp;<a href="module-qm.StreamAggr.html">module:qm.StreamAggr</a></small></h3>            <p>This stream aggregator represents the time series tick window buffer. It exposes the data to other stream aggregators
(similar to <a href="module-qm.html#~StreamAggrTimeSeriesWindow">module:qm~StreamAggrTimeSeriesWindow</a>). It implements the following methods:
<br>1. <a href="module-qm.StreamAggr.html#getFloat">module:qm.StreamAggr#getFloat</a> returns the last value added in its buffer window.
<br>2. <a href="module-qm.StreamAggr.html#getTimestamp">module:qm.StreamAggr#getTimestamp</a> returns the timestamp of the newest record in its buffer window.</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import the qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a base with a simple store
var base &#x3D; new qm.Base({
   mode: &quot;createClean&quot;,
   schema: [
   {
       name: &quot;Students&quot;,
       fields: [
           { name: &quot;Id&quot;, type: &quot;float&quot; },
           { name: &quot;TimeOfGraduation&quot;, type: &quot;datetime&quot; }
       ]
   }]
});

// create a new time series tick stream aggregator for the &#x27;Students&#x27; store, that takes the values from the &#x27;Id&#x27; field
// and the timestamp from the &#x27;TimeOfGraduation&#x27; field.
var tick &#x3D; {
   name: &#x27;TimeSeriesTickAggr&#x27;,
   type: &#x27;timeSeriesTick&#x27;,
   store: &#x27;Students&#x27;,
   timestamp: &#x27;TimeOfGraduation&#x27;,
   value: &#x27;Id&#x27;,
};
var timeSeriesTick &#x3D; base.store(&quot;Students&quot;).addStreamAggr(tick);
base.close();</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The given name for the stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the stream aggregator. <b>Important:</b> It must be equal to <code>'timeSeriesTick'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>store</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store from which it takes the data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>value</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store field, from which it takes the values.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>timestamp</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store field, from which it takes the timestamp.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~StreamAggrTimeSeriesWindow"><span class="symbol-name">StreamAggrTimeSeriesWindow</span><small class="property-type">
            &nbsp;<a href="module-qm.StreamAggr.html">module:qm.StreamAggr</a></small></h3>            <p>This stream aggregator represents the time series window buffer. It stores the values inside a moving window.
It implements all the stream aggregate methods <b>except</b> <a href="module-qm.StreamAggr.html#getFloat">module:qm.StreamAggr#getFloat</a> and <a href="module-qm.StreamAggr.html#getTimestamp">module:qm.StreamAggr#getTimestamp</a>.</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import the qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a base with a simple store
var base &#x3D; new qm.Base({
   mode: &quot;createClean&quot;,
   schema: [
   {
       name: &quot;Heat&quot;,
       fields: [
           { name: &quot;Celsius&quot;, type: &quot;float&quot; },
           { name: &quot;Time&quot;, type: &quot;datetime&quot; }
       ]
   }]
});

// create a new time series stream aggregator for the &#x27;Heat&#x27; store, that takes the values from the &#x27;Celsius&#x27; field
// and the timestamp from the &#x27;Time&#x27; field. The size of the window is 2 seconds (2000ms).
var aggr &#x3D; {
   name: &#x27;TimeSeriesAggr&#x27;,
   type: &#x27;timeSeriesWinBuf&#x27;,
   store: &#x27;Heat&#x27;,
   timestamp: &#x27;Time&#x27;,
   value: &#x27;Celsius&#x27;,
   winsize: 2000
};
base.store(&quot;Heat&quot;).addStreamAggr(aggr);
base.close();</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The given name of the stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the stream aggregator. <b>Important:</b> It must be equal to <code>'timeSeriesWinBuf'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>store</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store from which to takes the data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>timestamp</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The field of the store, where it takes the timestamp.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>value</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The field of the store, where it takes the values.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>winsize</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The size of the window, in milliseconds.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>delay</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>Delay in milliseconds.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~StreamAggrTimeSeriesWindowVector"><span class="symbol-name">StreamAggrTimeSeriesWindowVector</span><small class="property-type">
            &nbsp;<a href="module-qm.StreamAggr.html">module:qm.StreamAggr</a></small></h3>            <p>This stream aggregator represents the values read from a time series window buffer.
It implements <a href="module-qm.StreamAggr.html#getFloatVector">module:qm.StreamAggr#getFloatVector</a>, <a href="module-qm.StreamAggr.html#getFloatAt">module:qm.StreamAggr#getFloatAt</a> and <a href="module-qm.StreamAggr.html#getFloatLength">module:qm.StreamAggr#getFloatLength</a>.</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import the qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a base with a simple store
var base &#x3D; new qm.Base({
   mode: &quot;createClean&quot;,
   schema: [{
       name: &quot;Heat&quot;,
       fields: [
           { name: &quot;Celsius&quot;, type: &quot;float&quot; },
           { name: &quot;Time&quot;, type: &quot;datetime&quot; }
       ]
   }]
});

var store &#x3D; base.store(&quot;Heat&quot;);
var tick &#x3D; store.addStreamAggr({
    type: &#x27;timeSeriesTick&#x27;,
    timestamp: &#x27;Time&#x27;,
    value: &#x27;Celsius&#x27;
});

var winbufvec &#x3D; store.addStreamAggr({
    type: &#x27;timeSeriesWinBufVector&#x27;,
    inAggr: tick.name,
    winsize: 2000
});

store.push({ Time: &#x27;2015-06-10T14:13:32.0&#x27;, Celsius: 1 });
winbufvec.getFloatVector().print(); // prints 1
store.push({ Time: &#x27;2015-06-10T14:33:30.0&#x27;, Celsius: 2 });
winbufvec.getFloatVector().print(); // prints 2
store.push({ Time: &#x27;2015-06-10T14:33:31.0&#x27;, Celsius: 3 });
winbufvec.getFloatVector().print(); // prints 2,3
store.push({ Time: &#x27;2015-06-10T14:33:32.0&#x27;, Celsius: 4 });
winbufvec.getFloatVector().print(); // prints 2,3,4

base.close();</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The given name of the stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type of the stream aggregator. <b>Important:</b> It must be equal to <code>'timeSeriesWinBuf'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>store</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store from which to takes the data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>inAggr</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the window buffer aggregate that represents the input.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~StreamAggrVecDiff"><span class="symbol-name">StreamAggrVecDiff</span><small class="property-type">
            &nbsp;<a href="module-qm.StreamAggr.html">module:qm.StreamAggr</a></small></h3>            <p>This stream aggregator represents difference between two vectors (e.g. online histograms).
It implements the following methods:
<br>1. <a href="module-qm.StreamAggr.html#getFloatLength">module:qm.StreamAggr#getFloatLength</a> returns the number of bins.
<br>2. <a href="module-qm.StreamAggr.html#getFloatAt">module:qm.StreamAggr#getFloatAt</a> returns the count for a bin index.
<br>3. <a href="module-qm.StreamAggr.html#getFloatVector">module:qm.StreamAggr#getFloatVector</a> returns the vector of counts, the length is equal to the number of bins.</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>// import the qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a base with a simple store
// the store records results of clustering
var base &#x3D; new qm.Base({
mode: &quot;createClean&quot;,
schema: [
{
  name: &quot;Rpm&quot;,
  fields: [
      { name: &quot;ClusterId&quot;, type: &quot;float&quot; },
      { name: &quot;Time&quot;, type: &quot;datetime&quot; }
  ]
}]
});

var store &#x3D; base.store(&#x27;Rpm&#x27;);

// create a new time series stream aggregator for the &#x27;Rpm&#x27; store that takes the recorded cluster id
// and the timestamp from the &#x27;Time&#x27; field. The size of the window is 4 weeks.
var timeser1 &#x3D; {
  name: &#x27;TimeSeries1&#x27;,
  type: &#x27;timeSeriesWinBuf&#x27;,
  store: &#x27;Rpm&#x27;,
  timestamp: &#x27;Time&#x27;,
  value: &#x27;ClusterId&#x27;,
  winsize: 7200000 // 2 hours
};
var timeSeries1 &#x3D; base.store(&quot;Rpm&quot;).addStreamAggr(timeser1);

// add a histogram aggregator, that is connected with the &#x27;TimeSeries1&#x27; aggregator
var aggrJson1 &#x3D; {
  name: &#x27;Histogram1&#x27;,
  type: &#x27;onlineHistogram&#x27;,
  store: &#x27;Rpm&#x27;,
  inAggr: &#x27;TimeSeries1&#x27;,
  lowerBound: 0,
  upperBound: 5,
  bins: 5,
  addNegInf: false,
  addPosInf: false
};
var hist1 &#x3D; base.store(&quot;Rpm&quot;).addStreamAggr(aggrJson1);

// create a new time series stream aggregator for the &#x27;Rpm&#x27; store that takes the recorded cluster id
// and the timestamp from the &#x27;Time&#x27; field.
var timeser2 &#x3D; {
  name: &#x27;TimeSeries2&#x27;,
  type: &#x27;timeSeriesWinBuf&#x27;,
  store: &#x27;Rpm&#x27;,
  timestamp: &#x27;Time&#x27;,
  value: &#x27;ClusterId&#x27;,
  winsize: 21600000 // 6 hours
};
var timeSeries2 &#x3D; base.store(&quot;Rpm&quot;).addStreamAggr(timeser2);

// add a histogram aggregator, that is connected with the &#x27;TimeSeries1&#x27; aggregator
var aggrJson2 &#x3D; {
  name: &#x27;Histogram2&#x27;,
  type: &#x27;onlineHistogram&#x27;,
  store: &#x27;Rpm&#x27;,
  inAggr: &#x27;TimeSeries2&#x27;,
  lowerBound: 0,
  upperBound: 5,
  bins: 5,
  addNegInf: false,
  addPosInf: false
};
var hist2 &#x3D; base.store(&quot;Rpm&quot;).addStreamAggr(aggrJson2);

// add diff aggregator that subtracts Histogram1 with 2h window from Histogram2 with 6h window
var aggrJson3 &#x3D; {
  name: &#x27;DiffAggr&#x27;,
  type: &#x27;onlineVecDiff&#x27;,
  storeX: &#x27;Rpm&#x27;,
  storeY: &#x27;Rpm&#x27;,
  inAggrX: &#x27;Histogram2&#x27;,
  inAggrY: &#x27;Histogram1&#x27;
}
var diff &#x3D; store.addStreamAggr(aggrJson3);
base.close();</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The given name of the stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The type for the stream aggregator. <b>Important:</b> It must be equal to <code>'onlineVecDiff'</code>.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>storeX</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store from which it takes the data for the first vector.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>storeY</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the store from which it takes the data for the second vector.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>inAggrX</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the first stream aggregator to which it connects and gets data.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>inAggrY</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the second stream aggregator to which it connects and gets data.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

                <div class="symbol-detail-labels"><span class="label label-inner">inner</span></div><h3 id="~StreamAggrWindowQuantiles"><span class="symbol-name">StreamAggrWindowQuantiles</span><small class="property-type">
            &nbsp;<a href="module-qm.StreamAggr.html">module:qm.StreamAggr</a></small></h3>            <p>This stream aggregate computes approximate quantiles on a sliding time window using
the SW-GK algorithm proposed in:
http://dl.acm.org/citation.cfm?id=2954329</p>
<p>The quantile values are returned using <a href="module-qm.StreamAggr.html#getFloatVector">module:qm.StreamAggr#getFloatVector</a>.</p>

            <section>
        <h4>
            Example
        </h4>
                <div>
    <pre class="prettyprint"><code>var assert &#x3D; require(&#x27;assert&#x27;);
var qm &#x3D; require(&#x27;qminer&#x27;);

// variables
var batchSize &#x3D; 1000;
var nbatches &#x3D; 10;

var dt &#x3D; 10;
var windowMSec &#x3D; batchSize*dt;

var quantileEps &#x3D; 0.01;
var countEps &#x3D; 0.0001;

var maxRelErr &#x3D; quantileEps + 2*countEps;

var targetQuants &#x3D; (function () {
    var quants &#x3D; [];
    for (var prob &#x3D; 0; prob &lt;&#x3D; 1; prob +&#x3D; 0.001) {
        quants.push(prob);
    }
    return quants;
})();

// create a base with a simple store
// the store records results of throwing two independent fair dices
var base &#x3D; new qm.Base({
    mode: &quot;createClean&quot;,
    schema: [
    {
        name: &quot;hugeDie&quot;,
        fields: [
            { name: &quot;value&quot;, type: &quot;float&quot; },
            { name: &quot;time&quot;, type: &quot;datetime&quot; }
        ]
    }]
});
var store &#x3D; base.store(&#x27;hugeDie&#x27;);

// create a new time series stream aggregator for the &#x27;Dice&#x27; store, that takes the expected values of throwing a dice
// and the timestamp from the &#x27;Time&#x27; field. The size of the window is 1 day.
var windowAggr &#x3D; store.addStreamAggr({
    name: &#x27;TimeSeries1&#x27;,
    type: &#x27;timeSeriesWinBuf&#x27;,
    store: store,
    timestamp: &#x27;time&#x27;,
    value: &#x27;value&#x27;,
    winsize: windowMSec
});

var gk &#x3D; store.addStreamAggr({
type: &#x27;windowQuantiles&#x27;,
    inAggr: windowAggr,
    quantileEps: quantileEps,
    countEps: countEps,
    quantiles: targetQuants
})

var vals &#x3D; [];
for (var i &#x3D; 0; i &lt; batchSize; i++) {
    vals.push(i);
}
for (var batchN &#x3D; 0; batchN &lt; nbatches; batchN++) {
    // shuffle the array
    for (var i &#x3D; 0; i &lt; batchSize; i++) {
        var swapN &#x3D; Math.floor(Math.random()*batchSize);
        var temp &#x3D; vals[i];
        vals[i] &#x3D; vals[swapN];
        vals[swapN] &#x3D; temp;
    }

    for (var i &#x3D; 0; i &lt; batchSize; i++) {
        var time &#x3D; (batchN*batchSize + i)*dt;
        store.push({ time: time, value: vals[i] })
    }

    var result &#x3D; gk.getFloatVector();
    for (var i &#x3D; 0; i &lt; targetQuants.length; i++) {
        var pval &#x3D; targetQuants[i];
        var quant_hat &#x3D; result[i];
        assert(Math.floor((pval - maxRelErr)*batchSize) &lt;&#x3D; quant_hat);
        assert(Math.ceil((pval + maxRelErr)*batchSize) &gt;&#x3D; quant_hat);
    }
}</code></pre>
</div>

    </section>

        
            <section>
        <h4>Properties</h4>
            <table class="jsdoc-details-table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
                <tr>
        <td>
            <p>name</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The given name of the stream aggregator.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>type</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>Must use type 'windowQuantiles'.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>inAggr</p>
        </td>
        <td>
                <p>string</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>The name of the stream aggregate which defines the time window.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>quantiles</p>
        </td>
        <td>
                <p>Array of number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>An array of p-values for which the algorithm will return quantiles.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>quantileEps</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>Maximal relative error of the quantile estimation procedure.</p>
        </td>
</tr>

                <tr>
        <td>
            <p>countEps</p>
        </td>
        <td>
                <p>number</p>
        </td>
        <td>
                <p>&nbsp;</p>
        </td>
        <td>
                <p>Maximal relative error of the count procedure.</p>
<p>If the number of items in the window is N, then the algorithms error is bound by
N*(quantileEps + 2*countEps + O(countEps^2)). However in practice, the error should
be less.</p>
        </td>
</tr>

        </tbody>
</table>

    </section>


        <dl class="dl-compact">
            






















        </dl>

    </section>


            
</section>

                                        </div>
                                </div>
                                <nav id="jsdoc-toc-nav" role="navigation"></nav>
                        </div>
                </div>
                    <footer id="jsdoc-footer" class="jsdoc-footer">
                            <div id="jsdoc-footer-container">
                                    <p>
                                      
                                    </p>
                            </div>
                    </footer>
                <script src="scripts/jquery.min.js"></script>
                <script src="scripts/tree.jquery.js"></script>
                <script src="scripts/prettify.js"></script>
                <script src="scripts/jsdoc-toc.js"></script>
                <script src="scripts/linenumber.js"></script>
                <script src="scripts/scrollanchor.js"></script>
        </body>
</html>
