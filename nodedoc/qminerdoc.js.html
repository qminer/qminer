<!doctype html>
<html>
        <head>
                <meta name="generator" content="JSDoc 3">
                <meta charset="utf-8">
                <title>Source: qminerdoc.js</title>
                <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Karla:400,400i,700,700i" type="text/css">
                <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Noto+Serif:400,400i,700,700i" type="text/css">
                <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Inconsolata:500" type="text/css">
                <link href="css/baseline.css" rel="stylesheet">
        </head>
        <body onload="prettyPrint()">
                <nav id="jsdoc-navbar" role="navigation" class="jsdoc-navbar">
    <div id="jsdoc-navbar-container">
        <div id="jsdoc-navbar-content">
            <a href="index.html" class="jsdoc-navbar-package-name">Home</a>
        </div>
    </div>
</nav>

                <div id="jsdoc-body-container">
                        <div id="jsdoc-content">
                                <div id="jsdoc-content-container">
                                        <div id="jsdoc-banner" role="banner">
                                        </div>
                                        <div id="jsdoc-main" role="main">
            <header class="page-header">
                <h1>Source: qminerdoc.js</h1>
            </header>
            <article>
                <pre class="prettyprint linenums"><code>/**
 * Copyright (c) 2015, Jozef Stefan Institute, Quintelligence d.o.o. and contributors
 * All rights reserved.
 *
 * This source code is licensed under the FreeBSD license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
* QMiner module.
* @module qm
* @example
* // import module
* var qm = require(&#x27;qminer&#x27;);
*/
/**
    * Creates a directory structure.
    * @param {string} [configPath=&#x27;qm.conf&#x27;] - The path to configuration file.
    * @param {boolean} [overwrite=false] - If you want to overwrite the configuration file.
    * @param {number} [portN=8080] - The number of the port. Currently not used.
    * @param {number} [cacheSize=1024] - Sets available memory for indexing (in MB).
    */
 exports.config = function(configPath, overwrite, portN, cacheSize) {}
/**
    * Creates an empty base.
    * @param {string} [configPath=&#x27;qm.conf&#x27;] - Configuration file path.
    * @param {string} [schemaPath=&#x27;&#x27;] - Schema file path.
    * @param {boolean} [clear=false] - Clear the existing db folder.
    * @returns {module:qm.Base} The newly created base.
    */
 exports.create = function (configPath, schemaPath, clear) { return Object.create(require(&#x27;qminer&#x27;).Base.prototype); }
/**
    * Opens a base.
    * @param {string} [configPath=&#x27;qm.conf&#x27;] - The configuration file path.
    * @param {boolean} [readOnly=false] - Open in read-only mode.
    * @returns {module:qm.Base} The loaded base.
    */
 exports.open = function (configPath, readOnly) { return Object.create(require(&#x27;qminer&#x27;).Base.prototype); }
/**
    * Set verbosity of QMiner internals.
    * @param {number} [level=0] - verbosity level. Possible options:
    * &amp;lt;br&gt;1. &#x60;0&#x60; - No output,
    * &amp;lt;br&gt;2. &#x60;1&#x60; - Log output,
    * &amp;lt;br&gt;3. &#x60;2&#x60; - Log and debug output.
    */
 exports.verbosity = function (level) { }
/**
    * Returns an JSON with two properties: &quot;byClass&quot; and &quot;total&quot;. The &quot;byClass&quot; value is a JSON where
    * each key is a class ID and each value is of the form { newFromCpp: number, newFromJs: number, destructorCalls: number}
    * and the value of &quot;total&quot; is of the same form (aggregated over &quot;byClass&quot;)
    */
 exports.stats = function () { }
/**
    * @typedef {Object} QMinerFlags
    * The object containing the QMiner compile flags.
    * @property {string} buildTime - The module build time.
    * @property {boolean} win - True, if the module is compiled for Windows.
    * @property {boolean} linux - True, if the module is compiled for Linux.
    * @property {boolean} darwin - True, if the module is compiled for Darwin.
    * @property {boolean} x86 - True, if the module is compiled for x86 system.
    * @property {boolean} x64 - True, if the module is compiled for x64 system.
    * @property {boolean} omp - True, if the module is compiled for omp.
    * @property {boolean} debug - True, if the module is compiled for debug mode.
    * @property {boolean} gcc - True, if the module is compiled for gcc.
    * @property {boolean} clang - True, if the module is compiled for clang.
    * @property {boolean} blas - True, if the module is compiled with Blas.
    * @property {boolean} blas_intel - True, if the module is compiled with Intel Blas.
    * @property {boolean} blas_amd - True, if the module is compiled with AMD Blas.
    * @property {boolean} blas_openblas - True, if the module is compiled with OpenBLAS.
    * @property {boolean} lapacke - True, if the module is compiled with Lapacke.
    */
/**
    * Returns an object with all compile flags. Type {@link module:qm~QMinerFlags}.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // get the compile flags
    * var flags = qm.flags;
    */
 exports.flags = { buildTime: &quot;&quot;, win: true, linux: true, darwin: true, x86: true, x64: true, omp: true, debug: true, gcc: true, clang: true, blas: true, blas_intel: true, blas_amd: true, blas_openblas: true, lapacke: true };
/**
    * Returns the module version.
    * @returns {string} The module version.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // get the module version
    * var version = qm.version;
    */
 exports.version = &#x27;&#x27;;
/**
* @typedef {Object} BaseConstructorParam
* Base constructor parameter used for {@link module:qm.Base}.
* @property  {string} [mode=&#x27;openReadOnly&#x27;] - Base access mode. Can be one of the following:
* &amp;lt;br&gt;1. &#x60;&#x27;create&#x27;&#x60; - Sets up the db folder,
* &amp;lt;br&gt;2. &#x60;&#x27;createClean&#x27;&#x60; - Cleans db folder and then sets it up,
* &amp;lt;br&gt;3. &#x60;&#x27;open&#x27;&#x60; - Opens the db with read/write permissions,
* &amp;lt;br&gt;4. &#x60;&#x27;openReadOnly&#x27;&#x60; - Opens the db in read only mode.
* @property  {number} [indexCache=1024] - The ammount of memory reserved for indexing (in MB).
* @property  {number} [storeCache=1024] - The ammount of memory reserved for store cache (in MB).
* @property  {string} [schemaPath=&#x27;&#x27;] - The path to schema definition file.
* @property  {Array&amp;lt;module:qm~SchemaDef&gt;} [schema=[]] - Schema definition object array.
* @property  {string} [dbPath=&#x27;./db/&#x27;] - The path to db directory.
*/
/**
* @typedef {Object} SchemaDef
* Store schema definition used in {@link module:qm~BaseConstructorParam}.
* @property {string} name - The name of the store. Store name can be composed by from English letters, numbers, _ or $ characters. It can only begin with a character.
* @property {Array&amp;lt;module:qm~SchemaFieldDef&gt;} fields - The array of field descriptors.
* @property {Array&amp;lt;module:qm~SchemaJoinDef&gt;} [joins=[]] - The array of join descriptors, used for linking records from different stores.
* @property {Array&amp;lt;module:qm~SchemaKeyDef&gt;} [keys=[]] - The array of key descriptors. Keys define how records are indexed, which is needed for search using the query language.
* @property {module:qm~SchemaTimeWindowDef} [timeWindow] - Time window description. Stores can have a window, which is used by garbage collector to delete records once they fall out of the time window. Window can be defined by number of records or by time.
* @example
* var qm = require(&#x27;qminer&#x27;);
* // create a simple movies store, where each record contains only the movie title.
* var base = new qm.Base({
*     mode: &#x27;createClean&#x27;,
*     schema: [{
*       name: &quot;Movies&quot;,
*       fields: [{ name: &quot;title&quot;, type: &quot;string&quot; }]
*     }]
* });
* base.close();
*/
/**
* @typedef {Object} SchemaFieldDef
* Store schema field definition used in {@link module:qm~SchemaDef}.
* @property {string} name - The name of the field.
* @property {string} type - The type of the field. Possible options:
* &amp;lt;br&gt;1. &#x60;&#x27;int&#x27;&#x60; - Signed 32-bit integer,
* &amp;lt;br&gt;2. &#x60;&#x27;uint64&#x27;&#x60; - Unsigned 64-bit integer,
* &amp;lt;br&gt;3. &#x60;&#x27;int_v&#x27;&#x60; - Array of signed 32-bit integers,
* &amp;lt;br&gt;4. &#x60;&#x27;string&#x27;&#x60; - String,
* &amp;lt;br&gt;5. &#x60;&#x27;string_v&#x27;&#x60; - Array of strings,
* &amp;lt;br&gt;6. &#x60;&#x27;bool&#x27;&#x60; - Boolean,
* &amp;lt;br&gt;7. &#x60;&#x27;float&#x27;&#x60; - Double precision flating point number,
* &amp;lt;br&gt;8. &#x60;&#x27;float_pair&#x27;&#x60; - A pair of floats, useful for storing geo coordinates,
* &amp;lt;br&gt;9. &#x60;&#x27;float_v&#x27;&#x60; - Array of floats,
* &amp;lt;br&gt;10. &#x60;&#x27;datetime&#x27;&#x60; - Date and time format, stored in a form of miliseconds since 1600,
* &amp;lt;br&gt;11. &#x60;&#x27;num_sp_v&#x27;&#x60; - Array of [&#x60;int&#x60;, &#x60;float&#x60;] pairs. See constructor array for {@link module:la.SparseVector},
* &amp;lt;br&gt;12. &#x60;&#x27;json&#x27;&#x60; - this field can be an arbitrary object and will be internally serialized into string using JSON notation,
* &amp;lt;br&gt;13. &#x60;&#x27;blob&#x27;&#x60; - Binary buffer, used for storing binary data,
* @property {boolean} [primary=false] - Field which can be used to identify record. There can be only one primary field in a store. There can be at most one record for each value of the primary field. Currently following fields can be marked as primary: &#x60;int&#x60;, &#x60;uint64&#x60;, &#x60;string&#x60;, &#x60;float&#x60;, &#x60;datetime&#x60;. Primary fields of type &#x60;string&#x60; are also used for record querying using {@link module:qm.Store#recordByName}.
* @property {boolean} [null=false] - When set to true, null is a possible value for a field (allow missing values).
* @property {string} [store=&#x27;memory&#x27;] - Defines where to store the field. Possible options
* &amp;lt;br&gt;1. &#x60;&#x27;memory&#x27;&#x60; - Stores the values in RAM.
* &amp;lt;br&gt;2 &#x60;&#x27;cache&#x27;&#x60; - Stores the values on disk, with a layer of FIFO cache in RAM, storing the most recently used values.
* @property {Object} [default] - Default value for field when not given for a new record.
* @property {boolean} [codebook=false] - Useful when many records have only few different values of this field. If set to true, then a separate table of all values is kept, and records only point to this table (replacing variable string field in record serialisation with fixed-length integer). Useful to decrease memory footprint, and faster to update. (STRING FIELD TYPE SPECIFIC).
* @property {boolean} [shortstring=false] - Useful for string shorter then 127 characters (STRING FIELD TYPE SPECIFIC).
* @example
*  var qm = require(&#x27;qminer&#x27;);
*  var base = new qm.Base({
*      mode: &#x27;createClean&#x27;,
*      schema: [
*        { name: &#x27;NewsArticles&#x27;,
*          fields: [
*            { name: &quot;ID&quot;, primary: true, type: &quot;string&quot;, shortstring: true },
*            { name: &quot;Source&quot;, type: &quot;string&quot;, codebook: true },
*            { name: &quot;DateTime&quot;, type: &quot;datetime&quot; },
*            { name: &quot;Title&quot;, type: &quot;string&quot;, store: &quot;cache&quot; },
*            { name: &quot;Tokens&quot;, type: &quot;string_v&quot;, store: &quot;cache&quot;, null: true },
*            { name: &quot;Vector&quot;, type: &quot;num_sp_v&quot;, store: &quot;cache&quot;, null: true }]
*        }
*     ]
*  });
* // add a record:
* // - we set the date using the ISO string representation
* // - we set the string vector Tokens with an array of strings
* // - we set the numeric sparse vector Vector with an array of two element arrays
* //   (index, value), see the sparse vector constructor {@link module:la.SparseVector}
* base.store(&#x27;NewsArticles&#x27;).push({
*   ID: &#x27;t12344&#x27;,
*   Source: &#x27;s1234&#x27;,
*   DateTime: &#x27;2015-01-01T00:05:00&#x27;,
*   Title: &#x27;the title&#x27;,
*   Tokens: [&#x27;token1&#x27;, &#x27;token2&#x27;],
*   Vector: [[0,1], [1,1]]});
* base.close();
*/
/**
* @typedef {Object} SchemaJoinDef
* Store schema join definition used in {@link module:qm~SchemaDef}.
* @property {string} name - The name of the join.
* @property {string} type - Join types. Possible options:
* &amp;lt;br&gt;1. &#x60;&#x27;field&#x27;&#x60; - Points to zero or one record and is implemented as an additional hidden field of type &#x60;uint64&#x60;, which can hold the ID of the record it links to. Accessing the records join returns a record.
* &amp;lt;br&gt;2. &#x60;&#x27;index&#x27;&#x60; - Point to any number of records and is implemented using the inverted index, where for each record a list (vector) of linked records is kept. Accessing the records join returns a record set.
* &amp;lt;b&gt;Important:&amp;lt;/b&gt; The records given to this join field must be in an array.
*
* @property {string} store - The store name from which the linked records are.
* @example
* var qm = require(&#x27;qminer&#x27;);
* // Create two stores: People which stores only names of persons and Movies, which stores only titles.
* // Each person can direct zero or more movies, so we use an index join named &#x27;directed&#x27; and
* // each movie has a single director, so we use a field join &#x27;director&#x27;. The joins are
* // inverses of each other. The inverse join simplifies the linking, since only one join needs
* // to be specified, and the other direction can be linked automatically (in the example
* // below we specify only the &#x27;director&#x27; link and the &#x27;directed&#x27; join is updated automatically).
* //
* var base = new qm.Base({
*     mode: &#x27;createClean&#x27;,
*     schema: [
*       { name: &#x27;People&#x27;,
*         fields: [{ name: &#x27;name&#x27;, type: &#x27;string&#x27;, primary: true }],
*         joins: [{ name: &#x27;directed&#x27;, &#x27;type&#x27;: &#x27;index&#x27;, &#x27;store&#x27;: &#x27;Movies&#x27;, &#x27;inverse&#x27;: &#x27;director&#x27; }] },
*       { name: &#x27;Movies&#x27;,
*         fields: [{ name: &#x27;title&#x27;, type: &#x27;string&#x27;, primary: true }],
*         joins: [{ name: &#x27;director&#x27;, &#x27;type&#x27;: &#x27;field&#x27;, &#x27;store&#x27;: &#x27;People&#x27;, &#x27;inverse&#x27;: &#x27;directed&#x27; }] }
*     ]
* });
* // Adds a movie, automatically adds &#x27;Jim Jarmusch&#x27; to People, sets the &#x27;director&#x27; join (field join)
* // and automatically updates the index join &#x27;directed&#x27;, since it&#x27;s an inverse join of &#x27;director&#x27;
* base.store(&#x27;Movies&#x27;).push({ title: &#x27;Broken Flowers&#x27;, director: { name: &#x27;Jim Jarmusch&#x27; } });
*
* // Adds a movie, sets the &#x27;director&#x27; join, updates the index join of &#x27;Jim Jarmusch&#x27;
* base.store(&#x27;Movies&#x27;).push({ title: &#x27;Coffee and Cigarettes&#x27;, director: { name: &#x27;Jim Jarmusch&#x27; } });
* // Adds movie, automatically adds &#x27;Lars von Trier&#x27; to People, sets the &#x27;director&#x27; join
* // and &#x27;directed&#x27; inverse join (automatically)
* base.store(&#x27;Movies&#x27;).push({ title: &#x27;Dogville&#x27;, director: { name: &#x27;Lars von Trier&#x27; } });
*
* // Adds a person, sets the &#x27;directed&#x27; join with multiple movies (&#x27;directed&#x27; is of type &#x27;index&#x27;, movies must be given in an array)
* base.store(&#x27;People&#x27;).push({ name: &#x27;Christopher Nolan&#x27;, directed: [{ title: &#x27;Inception&#x27; }, { title: &#x27;Interstellar&#x27; }] });
*
* var movie = base.store(&#x27;Movies&#x27;)[0]; // get the first movie (Broken Flowers)
* // Each movie has a property corresponding to the join name: &#x27;director&#x27;.
* // Accessing the property returns a {@link module:qm.Record} from the store People.
* var person = movie.director; // get the director
* var personName = person.name; // get person&#x27;s name (&#x27;Jim Jarmusch&#x27;)
*
* // Each person has a property corresponding to the join name: &#x27;directed&#x27;.
* // Accessing the property returns a {@link module:qm.RecSet} from the store People.
* var movies = person.directed; // get all the movies the person directed.
* movies.each(function (movie) { var title = movie.title; });
* // Gets the following titles:
* //   &#x27;Broken Flowers&#x27;
* //   &#x27;Coffee and Cigarettes&#x27;
* base.close();
*/
/**
* @typedef {Object} SchemaKeyDef
* Store schema key definition used in {@link module:qm~SchemaDef}.
* @property {string} field - The name of the field that will be indexed.
* @property {string} type - Key type. Possible options:
* &amp;lt;br&gt;1. &#x60;&#x27;value&#x27;&#x60; - Indexes records using an inverted index using full value of the field (no processing).
*  The key type supports &#x60;&#x27;string&#x27;&#x60;, &#x60;&#x27;string_v&#x27;&#x60; and &#x60;&#x27;datetime&#x27;&#x60; fields types.
* &amp;lt;br&gt;2. &#x60;&#x27;text&#x27;&#x60; - Indexes string fields by using a tokenizer and text processing. Supported by &#x60;&#x27;string&#x27;&#x60; fields.
* &amp;lt;br&gt;3. &#x60;&#x27;location&#x27;&#x60;- Indexes records as points on a sphere and enables nearest-neighbour queries. Supported by &#x60;&#x27;float_pair&#x27;&#x60; type fields.
* @property {string} [name] - Allows using a different name for the key in search queries. This allows for multiple keys to be put against the same field. Default value is the name of the field.
* @property {string} [vocabulary] - Defines the name of the vocabulary used to store the tokens or values. This can be used indicate to several keys to use the same vocabulary, to save on memory. Supported by &#x60;&#x27;value&#x27;&#x60; and &#x60;&#x27;text&#x27;&#x60; keys.
* @property {string} [tokenize] - Defines the tokenizer that is used for tokenizing the values stored in indexed fields. Tokenizer uses same parameters as in bag-of-words feature extractor. Default is english stopword list and no stemmer. Supported by &#x60;&#x27;text&#x27;&#x60; keys.
* @example
* var qm = require(&#x27;qminer&#x27;);
* // Create a store People which stores only names of persons.
* var base = new qm.Base({
*     mode: &#x27;createClean&#x27;,
*     schema: [
*         { name: &#x27;People&#x27;,
*           fields: [{ name: &#x27;name&#x27;, type: &#x27;string&#x27;, primary: true }],
*           keys: [
*             { field: &#x27;name&#x27;, type: &#x27;value&#x27;},
*             { field: &#x27;name&#x27;, name: &#x27;nameText&#x27;, type: &#x27;text&#x27;}
*          ]
*        }
*     ]
* });
*
* base.store(&#x27;People&#x27;).push({name : &#x27;John Smith&#x27;});
* base.store(&#x27;People&#x27;).push({name : &#x27;Mary Smith&#x27;});
* // search based on indexed values
* base.search({$from : &#x27;People&#x27;, name: &#x27;John Smith&#x27;}); // Return the record set containing &#x27;John Smith&#x27;
* // search based on indexed values
* base.search({$from : &#x27;People&#x27;, name: &#x27;Smith&#x27;}); // Returns the empty record set
* // search based on text indexing
* base.search({$from : &#x27;People&#x27;, nameText: &#x27;Smith&#x27;}); // Returns both records
* base.close();
*/
/**
* @typedef {Object} SchemaTimeWindowDef
* Stores can have a window, which is used by garbage collector to delete records once they
* fall out of the time window. Window can be defined by number of records or by time.
* Window defined by parameter window, its value being the number of records to be kept. Used in {@link module:qm~SchemaDef}.
* &amp;lt;br&gt;&amp;lt;b&gt;Important:&amp;lt;/b&gt; {@link module:qm.Base#garbageCollect} must be called manually to remove records outside time window.
* @property {number} duration - The size of the time window (in number of units).
* @property {string} unit - Defines in which units the window size is specified. Possible options are &#x60;&#x27;second&#x27;&#x60;, &#x60;&#x27;minute&#x27;&#x60;, &#x60;&#x27;hour&#x27;&#x60;, &#x60;&#x27;day&#x27;&#x60;, &#x60;&#x27;week&#x27;&#x60; or &#x60;&#x27;month&#x27;&#x60;.
* @property {string} [field] - Name of the datetime field, which defines the time of the record. In case it is not given, the insert time is used in its place.
* @example &amp;lt;caption&gt;Define window by number of records&amp;lt;/caption&gt;
* var qm = require(&#x27;qminer&#x27;);
* // create base
* var base = new qm.Base({ mode: &#x27;createClean&#x27; });
* // create store with window
* base.createStore({
*     &quot;name&quot;: &quot;TestStore&quot;,
*     &quot;fields&quot;: [
*         { &quot;name&quot;: &quot;DateTime&quot;, &quot;type&quot;: &quot;datetime&quot; },
*         { &quot;name&quot;: &quot;Measurement&quot;, &quot;type&quot;: &quot;float&quot; }
*     ],
*     window: 3,
* });
*
* // push 5 records into created store
* for (var i = 0; i &amp;lt; 5; i++) {
*     var rec = {
*         &quot;DateTime&quot;: new Date().toISOString(),
*         &quot;Measurement&quot;: i
*     };
*     base.store(&quot;TestStore&quot;).push(rec);
* }
*
* // check number of records in store
* base.store(&quot;TestStore&quot;).allRecords.length; // 5
* // clean base with garbage collector
* base.garbageCollect();
* // check number of records in store
* base.store(&quot;TestStore&quot;).allRecords.length; // 3
* base.close();
*
* @example &amp;lt;caption&gt;Define window by time&amp;lt;/caption&gt;
* var qm = require(&#x27;qminer&#x27;);
* // create base
* var base = new qm.Base({ mode: &#x27;createClean&#x27; });
* // create store with window
* base.createStore({
*     &quot;name&quot;: &quot;TestStore&quot;,
*     &quot;fields&quot;: [
*         { &quot;name&quot;: &quot;DateTime&quot;, &quot;type&quot;: &quot;datetime&quot; },
*         { &quot;name&quot;: &quot;Measurement&quot;, &quot;type&quot;: &quot;float&quot; }
*     ],
*     timeWindow: {
*         duration: 2,
*         unit: &quot;hour&quot;,
*         field: &quot;DateTime&quot;
*     }
* });
*
* // push 5 records into created store
* for (var i = 0; i &amp;lt; 5; i++) {
*     var rec = {
*         &quot;DateTime&quot;: new Date(new Date().getTime() + i * 60 * 60 * 1001).toISOString(),
*         &quot;Measurement&quot;: i
*     };
*     base.store(&quot;TestStore&quot;).push(rec);
* }
*
* // check number of records in store
* base.store(&quot;TestStore&quot;).allRecords.length; // 5
* // clean base with garbage collector
* base.garbageCollect();
* // check number of records in store
* base.store(&quot;TestStore&quot;).allRecords.length; // 2
* base.close();
*/
/**
* Base
* @classdesc Represents the database and holds stores.
* @class
* @param {module:qm~BaseConstructorParam} paramObj - The base constructor parameter object.
* @example
* // import qm module
* var qm = require(&#x27;qminer&#x27;);
* // using a constructor, in open mode
* var base = new qm.Base({ mode: &#x27;open&#x27; });
* base.close();
*/
 exports.Base = function (paramObj) { return Object.create(require(&#x27;qminer&#x27;).Base.prototype); };
/**
    * Closes the database.
    * @returns {null} No value is returned.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // using a constructor, in open mode
    * var base = new qm.Base({ mode: &#x27;open&#x27; });
    * // close the database
    * base.close();
    */
 exports.Base.prototype.close = function () { return null; }
/**
    * Checks if the base is closed.
    * @returns {Boolean} Returns &#x60;true&#x60;, if the base is closed.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // using a constructor, in open mode
    * var base = new qm.Base({ mode: &#x27;open&#x27; });
    * // check if the base is closed
    * var closed = base.isClosed();
    * // close the database
    * base.close();
    */
 exports.Base.prototype.isClosed = function () { return true; }
/**
     * Returns the store with the specified name.
     * @param {string} name - Store name.
     * @returns {module:qm.Store} The store.
     * @example
     * // import qm module
     * var qm = require(&#x27;qminer&#x27;);
     * // create a base with two stores
     * var base = new qm.Base({
     *    mode: &quot;createClean&quot;,
     *    schema: [
     *    {
     *        name: &quot;KwikEMart&quot;,
     *        fields: [
     *            { name: &quot;Worker&quot;, type: &quot;string&quot; },
     *            { name: &quot;Groceries&quot;, type: &quot;string_v&quot; }
     *        ]
     *    },
     *    {
     *        name: &quot;NuclearPowerplant&quot;,
     *        fields: [
     *            { name: &quot;Owner&quot;, type: &quot;string&quot; },
     *            { name: &quot;NumberOfAccidents&quot;, type: &quot;int&quot; },
     *            { name: &quot;Workers&quot;, type: &quot;string_v&quot; }
     *        ]
     *    }]
     * });
     * // get the &quot;KwikEMart&quot; store
     * var store = base.store(&quot;KwikEMart&quot;); // returns the store with the name &quot;KwikEMart&quot;
     * base.close();
     */
 exports.Base.prototype.store = function (name) { return Object.create(require(&#x27;qminer&#x27;).Store.prototype); }
/**
     * Checks if there is a store.
     * @param {string} name - Store name.
     * @returns {boolean} True, if there exists a store with the store &#x60;name&#x60;. Otherwise, false.
     * @example
     * // import qm module
     * var qm = require(&#x27;qminer&#x27;);
     * // create a base with two stores
     * var base = new qm.Base({
     *    mode: &quot;createClean&quot;,
     *    schema: [
     *    {
     *        name: &quot;KwikEMart&quot;,
     *        fields: [
     *            { name: &quot;Worker&quot;, type: &quot;string&quot; },
     *            { name: &quot;Groceries&quot;, type: &quot;string_v&quot; }
     *        ]
     *    },
     *    {
     *        name: &quot;NuclearPowerplant&quot;,
     *        fields: [
     *            { name: &quot;Owner&quot;, type: &quot;string&quot; },
     *            { name: &quot;NumberOfAccidents&quot;, type: &quot;int&quot; },
     *            { name: &quot;Workers&quot;, type: &quot;string_v&quot; }
     *        ]
     *    }]
     * });
     * // get the &quot;KwikEMart&quot; store
     * var exists = base.isStore(&quot;KwikEMart&quot;);    // true
     * base.close();
     */
 exports.Base.prototype.isStore = function (name) { return false; }
/**
     * Returns a list of store descriptors.
     * @returns {Array.&amp;lt;object&gt;} An array of store descriptors. The store descriptor &#x60;storeDesc&#x60; contains the properties:
     * &amp;lt;br&gt;1. &#x60;storeDesc.storeId&#x60; - The store ID. Type &#x60;number&#x60;.
     * &amp;lt;br&gt;2. &#x60;storeDesc.storeName&#x60; - Store name. Type &#x60;string&#x60;.
     * &amp;lt;br&gt;3. &#x60;storeDesc.storeRecords&#x60; - Number of records in store. Type &#x60;number&#x60;.
     * &amp;lt;br&gt;4. &#x60;storeDesc.fields&#x60; - The store field schema. Type &amp;lt;code&gt;Array of &amp;lt;a href=&quot;module-qm.html#~SchemaFieldDef&quot;&gt;module:qm.SchemaFieldDef&amp;lt;/a&gt;&amp;lt;/code&gt;.
     * &amp;lt;br&gt;5. &#x60;storeDesc.keys&#x60; - The store key schema. Type &amp;lt;code&gt;Array of &amp;lt;a href=&quot;module-qm.html#~SchemaKeyDef&quot;&gt;module:qm.SchemaKeyDef&amp;lt;/a&gt;&amp;lt;/code&gt;.
     * &amp;lt;br&gt;6. &#x60;storeDesc.joins&#x60; - The store join schema. Type &amp;lt;code&gt;Array of &amp;lt;a href=&quot;module-qm.html#~SchemaJoinDef&quot;&gt;module:qm.SchemaJoinDef&amp;lt;/a&gt;&amp;lt;/code&gt;.
     * @example
     * // import qm module
     * var qm = require(&#x27;qminer&#x27;);
     * // create a base with two stores
     * var base = new qm.Base({
     *    mode: &quot;createClean&quot;,
     *    schema: [
     *    {
     *        name: &quot;KwikEMart&quot;,
     *        fields: [
     *            { name: &quot;Worker&quot;, type: &quot;string&quot; },
     *            { name: &quot;Groceries&quot;, type: &quot;string_v&quot; }
     *        ]
     *    },
     *    {
     *        name: &quot;NuclearPowerplant&quot;,
     *        fields: [
     *            { name: &quot;Owner&quot;, type: &quot;string&quot; },
     *            { name: &quot;NumberOfAccidents&quot;, type: &quot;int&quot; },
     *            { name: &quot;Workers&quot;, type: &quot;string_v&quot; }
     *        ]
     *    }]
     * });
     * // get the list of store descriptors
     * var exists = base.getStoreList();
     * base.close();
     */
 exports.Base.prototype.getStoreList = function () { return [{storeId: 0, storeName:&#x27;&#x27;, storeRecords: 0, fields: [{}], keys: [{}], joins: [{}]}]; }
/**
    * Creates a new store.
    * @param {Array.&amp;lt;module:qm~SchemaDef&gt;} storeDef - The definition of the store(s).
    * @param {number} [storeSizeInMB = 1024] - The reserved size of the store(s).
    * @returns {(module:qm.Store | Array.&amp;lt;module:qm.Store&gt;)} - Returns a store or an array of stores (if the schema definition was an array).
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a new base with one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [
    *    {
    *        name: &quot;Superheroes&quot;,
    *        fields: [
    *            { name: &quot;Name&quot;, type: &quot;string&quot; },
    *            { name: &quot;Superpowers&quot;, type: &quot;string_v&quot; },
    *            { name: &quot;YearsActive&quot;, type: &quot;int&quot; }
    *        ]
    *    }]
    * });
    * // create a new store called &quot;Supervillains&quot; in the base
    * base.createStore({
    *    name: &quot;Supervillians&quot;,
    *    fields: [
    *        { name: &quot;Name&quot;, type: &quot;string&quot; },
    *        { name: &quot;Superpowers&quot;, type: &quot;string_v&quot; },
    *        { name: &quot;YearsActive&quot;, type: &quot;int&quot; }
    *    ]
    * });
    * // create two new stores called &quot;Cities&quot; and &quot;Leagues&quot;
    * base.createStore([
    *    {
    *        name: &quot;Cities&quot;,
    *        fields: [
    *            { name: &quot;Name&quot;, type: &quot;string&quot;, primary: true },
    *            { name: &quot;Population&quot;, type: &quot;int&quot; }
    *        ]
    *    },
    *    {
    *        name: &quot;Leagues&quot;,
    *        fields: [
    *            { name: &quot;Name&quot;, type: &quot;string&quot; },
    *            { name: &quot;Members&quot;, type: &quot;string_v&quot; }
    *        ]
    *    }
    * ]);
    * base.close();
    */
 exports.Base.prototype.createStore = function (storeDef, storeSizeInMB) { return storeDef instanceof Array ? [Object.create(require(&#x27;qminer&#x27;).Store.prototype)] : Object.create(require(&#x27;qminer&#x27;).Store.prototype) ;}
/**
    * @typedef {object} QueryObject
    * The object used for querying records with {@link module:qm.Base#search}.
    * How to construct a query is found on the &amp;lt;a href=&quot;https://github.com/qminer/qminer/wiki/Query-Language&quot;&gt;QMiner Wiki page&amp;lt;/a&gt;.
    */
/**
    * Makes a query search and returns a record set.
    * @param {module:qm~QueryObject} query - Query language JSON object.
    * @returns {module:qm.RecordSet} The record set that matches the search criterion.
    */
 exports.Base.prototype.search = function (query) { return Object.create(require(&#x27;qminer&#x27;).RecordSet.prototype); }
/**
    * Calls qminer garbage collector to remove records outside time windows. For application example see {@link module:qm~SchemaTimeWindowDef}.
    */
 exports.Base.prototype.garbageCollect = function () { }
/**
    * Base saves dirty data given some time window.
    * @param {number} [window=500] - Length of available time window in miliseconds.
    * @returns {number} Number of records it flushed.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a base with two stores
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [
    *    {
    *        name: &quot;KwikEMart&quot;,
    *        fields: [
    *            { name: &quot;Worker&quot;, type: &quot;string&quot; },
    *            { name: &quot;Groceries&quot;, type: &quot;string_v&quot; }
    *        ]
    *    },
    *    {
    *        name: &quot;NuclearPowerplant&quot;,
    *        fields: [
    *            { name: &quot;Owner&quot;, type: &quot;string&quot; },
    *            { name: &quot;NumberOfAccidents&quot;, type: &quot;int&quot; },
    *            { name: &quot;Workers&quot;, type: &quot;string_v&quot; }
    *        ]
    *    }]
    * });
    * // call the garbage collector
    * base.partialFlush();
    * base.close();
    */
 exports.Base.prototype.partialFlush = function () { return 0; }
/**
    * @typedef {object} PerformanceStat
    * The performance statistics used to describe {@link module:qm~PerformanceStatBase} and {@link module:qm~PerformanceStatStore}.
    * @property {number} alloc_count - \\ TODO: Add the description
    * @property {number} alloc_size - \\ TODO: Add the description
    * @property {number} alloc_unused_size - \\ TODO: Add the description
    * @property {number} avg_get_len - \\ TODO: Add the description
    * @property {number} avg_put_len - \\ TODO: Add the description
    * @property {number} avg_get_new_len - \\ TODO: Add the description
    * @property {number} dels - \\ TODO: Add the description
    * @property {number} gets - \\ TODO: Add the description
    * @property {number} puts - \\ TODO: Add the description
    * @property {number} puts_new - \\ TODO: Add the description
    * @property {number} released_count - \\ TODO: Add the description
    * @property {number} released_size - \\ TODO: Add the description
    * @property {number} size_changes - \\ TODO: Add the description
    */
/**
    * @typedef {object} PerformanceStatStore
    * The performance statistics of the store found in {@link module:qm~PerformanceStatBase}.
    * @property {string} name - Store name.
    * @property {module:qm~PerformanceStat} blob_storage_memory - \\ TODO: Add the description
    * @property {module:qm~PerformanceStat} blob_storage_cache - \\ TODO: Add the description
    */
/**
    * @typedef {object} PerformanceStatBase
    * The performance statistics that is returned by {@link module:qm.Base#getStats}.
    * @property {Array.&amp;lt;module:qm~PerformanceStatStore&gt;} stores - The performance statistics of the stores in base. \\ TODO: Check if this is right
    * @property {object} gix_stats - The statistics of the base. \\ TODO: Check if this is right
    * @property {number} gix_stats.avg_len - The average length. \\ TODO: Check if this is right
    * @property {number} gix_stats.cache_all - The number of cache. \\ TODO: Check if this is right
    * @property {number} gix_stats.cache_all_loaded_perc - \\ TODO: Add the description
    * @property {number} gix_stats.cache_dirty - \\ TODO: Add the description
    * @property {number} gix_stats.cache_dirty_loaded_perc - \\ TODO: Add the description
    * @property {number} gix_stats.mem_sed - \\ TODO: Add the description
    * @property {module:qm~PerformanceStat} gix_blob - \\ TODO: Add the description
    */
/**
    * Retrieves performance statistics for qminer.
    * @returns {module:qm~PerformanceStatBase} The performance statistics.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a base with two stores
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [
    *    {
    *        name: &quot;KwikEMart&quot;,
    *        fields: [
    *            { name: &quot;Worker&quot;, type: &quot;string&quot; },
    *            { name: &quot;Groceries&quot;, type: &quot;string_v&quot; }
    *        ]
    *    },
    *    {
    *        name: &quot;NuclearPowerplant&quot;,
    *        fields: [
    *            { name: &quot;Owner&quot;, type: &quot;string&quot; },
    *            { name: &quot;NumberOfAccidents&quot;, type: &quot;int&quot; },
    *            { name: &quot;Workers&quot;, type: &quot;string_v&quot; }
    *        ]
    *    }]
    * });
    * // call the garbage collector
    * base.getStats();
    * base.close();
    */
 exports.Base.prototype.getStats = function () { }
/**
    * Gets the stream aggregate of the given name.
    * @param {string} saName - The name of the stream aggregate.
    * @returns {module:qm.StreamAggr} The stream aggregate whose name is &#x60;saName&#x60;.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a simple base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;People&quot;,
    *        fields: [
    *            { name: &quot;Name&quot;, type: &quot;string&quot; },
    *            { name: &quot;Gendre&quot;, type: &quot;string&quot; },
    *        ]
    *    },
    *    {
    *        name: &quot;Laser&quot;,
    *        fields: [
    *            { name: &quot;Time&quot;, type: &quot;datetime&quot; },
    *            { name: &quot;WaveLength&quot;, type: &quot;float&quot; }
    *        ]
    *    }]
    * });
    *
    * // create a new time series window buffer stream aggregator for &#x27;Laser&#x27; store (with the JSON object)
    * var wavelength = {
    *     name: &quot;WaveLengthLaser&quot;,
    *     type: &quot;timeSeriesWinBuf&quot;,
    *     store: &quot;Laser&quot;,
    *     timestamp: &quot;Time&quot;,
    *     value: &quot;WaveLength&quot;,
    *     winsize: 10000
    * }
    * var sa = base.store(&quot;Laser&quot;).addStreamAggr(wavelength);
    * // get the stream aggregate with the name &#x27;Laser&#x27;
    * var streamAggr = base.getStreamAggr(&#x27;WaveLengthLaser&#x27;);
    * base.close();
    */
 exports.Base.prototype.getStreamAggr = function (saName) { return Object.create(require(&#x27;qminer&#x27;).StreamAggr.prototype); }
/**
    * Gets an array of the stream aggregate names in the base.
    * @returns {Array.&amp;lt;string&gt;} The array containing the stream aggregate names.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a simple base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;People&quot;,
    *        fields: [
    *            { name: &quot;Name&quot;, type: &quot;string&quot; },
    *            { name: &quot;Gendre&quot;, type: &quot;string&quot; },
    *        ]
    *    },
    *    {
    *        name: &quot;Laser&quot;,
    *        fields: [
    *            { name: &quot;Time&quot;, type: &quot;datetime&quot; },
    *            { name: &quot;WaveLength&quot;, type: &quot;float&quot; }
    *        ]
    *    }]
    * });
    *
    * // create a new stream aggregator for &#x27;People&#x27; store, get the length of the record name (with the function object)
    * var aggr = new qm.StreamAggr(base, new function () {
    *    var length = 0;
    *    this.name = &#x27;nameLength&#x27;,
    *    this.onAdd = function (rec) {
    *        length = rec.Name.length;
    *    };
    *    this.saveJson = function (limit) {
    *        return { val: length };
    *    }
    * }, &quot;People&quot;);
    *
    * // create a new time series window buffer stream aggregator for &#x27;Laser&#x27; store (with the JSON object)
    * var wavelength = {
    *     name: &quot;WaveLengthLaser&quot;,
    *     type: &quot;timeSeriesWinBuf&quot;,
    *     store: &quot;Laser&quot;,
    *     timestamp: &quot;Time&quot;,
    *     value: &quot;WaveLength&quot;,
    *     winsize: 10000
    * }
    * var sa = base.store(&quot;Laser&quot;).addStreamAggr(wavelength);
    * // get the stream aggregates names
    * var streamAggrNames = base.getStreamAggrNames();
    * base.close();
    */
 exports.Base.prototype.getStreamAggrNames = function () { return [&quot;&quot;]; }
/**
    * Retrieves performance statistics for stream aggregates.
    */
 exports.Base.prototype.getStreamAggrStats = function () { }
/**
* Stores are containers of records. &amp;lt;br&gt;
* &amp;lt;b&gt;Factory pattern:&amp;lt;/b&gt; this class cannot be construced using the new keyword. This class is constructed when
* calling a specific method or attribute, e.g. constructing the {@link module:qm.Base} using schema or with the
* {@link module:qm.Base#createStore}.
* @class
* @example &amp;lt;caption&gt;Creating a store with createStore function&amp;lt;/caption&gt;
* // import qm module
* var qm = require(&#x27;qminer&#x27;);
* // factory based construction using base.createStore
* var base = new qm.Base({ mode: &#x27;createClean&#x27; });
* base.createStore([{
*    name: &quot;People&quot;,
*    fields: [
*        { name: &quot;Name&quot;, type: &quot;string&quot;, primary: true },
*        { name: &quot;Gender&quot;, type: &quot;string&quot;, shortstring: true },
*        { name: &quot;Age&quot;, type: &quot;int&quot; }
*    ],
*    joins: [
*        { name: &quot;ActedIn&quot;, type: &quot;index&quot;, store: &quot;Movies&quot;, inverse: &quot;Actor&quot; },
*        { name: &quot;Directed&quot;, type: &quot;index&quot;, store: &quot;Movies&quot;, inverse: &quot;Director&quot; }
*    ],
*    keys: [
*        { field: &quot;Name&quot;, type: &quot;text&quot; },
*        { field: &quot;Gender&quot;, type: &quot;value&quot; }
*    ]
* },
* {
*    name: &quot;Movies&quot;,
*    fields: [
*        { name: &quot;Title&quot;, type: &quot;string&quot;, primary: true },
*        { name: &quot;Plot&quot;, type: &quot;string&quot;, store: &quot;cache&quot; },
*        { name: &quot;Year&quot;, type: &quot;int&quot; },
*        { name: &quot;Rating&quot;, type: &quot;float&quot; },
*        { name: &quot;Genres&quot;, type: &quot;string_v&quot;, codebook: true }
*    ],
*    joins: [
*        { name: &quot;Actor&quot;, type: &quot;index&quot;, store: &quot;People&quot;, inverse: &quot;ActedIn&quot; },
*        { name: &quot;Director&quot;, type: &quot;index&quot;, store: &quot;People&quot;, inverse: &quot;Directed&quot; }
*    ],
*    keys: [
*        { field: &quot;Title&quot;, type: &quot;value&quot; },
*        { field: &quot;Plot&quot;, type: &quot;text&quot;, vocabulary: &quot;voc_01&quot; },
*        { field: &quot;Genres&quot;, type: &quot;value&quot; }
*    ]
* }]);
* base.close();
* @example &amp;lt;caption&gt;Creating store with schema in base constructor&amp;lt;/caption&gt;
* // import qm module
* var qm = require(&#x27;qminer&#x27;);
* // using the base constructor
* var base = new qm.Base({
*    mode: &quot;createClean&quot;,
*    schema: [{
*        name: &quot;Class&quot;,
*        fields: [
*            { name: &quot;Name&quot;, type: &quot;string&quot; },
*            { name: &quot;StudyGroup&quot;, type: &quot;string&quot; }
*        ]
*    }]
* });
* base.close();
*/
 exports.Store = function (base, storeDef) { return Object.create(require(&#x27;qminer&#x27;).Store.prototype); };
/**
    * Returns a record from the store.
    * @param {string} recName - Record name.
    * @returns {(module:qm.Record | null)} Returns the record. If the record doesn&#x27;t exist, it returns &#x60;null&#x60;.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a base containing the store Class. Let the Name field be the primary field.
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;Class&quot;,
    *        fields: [
    *            { name: &quot;Name&quot;, type: &quot;string&quot;, primary: true },
    *            { name: &quot;StudyGroup&quot;, type: &quot;string&quot; }
    *        ]
    *    }]
    * });
    * // add some records to the store
    * base.store(&quot;Class&quot;).push({ Name: &quot;Dean&quot;, StudyGroup: &quot;A&quot; });
    * base.store(&quot;Class&quot;).push({ Name: &quot;Chang&quot;, StudyGroup: &quot;D&quot; });
    * base.store(&quot;Class&quot;).push({ Name: &quot;Magnitude&quot;, StudyGroup: &quot;C&quot; });
    * base.store(&quot;Class&quot;).push({ Name: &quot;Leonard&quot;, StudyGroup: &quot;B&quot; });
    * // get the record with the name &quot;Magnitude&quot;
    * var record = base.store(&quot;Class&quot;).recordByName(&quot;Magnitude&quot;);
    * base.close();
    */
 exports.Store.prototype.recordByName = function (recName) { return Object.create(require(&#x27;qminer&#x27;).Record.prototype); };
/**
    * Executes a function on each record in store.
    * @param {function} callback - Function to be executed. It takes two parameters:
    * &amp;lt;br&gt;1. &#x60;rec&#x60; - The current record. Type {@link module:qm.Record}.
    * &amp;lt;br&gt;2. &#x60;idx&#x60; - The index of the current record (&amp;lt;i&gt;optional&amp;lt;/i&gt;). Type &#x60;number&#x60;.
    * @returns {module:qm.Store} Self.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a base containing the store Class
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;Class&quot;,
    *        fields: [
    *            { name: &quot;Name&quot;, type: &quot;string&quot; },
    *            { name: &quot;StudyGroup&quot;, type: &quot;string&quot; }
    *        ]
    *    }]
    * });
    * // add some records to the store
    * base.store(&quot;Class&quot;).push({ Name: &quot;Abed&quot;, StudyGroup: &quot;A&quot; });
    * base.store(&quot;Class&quot;).push({ Name: &quot;Annie&quot;, StudyGroup: &quot;B&quot; });
    * base.store(&quot;Class&quot;).push({ Name: &quot;Britta&quot;, StudyGroup: &quot;C&quot; });
    * base.store(&quot;Class&quot;).push({ Name: &quot;Jeff&quot;, StudyGroup: &quot;A&quot; });
    * // change the StudyGroup of all records of store Class to A
    * base.store(&quot;Class&quot;).each(function (rec) { rec.StudyGroup = &quot;A&quot;; });   // all records in Class are now in study group A
    * base.close();
    */
 exports.Store.prototype.each = function (callback) { return Object.create(require(&#x27;qminer&#x27;).Store.prototype); }
/**
    * Creates an array of function outputs created from the store records.
    * @param {function} callback - Function that generates the array. It takes two parameters:
    * &amp;lt;br&gt;1. &#x60;rec&#x60; - The current record. Type {@link module:qm.Record}.
    * &amp;lt;br&gt;2. &#x60;idx&#x60; - The index of the current record (&amp;lt;i&gt;optional&amp;lt;/i&gt;). Type &#x60;number&#x60;.
    * @returns {Array&amp;lt;Object&gt;} The array created by the callback function.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a base containing the store Class
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;Class&quot;,
    *        fields: [
    *            { name: &quot;Name&quot;, type: &quot;string&quot; },
    *            { name: &quot;StudyGroup&quot;, type: &quot;string&quot; }
    *        ]
    *    }]
    * });
    * // add some records to the store
    * base.store(&quot;Class&quot;).push({ Name: &quot;Shirley&quot;, StudyGroup: &quot;A&quot; });
    * base.store(&quot;Class&quot;).push({ Name: &quot;Troy&quot;, StudyGroup: &quot;B&quot; });
    * base.store(&quot;Class&quot;).push({ Name: &quot;Chang&quot;, StudyGroup: &quot;C&quot; });
    * base.store(&quot;Class&quot;).push({ Name: &quot;Pierce&quot;, StudyGroup: &quot;A&quot; });
    * // make an array of record names
    * var arr = base.store(&quot;Class&quot;).map(function (rec) { return rec.Name; }); // returns an array [&quot;Shirley&quot;, &quot;Troy&quot;, &quot;Chang&quot;, &quot;Pierce&quot;]
    * base.close();
    */
 exports.Store.prototype.map = function (callback) {}
/**
    * Adds a record to the store.
    * @param {object} rec - The added record. The record must be a object corresponding to store schema created at store creation using {@link module:qm~SchemaDef}.
    * @param {boolean} [triggerEvents=true] - If true, all stream aggregate callbacks &#x60;onAdd&#x60; will be called after the record is inserted. If false, no stream aggregate will be updated.
    * @returns {number} The ID of the added record.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a new base containing two stores
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [
    *    {
    *        name: &quot;Superheroes&quot;,
    *        fields: [
    *            { name: &quot;Name&quot;, type: &quot;string&quot; },
    *            { name: &quot;Superpowers&quot;, type: &quot;string_v&quot; }
    *        ]
    *    },
    *    {
    *        name: &quot;Supervillians&quot;,
    *        fields: [
    *            { name: &quot;Name&quot;, type: &quot;string&quot; },
    *            { name: &quot;Superpowers&quot;, type: &quot;string_v&quot; }
    *        ]
    *    }]
    * });
    * // add a new superhero to the Superheroes store
    * base.store(&quot;Superheroes&quot;).push({ Name: &quot;Superman&quot;, Superpowers: [&quot;flight&quot;, &quot;heat vision&quot;, &quot;bulletproof&quot;] }); // returns 0
    * // add a new supervillian to the Supervillians store
    * base.store(&quot;Supervillians&quot;).push({ Name: &quot;Lex Luthor&quot;, Superpowers: [&quot;expert engineer&quot;, &quot;genius-level intellect&quot;, &quot;money&quot;] }); // returns 0
    * base.close();
    */
 exports.Store.prototype.push = function (rec, triggerEvents) { return 0; }
/**
    * Creates a new record of given store. The record is not added to the store.
    * @param {object} obj - An object describing the record.
    * @returns {module:qm.Record} The record created by &#x60;obj&#x60; and the store.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a new base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;Planets&quot;,
    *        fields: [
    *            { name: &quot;Name&quot;, type: &quot;string&quot; },
    *            { name: &quot;Diameter&quot;, type: &quot;int&quot; },
    *            { name: &quot;NearestStars&quot;, type: &quot;string_v&quot; }
    *        ]
    *    }]
    * });
    * // add a new planet in the store
    * base.store(&quot;Planets&quot;).push({ Name: &quot;Earth&quot;, Diameter: 299196522, NearestStars: [&quot;Sun&quot;] });
    * // create a record of a planet (not added to the Planets store)
    * var planet = base.store(&quot;Planets&quot;).newRecord({ Name: &quot;Tatooine&quot;, Diameter: 10465, NearestStars: [&quot;Tatoo 1&quot;, &quot;Tatoo 2&quot;] });
    * base.close();
    */
 exports.Store.prototype.newRecord = function (obj) { return Object.create(require(&#x27;qminer&#x27;).Record.prototype); };
/**
    * Creates a new record set out of the records in store.
    * @param {module:la.IntVector} idVec - The integer vector containing the IDs of selected records.
    * @returns {module:qm.RecordSet} The record set that contains the records gained with &#x60;idVec&#x60;.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a new base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;Superheroes&quot;,
    *        fields: [
    *            { name: &quot;Name&quot;, type: &quot;string&quot; },
    *            { name: &quot;Superpowers&quot;, type: &quot;string_v&quot; }
    *        ]
    *    }]
    * });
    * // add some new records to the store
    * base.store(&quot;Superheroes&quot;).push({ Name: &quot;Superman&quot;, Superpowers: [&quot;Superhuman strength, speed, hearing&quot;, &quot;Flight&quot;, &quot;Heat vision&quot;] });
    * base.store(&quot;Superheroes&quot;).push({ Name: &quot;Batman&quot;, Superpowers: [&quot;Genius-level intellect&quot;, &quot;Peak physical and mental conditioning&quot;, &quot;Master detective&quot;] });
    * base.store(&quot;Superheroes&quot;).push({ Name: &quot;Thor&quot;, Superpowers: [&quot;Superhuman strength, endurance and longevity&quot;, &quot;Abilities via Mjolnir&quot;] });
    * base.store(&quot;Superheroes&quot;).push({ Name: &quot;Wonder Woman&quot;, Superpowers: [&quot;Superhuman strength, agility and endurance&quot;, &quot;Flight&quot;, &quot;Highly skilled hand-to-hand combatant&quot;] });
    * // create a new record set containing only the DC Comic superheroes (those with the record ids 0, 1 and 3)
    * var intVec = new qm.la.IntVector([0, 1, 3]);
    * var DCHeroes = base.store(&quot;Superheroes&quot;).newRecordSet(intVec);
    * base.close();
    */
 exports.Store.prototype.newRecordSet = function (idVec) { return Object.create(require(&#x27;qminer&#x27;).RecordSet.prototype); };
/**
    * Creates a record set containing random records from store.
    * @param {number} sampleSize - The size of sample.
    * @returns {module:qm.RecordSet} Returns a record set containing &#x60;sampleSize&#x60; random records.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;TVSeries&quot;,
    *        fields: [
    *            { name: &quot;Title&quot;, type: &quot;string&quot;, primary: true },
    *            { name: &quot;NumberOfEpisodes&quot;, type: &quot;int&quot; }
    *        ]
    *    }]
    * });
    * // add some records in the store
    * base.store(&quot;TVSeries&quot;).push({ Title: &quot;Archer&quot;, NumberOfEpisodes: 75 });
    * base.store(&quot;TVSeries&quot;).push({ Title: &quot;The Simpsons&quot;, NumberOfEpisodes: 574 });
    * base.store(&quot;TVSeries&quot;).push({ Title: &quot;New Girl&quot;, NumberOfEpisodes: 94 });
    * base.store(&quot;TVSeries&quot;).push({ Title: &quot;Rick and Morty&quot;, NumberOfEpisodes: 11 });
    * base.store(&quot;TVSeries&quot;).push({ Title: &quot;Game of Thrones&quot;, NumberOfEpisodes: 47 });
    * // create a sample record set containing 3 records
    * var randomRecordSet = base.store(&quot;TVSeries&quot;).sample(3); // contains 3 random records from the TVSeries store
    * base.close();
    */
 exports.Store.prototype.sample = function (sampleSize) { return Object.create(require(&#x27;qminer&#x27;).RecordSet.prototype); };
/**
    * Gets the details of the selected field.
    * @param {string} fieldName - The field name.
    * @returns {object} The object containing the details of the field. The properties are:
    * &amp;lt;br&gt;1. &#x60;id&#x60; - The ID of the field. Type B4numberB4.
    * &amp;lt;br&gt;2. &#x60;name&#x60; - The name of the field. Type &#x60;string&#x60;.
    * &amp;lt;br&gt;3. &#x60;type&#x60; - The type of the field. Type &#x60;string&#x60;.
    * &amp;lt;br&gt;4. &#x60;nullable&#x60; - If the field value can be null. Type &#x60;boolean&#x60;.
    * &amp;lt;br&gt;5. &#x60;internal&#x60; - If the field is internal. Type &#x60;boolean&#x60;.
    * &amp;lt;br&gt;6. &#x60;primary&#x60; - If the field is primary. Type &#x60;boolean&#x60;.
    * @example
    * // import qm module
    * var qm = require(&quot;qminer&quot;);
    * // create a new base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;People&quot;,
    *        fields: [
    *            { name: &quot;Name&quot;, type: &quot;string&quot;, primary: true },
    *            { name: &quot;Gender&quot;, type: &quot;string&quot; },
    *            { name: &quot;Age&quot;, type: &quot;int&quot; }
    *        ]
    *    }]
    * });
    * // get the details of the field &quot;Name&quot; of store &quot;People&quot;
    * // it returns a JSON object:
    * // { id: 0, name: &quot;Name&quot;, type: &quot;string&quot;, primary: true, nullable: false, internal: false }
    * var details = base.store(&quot;People&quot;).field(&quot;Name&quot;);
    * base.close();
    */
 exports.Store.prototype.field = function (fieldName) { return { id: 0, name:&#x27;&#x27;, type:&#x27;&#x27;, primary: true, internal: true, nullable: true }; };
/**
    * Checks if the field is of numeric type.
    * @param {string} fieldName - The field name.
    * @returns {boolean} True, if the field is of numeric type. Otherwise, false.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;TVSeries&quot;,
    *        fields: [
    *            { name: &quot;Title&quot;, type: &quot;string&quot;, primary: true },
    *            { name: &quot;NumberOfEpisodes&quot;, type: &quot;int&quot; }
    *        ]
    *    }]
    * });
    * // check if the field &quot;Title&quot; is of numeric type
    * var isTitleNumeric = base.store(&quot;TVSeries&quot;).isNumeric(&quot;Title&quot;); // returns false
    * // check if the field &quot;NumberOfEpisodes&quot; is of numeric type
    * var isNumberOfEpisodesNumeric = base.store(&quot;TVSeries&quot;).isNumeric(&quot;NumberOfEpisodes&quot;); // returns true
    * base.close();
    */
 exports.Store.prototype.isNumeric = function (fieldName) { return true; };
/**
    * Checks if the field is of string type.
    * @param {string} fieldName - The field name.
    * @returns {boolean} True, if the field is of string type. Otherwise, false.
    * @example
    * // import qm module
    * var qm = require(&quot;qminer&quot;);
    * // create a new base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;People&quot;,
    *        fields: [
    *            { name: &quot;Name&quot;, type: &quot;string&quot;, primary: true },
    *            { name: &quot;Gender&quot;, type: &quot;string&quot; },
    *            { name: &quot;Age&quot;, type: &quot;int&quot; }
    *        ]
    *    }]
    * });
    * // check if the field &quot;Name&quot; is of string type
    * var isNameString = base.store(&quot;People&quot;).isString(&quot;Name&quot;); // returns true
    * // check if the field &quot;Age&quot; is of string type
    * var isAgeString = base.store(&quot;People&quot;).isString(&quot;Age&quot;); // returns false
    * base.close();
    */
 exports.Store.prototype.isString = function (fieldName) { return true; };
/**
    * Checks if the field is of type Date.
    * @param {string} fieldName - The field name.
    * @returns {boolean} True, if the field is of type Date. Otherwise, false.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a new base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;BasketballPlayers&quot;,
    *        fields: [
    *            { name: &quot;Name&quot;, type: &quot;string&quot; },
    *            { name: &quot;SeasonScore&quot;, type: &quot;int_v&quot; },
    *            { name: &quot;DateOfBirth&quot;, type: &quot;datetime&quot; }
    *        ]
    *    }]
    * });
    * // check if the SeasonScore field is of type Date
    * var isSeasonScoreDate = base.store(&quot;BasketballPlayers&quot;).isDate(&quot;SeasonScore&quot;); // returns false
    * // check if the FirstPlayed field is of type Date
    * var isFirstPlayedDate = base.store(&quot;BasketballPlayers&quot;).isDate(&quot;DateOfBirth&quot;); // returns true
    * base.close();
    */
 exports.Store.prototype.isDate = function (fieldName) { return true; }
/**
    * @typedef {object} DetailKeyObject
    * The details about the key object used in {@link module:qm.Store#key} and {@link module:qm.Store#keys}.
    * @property {module:la.IntVector} fq - The frequency.
    * @property {module:la.StrVector} vocabulary - The vocabulary.
    * @property {string} name - The key name.
    * @property {module:qm.Store} store - The store.
    */
/**
    * Returns the details of the selected key as a object.
    * @param {string} keyName - The key name.
    * @returns {module:qm~DetailKeyObject} The object containing the details of the key.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a new base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;Countries&quot;,
    *        fields: [
    *            { name: &quot;Name&quot;, type: &quot;string&quot;, primary: true },
    *            { name: &quot;Population&quot;, type: &quot;int&quot; },
    *            { name: &quot;Continent&quot;, type: &quot;string&quot; }
    *        ],
    *        keys: [
    *            { field: &quot;Name&quot;, type: &quot;text&quot; },
    *            { field: &quot;Continent&quot;, type: &quot;value&quot; }
    *        ]
    *    }]
    * });
    * // get the details of the key of the field &quot;Continent&quot;
    * // returns a JSON object containing the details of the key:
    * // { fq: { length: 0 }, vocabulary: { length: 0 }, name: &#x27;Continent&#x27;, store: { name: &#x27;Countries&#x27;, ... }}
    * var details = base.store(&quot;Countries&quot;).key(&quot;Continent&quot;);
    * base.close();
    */
 exports.Store.prototype.key = function (keyName) { return { fq: Object.create(require(&#x27;qminer&#x27;).la.IntVector.prototype), vocabulary: Object.create(require(&#x27;qminer&#x27;).la.StrVector.prototype), name:&#x27;&#x27;, store: Object.create(require(&#x27;qminer&#x27;).Store.prototype) }; }
/**
    * Resets all stream aggregates.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a simple base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;Laser&quot;,
    *        fields: [
    *            { name: &quot;Time&quot;, type: &quot;datetime&quot; },
    *            { name: &quot;WaveLength&quot;, type: &quot;float&quot; }
    *        ]
    *    }]
    * });
    *
    * // create a new time series window buffer stream aggregator for &#x27;Laser&#x27; store (with the JSON object)
    * var wavelength = {
    *     name: &quot;WaveLengthLaser&quot;,
    *     type: &quot;timeSeriesWinBuf&quot;,
    *     store: &quot;Laser&quot;,
    *     timestamp: &quot;Time&quot;,
    *     value: &quot;WaveLength&quot;,
    *     winsize: 10000
    * }
    * var sa = base.store(&quot;Laser&quot;).addStreamAggr(wavelength);
    * // reset the stream aggregates on store &quot;Laser&quot;
    * base.store(&quot;Laser&quot;).resetStreamAggregates();
    * base.close();
    */
 exports.Store.prototype.resetStreamAggregates = function () { }
/**
    * Returns an array of the stream aggregates names connected to the store.
    * @returns {Array.&amp;lt;string&gt;} An array of stream aggregates names.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a simple base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;Laser&quot;,
    *        fields: [
    *            { name: &quot;Time&quot;, type: &quot;datetime&quot; },
    *            { name: &quot;WaveLength&quot;, type: &quot;float&quot; }
    *        ]
    *    }]
    * });
    *
    * // create a new time series window buffer stream aggregator for &#x27;Laser&#x27; store (with the JSON object)
    * var wavelength = {
    *     name: &quot;WaveLengthLaser&quot;,
    *     type: &quot;timeSeriesWinBuf&quot;,
    *     store: &quot;Laser&quot;,
    *     timestamp: &quot;Time&quot;,
    *     value: &quot;WaveLength&quot;,
    *     winsize: 10000
    * }
    * var sa = base.store(&quot;Laser&quot;).addStreamAggr(wavelength);
    * // get the stream aggregates on store &quot;Laser&quot;
    * base.store(&quot;Laser&quot;).getStreamAggrNames();
    * base.close();
    */
 exports.Store.prototype.getStreamAggrNames = function () { return [&quot;&quot;]; }
/**
    * Returns the store as a JSON.
    * @returns {Object} The store as a JSON.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a new base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;FootballPlayers&quot;,
    *        fields: [
    *            { name: &quot;Name&quot;, type: &quot;string&quot; },
    *            { name: &quot;FootballClubs&quot;, type: &quot;string_v&quot; },
    *            { name: &quot;GoalsPerSeason&quot;, type: &quot;int_v&quot; },
    *        ]
    *    }]
    * });
    * // get the store as a JSON object
    * // the returned JSON object is:
    * // { storeId: 0, storeName: &#x27;FootballPlayers&#x27;, storeRecords: 0, fields: [...], keys: [], joins: [] }
    * var json = base.store(&quot;FootballPlayers&quot;).toJSON();
    * base.close();
    */
 exports.Store.prototype.toJSON = function () { return { storeId:0, storeName:&#x27;&#x27;, storeRecords:0, fields:[{}], keys:[{}], joins:[{}] }; };
/**
    * Deletes the first records in the store.
    * @param {number} [num] - The number of deleted records. If the number is given, the first &#x60;num&#x60; records will be deleted.
    * @returns {number} The number of remaining records in the store.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;TVSeries&quot;,
    *        fields: [
    *            { name: &quot;Title&quot;, type: &quot;string&quot;, primary: true },
    *            { name: &quot;NumberOfEpisodes&quot;, type: &quot;int&quot; }
    *        ]
    *    }]
    * });
    * // add some records in the store
    * base.store(&quot;TVSeries&quot;).push({ Title: &quot;Archer&quot;, NumberOfEpisodes: 75 });
    * base.store(&quot;TVSeries&quot;).push({ Title: &quot;The Simpsons&quot;, NumberOfEpisodes: 574 });
    * base.store(&quot;TVSeries&quot;).push({ Title: &quot;New Girl&quot;, NumberOfEpisodes: 94 });
    * base.store(&quot;TVSeries&quot;).push({ Title: &quot;Rick and Morty&quot;, NumberOfEpisodes: 11 });
    * base.store(&quot;TVSeries&quot;).push({ Title: &quot;Game of Thrones&quot;, NumberOfEpisodes: 47 });
    * // deletes the first 2 records (Archer and The Simpsons) in TVSeries
    * base.store(&quot;TVSeries&quot;).clear(2); // returns 3
    * // delete all remaining records in TVStore
    * base.store(&quot;TVSeries&quot;).clear();  // returns 0
    * base.close();
    */
 exports.Store.prototype.clear = function (num) { return 0; };
/**
    * Gives a vector containing the field value of each record.
    * @param {string} fieldName - The field name. Field must be of one-dimensional type, e.g. &#x60;int&#x60;, &#x60;float&#x60;, &#x60;string&#x60;...
    * @returns {module:la.Vector} The vector containing the field values of each record.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;Companies&quot;,
    *        fields: [
    *            { name: &quot;Name&quot;, type: &quot;string&quot;, primary: true },
    *            { name: &quot;Location&quot;, type: &quot;string&quot; }
    *        ]
    *    }]
    * });
    * // add some records to the store
    * base.store(&quot;Companies&quot;).push({ Name: &quot;DC Comics&quot;, Location: &quot;Burbank, California&quot; });
    * base.store(&quot;Companies&quot;).push({ Name: &quot;DC Shoes&quot;, Location: &quot;Huntington Beach, California&quot; });
    * base.store(&quot;Companies&quot;).push({ Name: &quot;21st Century Fox&quot;, Location: &quot;New York City, New York&quot; });
    * // get the vector of company names
    * var companyNames = base.store(&quot;Companies&quot;).getVector(&quot;Name&quot;); // returns a vector [&quot;DC Comics&quot;, &quot;DC Shoes&quot;, &quot;21st Century Fox&quot;]
    * base.close();
    */
 exports.Store.prototype.getVector = function (fieldName) { return Object.create(require(&#x27;qminer&#x27;).la.Vector.prototype); };
/**
    * Gives a matrix containing the field values of each record.
    * @param {string} fieldName - The field name. Field mustn&#x27;t be of type &#x60;string&#x60;.
    * @returns {(module:la.Matrix | module:la.SparseMatrix)} The matrix containing the field values.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a new base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;ArcheryChampionship&quot;,
    *        fields: [
    *            { name: &quot;Name&quot;, type: &quot;string&quot; },
    *            { name: &quot;ScorePerRound&quot;, type: &quot;float_v&quot; }
    *        ]
    *    }]
    * });
    * // set new records in the store
    * base.store(&quot;ArcheryChampionship&quot;).push({ Name: &quot;Robin Hood&quot;, ScorePerRound: [50, 48, 48] });
    * base.store(&quot;ArcheryChampionship&quot;).push({ Name: &quot;Oliver Queen&quot;, ScorePerRound: [44, 46, 44] });
    * base.store(&quot;ArcheryChampionship&quot;).push({ Name: &quot;Legolas&quot;, ScorePerRound: [50, 50, 48] });
    * // get the matrix containing the &quot;score per round&quot; values
    * // The values of the i-th column are the values of the i-th record.
    * // The function will give the matrix:
    * // 50  44  50
    * // 48  46  50
    * // 48  44  48
    * var matrix = base.store(&quot;ArcheryChampionship&quot;).getMatrix(&quot;ScorePerRound&quot;);
    * base.close();
    */
 exports.Store.prototype.getMatrix = function (fieldName) { return Object.create(require(&#x27;qminer&#x27;).la.Matrix.prototype); };
/**
    * Gives the field value of a specific record.
    * @param {number} recId - The record id.
    * @param {string} fieldName - The field name.
    * @returns {number | string | Array.&amp;lt;number&gt; | Array.&amp;lt;string&gt;} The &#x60;fieldName&#x60; value of the record with ID &#x60;recId&#x60;.
    * @example
    * //import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a new base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;Festivals&quot;,
    *        fields: [
    *            { name: &quot;Name&quot;, type: &quot;string&quot; },
    *            { name: &quot;Type&quot;, type: &quot;string&quot; },
    *            { name: &quot;Location&quot;, type: &quot;string&quot; }
    *        ]
    *    }]
    * });
    * // add some records in the store
    * base.store(&quot;Festivals&quot;).push({ Name: &quot;Metaldays&quot;, Type: &quot;music&quot;, Location: &quot;Tolmin, Slovenia&quot; });
    * base.store(&quot;Festivals&quot;).push({ Name: &quot;Festival de Cannes&quot;, Type: &quot;movie&quot;, Location: &quot;Cannes, France&quot; });
    * base.store(&quot;Festivals&quot;).push({ Name: &quot;The Festival of Chocolate&quot;, Type: &quot;food&quot;, Location: &quot;Hillsborough, USA&quot; });
    * // get the field value of the second record for field &quot;Type&quot;
    * var fieldValue = base.store(&quot;Festivals&quot;).cell(1, &quot;Type&quot;); // returns &quot;movie&quot;
    * base.close();
    */
 exports.Store.prototype.cell = function (recId, fieldName) {};
/**
    * Calls &#x60;onAdd&#x60; callback on all stream aggregates.
    * @param {(module:qm.Record | number)} [arg] - The record or record ID which will be passed to &#x60;onAdd&#x60; callbacks. If the record or record ID is not provided, the last record will be used. Throws exception if the record cannot be provided.
    * &amp;lt;br&gt;Defaults to the last {@link module:qm.Record} in store.
    */
 exports.Store.prototype.triggerOnAddCallbacks = function (arg) {};
/**
    * Gives the name of the store. Type &#x60;string&#x60;.
    */
 exports.Store.prototype.name = &quot;&quot;;
/**
    * Checks if the store is empty. Type &#x60;boolean&#x60;.
    */
 exports.Store.prototype.empty = true;
/**
    * Gives the number of records. Type &#x60;number&#x60;.
    */
 exports.Store.prototype.length = 0;
/**
    * Creates a record set containing all the records from the store. Type {@link module:qm.RecordSet}.
    */
 exports.Store.prototype.allRecords = Object.create(require(&#x27;qminer&#x27;).RecordSet.prototype);
/**
    * Gives an array of all field descriptor objects. Type &#x60;Array of objects&#x60;, where the objects contain the properties:
    * &amp;lt;br&gt;1. &#x60;id&#x60; - The ID of the field. Type B4numberB4.
    * &amp;lt;br&gt;2. &#x60;name&#x60; - The name of the field. Type &#x60;string&#x60;.
    * &amp;lt;br&gt;3. &#x60;type&#x60; - The type of the field. Type &#x60;string&#x60;.
    * &amp;lt;br&gt;4. &#x60;nullable&#x60; - If the field value can be null. Type &#x60;boolean&#x60;.
    * &amp;lt;br&gt;5. &#x60;internal&#x60; - If the field is internal. Type &#x60;boolean&#x60;.
    * &amp;lt;br&gt;6. &#x60;primary&#x60; - If the field is primary. Type &#x60;boolean&#x60;.
    */
 exports.Store.prototype.fields = [{}];
/**
    * Gives an array of all join descriptor objects. Type &#x60;Array of objects&#x60;, where the objects contain the properties:
    * &amp;lt;br&gt;1. &#x60;id&#x60; - The ID of the join. Type B4numberB4.
    * &amp;lt;br&gt;2. &#x60;name&#x60; - The name of the join. Type &#x60;string&#x60;.
    * &amp;lt;br&gt;2. &#x60;store&#x60; - The store the join was created in. Type &#x60;string&#x60;.
    * &amp;lt;br&gt;2. &#x60;inverse&#x60; - The inverse join. Type &#x60;string&#x60;.
    * &amp;lt;br&gt;3. &#x60;type&#x60; - The type of the field. Type &#x60;string&#x60;.
    * &amp;lt;br&gt;4. &#x60;key&#x60; - The index key. Type {@link module:qm~DetailKeyObject}.
    */
 exports.Store.prototype.joins = [{}];
/**
    * Gives an array of all key descriptor objects. Type &amp;lt;code&gt;Array of &amp;lt;a href=&quot;module-qm.html#~DetailKeyObject&quot;&gt;module:qm~DetailKeyObject&amp;lt;/a&gt;&amp;lt;/code&gt;.
    */
 exports.Store.prototype.keys = [{}];
/**
    * Returns the first record of the store. Type {@link module:qm.Record}.
    */
 exports.Store.prototype.first = Object.create(require(&#x27;qminer&#x27;).Record.prototype);
/**
    * Returns the last record of the store. Type {@link module:qm.Record}.
    */
 exports.Store.prototype.last = Object.create(require(&#x27;qminer&#x27;).Record.prototype);
/**
    * Returns an iterator for iterating over the store from start to end. Type {@link module:qm.Iterator}.
    */
 exports.Store.prototype.forwardIter = Object.create(require(&#x27;qminer&#x27;).Iterator.prototype);
/**
    * Returns an iterator for iterating over the store form end to start. Type {@link module:qm.Iterator}.
    */
 exports.Store.prototype.backwardIter = Object.create(require(&#x27;qminer&#x27;).Iterator.prototype);
/**
    * Gets the record with the given ID.
    * @param {number} recId - The id of the record.
    * @returns {module:qm.Record} The record with the ID equal to &#x60;recId&#x60;.
    * @ignore
    */
 exports.Store.prototype.store = function (recId) { };
/**
    * Returns the base, in which the store is contained. Type {@link module:qm.Base}.
    */
 exports.Store.prototype.base = Object.create(require(&#x27;qminer&#x27;).Base.prototype);
/**
* Records are used for storing data in {@link module:qm.Store}. &amp;lt;br&gt;
* &amp;lt;b&gt;Factory pattern&amp;lt;/b&gt;: this class cannot be construced using the new keyword. This class is constructed
* when calling a specific method or attribute, e.g. using {@link module:qm.Store#push} to create a new record in
* the store or {@link module:qm.Store#newRecord} to create a new record, that is not saved in the store.
* @class
*/
 exports.Record = function () { return Object.create(require(&#x27;qminer&#x27;).qm.Record.prototype); };
/**
    * Clones the record.
    * @returns {module:qm.Record} The clone of the record.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a new base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;StarWarsMovies&quot;,
    *        fields: [
    *            { name: &quot;Title&quot;, type: &quot;string&quot; },
    *            { name: &quot;ReleseDate&quot;, type: &quot;datetime&quot; },
    *            { name: &quot;Length&quot;, type: &quot;int&quot; }
    *        ]
    *    }]
    * });
    * // create some records in the new store
    * base.store(&quot;StarWarsMovies&quot;).push({ Title: &quot;Attack of the Clones&quot;, ReleseDate: &quot;2002-05-16T00:00:00&quot;, Length: 142 });
    * base.store(&quot;StarWarsMovies&quot;).push({ Title: &quot;The Empire Strikes Back&quot;, ReleseDate: &quot;1980-06-20T00:00:00&quot;, Length: 124 });
    * base.store(&quot;StarWarsMovies&quot;).push({ Title: &quot;Return of the Jedi&quot;, ReleseDate: &quot;1983-05-25T00:00:00&quot;, Length: 134 });
    * // create a clone of the &quot;Attack of the Clones&quot; record
    * var clone = base.store(&quot;StarWarsMovies&quot;)[0].$clone();
    * base.close();
    */
 exports.Record.prototype.$clone = function () { return Object.create(require(&#x27;qminer&#x27;).Record.prototype); };
/**
    * Adds a join record &#x60;joinRecord&#x60; to join &#x60;joinName&#x60; (string) with join frequency &#x60;joinFrequency&#x60;.
    * @param {string} joinName - Join name.
    * @param {(module:qm.Record | number)} joinRecord - Joined record or its ID.
    * @param {number} [joinFrequency=1] - Frequency attached to the join.
    * @returns {module:qm.Record} The joined record.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // Create two stores
    * var base = new qm.Base({
    *     mode: &#x27;createClean&#x27;,
    *     schema: [
    *       { name: &#x27;People&#x27;,
    *         fields: [{ name: &#x27;name&#x27;, type: &#x27;string&#x27;, primary: true }],
    *         joins: [{ name: &#x27;directed&#x27;, &#x27;type&#x27;: &#x27;index&#x27;, &#x27;store&#x27;: &#x27;Movies&#x27;, &#x27;inverse&#x27;: &#x27;director&#x27; }] },
    *       { name: &#x27;Movies&#x27;,
    *         fields: [{ name: &#x27;title&#x27;, type: &#x27;string&#x27;, primary: true }],
    *         joins: [{ name: &#x27;director&#x27;, &#x27;type&#x27;: &#x27;field&#x27;, &#x27;store&#x27;: &#x27;People&#x27;, &#x27;inverse&#x27;: &#x27;directed&#x27; }] }
    *     ]
    * });
    * // Add a record to people and a record to movies
    * base.store(&#x27;Movies&#x27;).push({ title: &#x27;Coffee and Cigarettes&#x27; });
    * base.store(&#x27;People&#x27;).push({ name: &#x27;Jim Jarmusch&#x27; });
    *
    * // add a join between the added records
    * base.store(&#x27;People&#x27;)[0].$addJoin(&#x27;directed&#x27;, base.store(&#x27;Movies&#x27;)[0]);
    * base.close();
    */
 exports.Record.prototype.$addJoin = function (joinName, joinRecord, joinFrequency) { return Object.create(require(&#x27;qminer&#x27;).Record.prototype); }
/**
    * Deletes join record &#x60;joinRecord&#x60; from join &#x60;joinName&#x60; (string) with join frequency &#x60;joinFrequency&#x60;.
    * @param {string} joinName - Join name.
    * @param {(module:qm.Record | number)} joinRecord - Joined record or its ID.
    * @param {number} [joinFrequency=1] - Frequency attached to the join.
    * @returns {module:qm.Record} The joined record.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // Create two stores
    * var base = new qm.Base({
    *     mode: &#x27;createClean&#x27;,
    *     schema: [
    *       { name: &#x27;People&#x27;,
    *         fields: [{ name: &#x27;name&#x27;, type: &#x27;string&#x27;, primary: true }],
    *         joins: [{ name: &#x27;directed&#x27;, &#x27;type&#x27;: &#x27;index&#x27;, &#x27;store&#x27;: &#x27;Movies&#x27;, &#x27;inverse&#x27;: &#x27;director&#x27; }] },
    *       { name: &#x27;Movies&#x27;,
    *         fields: [{ name: &#x27;title&#x27;, type: &#x27;string&#x27;, primary: true }],
    *         joins: [{ name: &#x27;director&#x27;, &#x27;type&#x27;: &#x27;field&#x27;, &#x27;store&#x27;: &#x27;People&#x27;, &#x27;inverse&#x27;: &#x27;directed&#x27; }] }
    *     ]
    * });
    * // Add a record to people and a record to movies
    * base.store(&#x27;Movies&#x27;).push({ title: &#x27;Coffee and Cigarettes&#x27;, director: { name: &#x27;Jim Jarmusch&#x27; } });
    * // delete the join between the added records
    * base.store(&#x27;People&#x27;)[0].$delJoin(&#x27;directed&#x27;, base.store(&#x27;Movies&#x27;)[0]);
    * base.close();
    */
 exports.Record.prototype.$delJoin = function (joinName, joinRecord, joinFrequency) { return Object.create(require(&#x27;qminer&#x27;).Record.prototype); }
/**
    * Creates a JSON version of the record.
    * @param {Boolean} [joinRecords=false] - Include joined records (only IDs).
    * @param {Boolean} [joinRecordFields=false] - Expand joined record fields.
    * @param {Boolean} [sysFields=true] - If set to true system fields, like $id, will be included.
    * @returns {Object} The JSON version of the record.
    *
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a new base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;Musicians&quot;,
    *        fields: [
    *            { name: &quot;Name&quot;, type: &quot;string&quot;, primary: true },
    *            { name: &quot;DateOfBirth&quot;, type: &quot;datetime&quot; },
    *            { name: &quot;GreatestHits&quot;, type: &quot;string_v&quot; }
    *        ]
    *    }]
    * });
    * // create some records
    * base.store(&quot;Musicians&quot;).push({ Name: &quot;Jimmy Page&quot;, DateOfBirth:  &quot;1944-01-09T00:00:00&quot;, GreatestHits: [&quot;Stairway to Heaven&quot;, &quot;Whole Lotta Love&quot;] });
    * base.store(&quot;Musicians&quot;).push({ Name: &quot;Beyonce&quot;, DateOfBirth: &quot;1981-09-04T00:00:00&quot;, GreatestHits: [&quot;Single Ladies (Put a Ring on It)&quot;] });
    * // get a JSON version of the &quot;Beyonce&quot; record
    * // The JSON object for this example si:
    * // { &#x27;$id&#x27;: 1, Name: &#x27;Beyonce&#x27;, ActiveSince: &#x27;1981-09-04T00:00:00&#x27;, GreatestHits: [&#x27;Single Ladies (Put a Ring on It)&#x27;] }
    * var json = base.store(&quot;Musicians&quot;).recordByName(&quot;Beyonce&quot;).toJSON();
    * base.close();
    */
 exports.Record.prototype.toJSON = function () { return {}; };
/**
    * Returns the id of the record. Type &#x60;number&#x60;.
    */
 exports.Record.prototype.$id = 0;
/**
    * Returns the name of the record. Type &#x60;string&#x60;.
    */
 exports.Record.prototype.$name = &quot;&quot;;
/**
    * Returns the frequency of the record. Type &#x60;number&#x60;.
    */
 exports.Record.prototype.$fq = 0;
/**
    * Returns the store the record belongs to. Type {@link module:qm.Store}.
    */
 exports.Record.prototype.store = Object.create(&#x27;qminer&#x27;).Store.prototype;
/**
 * Vector of records by value.
 * @class
 * @param {module:fs.FIn} [arg] - Load vector from input stream.
 * @classdesc Vector storing records defined by value. Vector can be serialized and
 * iterated over. For storing records by reference use {@link module:qm.RecordSet} or
 * {@link module:la.IntVector}.
 * @example
 * // import qm module
 * var qm = require(&#x27;qminer&#x27;);
 * // create a new base containing one store
 * var base = new qm.Base({
 *    mode: &quot;createClean&quot;,
 *    schema: [{
 *        name: &quot;Philosophers&quot;,
 *        fields: [
 *            { name: &quot;Name&quot;, type: &quot;string&quot; },
 *            { name: &quot;Era&quot;, type: &quot;string&quot; }
 *        ]
 *    }]
 * });
 * // Create record vector
 * var recordVector = new qm.RecordVector(base);
 * // Add some records to the vector
 * recordVector.push(base.store(&quot;Philosophers&quot;).newRecord({ Name: &quot;Plato&quot;, Era: &quot;Ancient philosophy&quot; }));
 * recordVector.push(base.store(&quot;Philosophers&quot;).newRecord({ Name: &quot;Immanuel Kant&quot;, Era: &quot;18th-century philosophy&quot; }));
 * recordVector.push(base.store(&quot;Philosophers&quot;).newRecord({ Name: &quot;Emmanuel Levinas&quot;, Era: &quot;20th-century philosophy&quot; }));
 * recordVector.push(base.store(&quot;Philosophers&quot;).newRecord({ Name: &quot;Rene Descartes&quot;, Era: &quot;17th-century philosophy&quot; }));
 * recordVector.push(base.store(&quot;Philosophers&quot;).newRecord({ Name: &quot;Confucius&quot;, Era: &quot;Ancient philosophy&quot; }));
 * // Iterate over all records
 * for (var i = 0; i &amp;lt; recordVector.length; i++) {
 *    var rec = recordVector[i];
 *    var tite = rec.Name + &quot; (&quot; + rec.Era + &quot;)&quot;;
 * }
 * base.close();
 */
 exports.RecordVector = function(arg) { return Object.create(require(&#x27;qminer&#x27;).qm.RecordVector.prototype) };
/**
     * Adds a new record to the vector.
     * @param {module:qm.Record} rec - The added record. The record must be provided by value.
     * @returns {number} The position of the added record in the vector.
     * @example
     * // import qm module
     * var qm = require(&#x27;qminer&#x27;);
     * // create a new base containing one store
     * var base = new qm.Base({
     *    mode: &quot;createClean&quot;,
     *    schema: [{
     *        name: &quot;Philosophers&quot;,
     *        fields: [
     *            { name: &quot;Name&quot;, type: &quot;string&quot; },
     *            { name: &quot;Era&quot;, type: &quot;string&quot; }
     *        ]
     *    }]
     * });
     * // Create record vector
     * var recordVector = new qm.RecordVector(base);
     * // Add some records to the vector
     * recordVector.push(base.store(&quot;Philosophers&quot;).newRecord({ Name: &quot;Plato&quot;, Era: &quot;Ancient philosophy&quot; }));
     * base.close();
     */
 exports.RecordVector.prototype.push = function (rec) {};
/**
     * Gives the number of records. Type &#x60;number&#x60;.
     */
 exports.RecordVector.prototype.length = 0;
/**
    * Gets the record with the given ID.
    * @param {number} recN - The index of the record
    * @returns {module:qm.Record} The record at &#x60;recN&#x60; position.
    * @ignore
    */
/**
     * Saves the vector into the output stream.
     * @param {module:fs.FOut} fout - Output stream.
     * @returns {module:fs.FOut} The output stream &#x60;fout&#x60;.
     * @example
     * // import qm module
     * var qm = require(&#x27;qminer&#x27;);
     * var fs = require(&#x27;qminer&#x27;).fs;
     * // create a new base containing one store
     * var base = new qm.Base({
     *    mode: &quot;createClean&quot;,
     *    schema: [{
     *        name: &quot;Philosophers&quot;,
     *        fields: [
     *            { name: &quot;Name&quot;, type: &quot;string&quot; },
     *            { name: &quot;Era&quot;, type: &quot;string&quot; }
     *        ]
     *    }]
     * });
     * // Create record vector
     * var recordVector = new qm.RecordVector(base);
     * // Add some records to the vector
     * recordVector.push(base.store(&quot;Philosophers&quot;).newRecord({ Name: &quot;Plato&quot;, Era: &quot;Ancient philosophy&quot; }));
     * // save to disk
     * var fout = fs.openWrite(&#x27;record_vector.bin&#x27;);
     * recordVector.save(fout).close();
     * // load into a new vector
     * var fin = fs.openRead(&#x27;record_vector.bin&#x27;);
     * var recordVector2 = new qm.RecordVector(base, fin);
     * base.close();
     */
 exports.RecordVector.prototype.save = function(fout) { return Object.create(require(&#x27;qminer&#x27;).RecordVector.prototype); };
/**
* Record Set is a set of records. &amp;lt;br&gt;
* &amp;lt;b&gt;Factory pattern&amp;lt;/b&gt;: this class cannot be construced using the new keyword. This class is constructed
* when calling a specific method or attribute, e.g. using {@link module:qm.Store#allRecords} to get all the records
* in the store as a record set.
* @class
*/
 exports.RecordSet = function () { return Object.create(require(&#x27;qminer&#x27;).qm.RecordSet.prototype); }
/**
    * Creates a new instance of the record set.
    * @returns {module:qm.RecordSet} A copy of the record set.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a new base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;Philosophers&quot;,
    *        fields: [
    *            { name: &quot;Name&quot;, type: &quot;string&quot; },
    *            { name: &quot;Era&quot;, type: &quot;string&quot; }
    *        ]
    *    }]
    * });
    * // put some records in the store
    * base.store(&quot;Philosophers&quot;).push({ Name: &quot;Plato&quot;, Era: &quot;Ancient philosophy&quot; });
    * base.store(&quot;Philosophers&quot;).push({ Name: &quot;Immanuel Kant&quot;, Era: &quot;18th-century philosophy&quot; });
    * base.store(&quot;Philosophers&quot;).push({ Name: &quot;Emmanuel Levinas&quot;, Era: &quot;20th-century philosophy&quot; });
    * base.store(&quot;Philosophers&quot;).push({ Name: &quot;Rene Descartes&quot;, Era: &quot;17th-century philosophy&quot; });
    * base.store(&quot;Philosophers&quot;).push({ Name: &quot;Confucius&quot;, Era: &quot;Ancient philosophy&quot; });
    * // create a record set out of the records in store
    * var recordSet = base.store(&quot;Philosophers&quot;).allRecords;
    * // clone the record set of the &quot;Philosophers&quot; store
    * var philosophers = recordSet.clone();
    * base.close();
    */
 exports.RecordSet.prototype.clone = function () { return Object.create(require(qminer).RecordSet.prototype); };
/**
    * Creates a new record set out of the join attribute of records.
    * @param {string} joinName - The name of the join attribute.
    * @param {number} [sampleSize] - The number of records to be used for construction of the record set.
    * @returns {module:qm.RecordSet} The record set containing the join records.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a new base containing two stores, with join attributes
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [
    *    {
    *        name: &quot;Musicians&quot;,
    *        fields: [
    *            { name: &quot;Name&quot;, type: &quot;string&quot; },
    *            { name: &quot;Instruments&quot;, type: &quot;string_v&quot; }
    *        ],
    *        joins: [
    *            { name: &quot;PlaysIn&quot;, type: &quot;index&quot;, store: &quot;Bands&quot;, inverse: &quot;Members&quot; }
    *        ]
    *    },
    *    {
    *        name: &quot;Bands&quot;,
    *        fields: [
    *            { name: &quot;Name&quot;, type: &quot;string&quot; },
    *            { name: &quot;Genre&quot;, type: &quot;string&quot; }
    *        ],
    *        joins: [
    *            { name: &quot;Members&quot;, type: &quot;index&quot;, store: &quot;Musicians&quot;, inverse: &quot;PlaysIn&quot; }
    *        ]
    *    }]
    * });
    * // add some new records to both stores
    * base.store(&quot;Musicians&quot;).push({ Name: &quot;Robert Plant&quot;, Instruments: [&quot;Vocals&quot;], PlaysIn: [{Name: &quot;Led Zeppelin&quot;, &quot;Genre&quot;: &quot;Rock&quot; }] });
    * base.store(&quot;Musicians&quot;).push({ Name: &quot;Jimmy Page&quot;, Instruments: [&quot;Guitar&quot;], PlaysIn: [{Name: &quot;Led Zeppelin&quot;, &quot;Genre&quot;: &quot;Rock&quot; }] });
    * base.store(&quot;Bands&quot;).push({ Name: &quot;The White Stripes&quot;, Genre: &quot;Rock&quot; });
    * // create a record set containing the musicians, that are members of some bend
    * // returns a record set containing the records of &quot;Robert Plant&quot; and &quot;Jimmy Page&quot;
    * var ledZeppelin = base.store(&quot;Bands&quot;).allRecords.join(&quot;Members&quot;);
    * // create a record set containing the first musician, that is a member of some band
    * // returns a record set containing only one record, which is &quot;Robert Plant&quot; or &quot;Jimmy Page&quot;
    * var ledMember = base.store(&quot;Bands&quot;).allRecords.join(&quot;Members&quot;, 1);
    * base.close();
    */
 exports.RecordSet.prototype.join = function (joinName, sampleSize) { return Object.create(require(&#x27;qminer&#x27;).RecordSet.prototype); };
/**
    * Aggr // TODO
    * @param {Object} [aggrQueryJSON]
    * @returns {Object} Aggregate
    * @ignore
    */
 exports.RecordSet.prototype.aggr = function (aggrQueryJSON) {};
/**
    * Truncates the first records.
    * @param {number} limit_num - How many records to truncate.
    * @param {number} [offset_num] - Where to start to truncate.
    * @returns {module:qm.RecordSet} Self.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a new base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;Philosophers&quot;,
    *        fields: [
    *            { name: &quot;Name&quot;, type: &quot;string&quot; },
    *            { name: &quot;Era&quot;, type: &quot;string&quot; }
    *        ]
    *    }]
    * });
    * // put some records in the store
    * base.store(&quot;Philosophers&quot;).push({ Name: &quot;Plato&quot;, Era: &quot;Ancient philosophy&quot; });
    * base.store(&quot;Philosophers&quot;).push({ Name: &quot;Immanuel Kant&quot;, Era: &quot;18th-century philosophy&quot; });
    * base.store(&quot;Philosophers&quot;).push({ Name: &quot;Emmanuel Levinas&quot;, Era: &quot;20th-century philosophy&quot; });
    * base.store(&quot;Philosophers&quot;).push({ Name: &quot;Rene Descartes&quot;, Era: &quot;17th-century philosophy&quot; });
    * base.store(&quot;Philosophers&quot;).push({ Name: &quot;Confucius&quot;, Era: &quot;Ancient philosophy&quot; });
    * // create two identical record sets of the &quot;Philosophers&quot; store
    * var recordSet1 = base.store(&quot;Philosophers&quot;).allRecords;
    * var recordSet2 = base.store(&quot;Philosophers&quot;).allRecords;
    * // truncate the first 3 records in recordSet1
    * recordSet1.trunc(3); // return self, containing only the first 3 records (&quot;Plato&quot;, &quot;Immanuel Kant&quot;, &quot;Emmanuel Levinas&quot;)
    * // truncate the first 2 records in recordSet2, starting with &quot;Emmanuel Levinas&quot;
    * recordSet2.trunc(2, 2); // returns self, containing only the 2 records (&quot;Emmanuel Levinas&quot;, &quot;Rene Descartes&quot;)
    * base.close();
    */
 exports.RecordSet.prototype.trunc = function (limit_num, offset_num) { return Object.create(require(&#x27;qminer&#x27;).RecordSet.prototype); };
/**
    * Creates a random sample of records of the record set.
    * @param {number} num - The number of records in the sample.
    * @returns {module:qm.RecordSet} A record set containing the sample records.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a new base with one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;Movies&quot;,
    *        fields: [
    *            { name: &quot;Title&quot;, type: &quot;string&quot; },
    *            { name: &quot;Length&quot;, type: &quot;int&quot; },
    *            { name: &quot;Director&quot;, type: &quot;string&quot; }
    *        ]
    *    }]
    * });
    * // put some records in the store
    * base.store(&quot;Movies&quot;).push({ Title: &quot;The Nightmare Before Christmas&quot;, Length: 76, Director: &quot;Henry Selick&quot; });
    * base.store(&quot;Movies&quot;).push({ Title: &quot;Jurassic Part&quot;, Length: 127, Director: &quot;Steven Spielberg&quot; });
    * base.store(&quot;Movies&quot;).push({ Title: &quot;The Avengers&quot;, Length: 143, Director: &quot;Joss Whedon&quot; });
    * base.store(&quot;Movies&quot;).push({ Title: &quot;The Clockwork Orange&quot;, Length: 136, Director: &quot;Stanley Kubrick&quot; });
    * base.store(&quot;Movies&quot;).push({ Title: &quot;Full Metal Jacket&quot;, Length: 116, Director: &quot;Stanely Kubrick&quot; });
    * // create a sample record set of containing 3 records from the &quot;Movies&quot; store
    * var sample = base.store(&quot;Movies&quot;).allRecords.sample(3);
    * base.close();
    */
 exports.RecordSet.prototype.sample = function (num) { return Object.create(require(&#x27;qminer&#x27;).RecordSet.prototype); };
/**
    * Shuffles the order of records in the record set.
    * @param {number} [seed] - Integer.
    * @returns {module:qm.RecordSet} Self. The records in the record set are in a different order.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a new base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;WeatherForcast&quot;,
    *        fields: [
    *            { name: &quot;Weather&quot;, type: &quot;string&quot; },
    *            { name: &quot;Date&quot;, type: &quot;datetime&quot; },
    *            { name: &quot;TemperatureDegrees&quot;, type: &quot;int&quot; }
    *        ]
    *    }]
    * });
    * // put some records in the &quot;WeatherForecast&quot; store
    * base.store(&quot;WeatherForcast&quot;).push({ Weather: &quot;Partly Cloudy&quot;, Date: &quot;2015-05-27T11:00:00&quot;, TemperatureDegrees: 19 });
    * base.store(&quot;WeatherForcast&quot;).push({ Weather: &quot;Partly Cloudy&quot;, Date: &quot;2015-05-28T11:00:00&quot;, TemperatureDegrees: 22 });
    * base.store(&quot;WeatherForcast&quot;).push({ Weather: &quot;Mostly Cloudy&quot;, Date: &quot;2015-05-29T11:00:00&quot;, TemperatureDegrees: 25 });
    * base.store(&quot;WeatherForcast&quot;).push({ Weather: &quot;Mostly Cloudy&quot;, Date: &quot;2015-05-30T11:00:00&quot;, TemperatureDegrees: 25 });
    * base.store(&quot;WeatherForcast&quot;).push({ Weather: &quot;Scattered Showers&quot;, Date: &quot;2015-05-31T11:00:00&quot;, TemperatureDegrees: 24 });
    * base.store(&quot;WeatherForcast&quot;).push({ Weather: &quot;Mostly Cloudy&quot;, Date: &quot;2015-06-01T11:00:00&quot;, TemperatureDegrees: 27 });
    * // get the record set containing the records from the &quot;WeatherForcast&quot; store
    * var recordSet = base.store(&quot;WeatherForcast&quot;).allRecords;
    * // shuffle the records in the newly created record set. Use the number 100 as the seed for the shuffle
    * recordSet.shuffle(100); // returns self, the records in the record set are shuffled
    * base.close();
    */
 exports.RecordSet.prototype.shuffle = function (seed) { return Object.create(require(&#x27;qminer&#x27;).RecordSet.prototype); };
/**
    * It reverses the record order.
    * @returns {module:qm.RecordSet} Self. Records are in reversed order.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a new base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;WeatherForcast&quot;,
    *        fields: [
    *            { name: &quot;Weather&quot;, type: &quot;string&quot; },
    *            { name: &quot;Date&quot;, type: &quot;datetime&quot; },
    *            { name: &quot;TemperatureDegrees&quot;, type: &quot;int&quot; },
    *        ]
    *    }]
    * });
    * // put some records in the &quot;WeatherForecast&quot; store
    * base.store(&quot;WeatherForcast&quot;).push({ Weather: &quot;Partly Cloudy&quot;, Date: &quot;2015-05-27T11:00:00&quot;, TemperatureDegrees: 19 });
    * base.store(&quot;WeatherForcast&quot;).push({ Weather: &quot;Partly Cloudy&quot;, Date: &quot;2015-05-28T11:00:00&quot;, TemperatureDegrees: 22 });
    * base.store(&quot;WeatherForcast&quot;).push({ Weather: &quot;Mostly Cloudy&quot;, Date: &quot;2015-05-29T11:00:00&quot;, TemperatureDegrees: 25 });
    * base.store(&quot;WeatherForcast&quot;).push({ Weather: &quot;Mostly Cloudy&quot;, Date: &quot;2015-05-30T11:00:00&quot;, TemperatureDegrees: 25 });
    * base.store(&quot;WeatherForcast&quot;).push({ Weather: &quot;Scattered Showers&quot;, Date: &quot;2015-05-31T11:00:00&quot;, TemperatureDegrees: 24 });
    * base.store(&quot;WeatherForcast&quot;).push({ Weather: &quot;Mostly Cloudy&quot;, Date: &quot;2015-06-01T11:00:00&quot;, TemperatureDegrees: 27 });
    * // get the record set containing the records from the &quot;WeatherForcast&quot; store
    * var recordSet = base.store(&quot;WeatherForcast&quot;).allRecords;
    * // reverse the record order in the record set
    * recordSet.reverse(); // returns self, the records in the record set are in the reverse order
    * base.close();
    */
 exports.RecordSet.prototype.reverse = function () { return Object.create(require(&#x27;qminer&#x27;).RecordSet.prototype); };
/**
    * Sorts the records according to record ID.
    * @param {number} [asc=-1] - If &#x60;asc&#x60; &gt; 0, it sorts in ascending order. Otherwise, it sorts in descending order.
    * @returns {module:qm.RecordSet} Self. Records are sorted according to record ID and &#x60;asc&#x60;.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a new base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;Tea&quot;,
    *        fields: [
    *            { name: &quot;Name&quot;, type: &quot;string&quot; },
    *            { name: &quot;Type&quot;, type: &quot;string&quot;},
    *            { name: &quot;Origin&quot;, type: &quot;string&quot;, &quot;null&quot;: true  }
    *        ]
    *    }]
    * });
    * // put some records in the &quot;Tea&quot; store
    * base.store(&quot;Tea&quot;).push({ Name: &quot;Tanyang Gongfu&quot;, Type: &quot;Black&quot;, Origin: &quot;Tanyang&quot; });
    * base.store(&quot;Tea&quot;).push({ Name: &quot;Rou Gui&quot;, Type: &quot;White&quot; });
    * base.store(&quot;Tea&quot;).push({ Name: &quot;Tieluohan Tea&quot;, Type: &quot;Wuyi&quot;, Origin: &quot;Northern Fujian&quot; });
    * base.store(&quot;Tea&quot;).push({ Name: &quot;Red Robe&quot;, Type: &quot;Oolong&quot;, Origin: &quot;Wuyi Mountains&quot; });
    * // get the records of the &quot;Tea&quot; store as a record set
    * var recordSet = base.store(&quot;Tea&quot;).allRecords;
    * // sort the records in the record set by their id in descending order
    * recordSet.sortById(); // returns self, the records are sorted in descending order (default)
    * // sort the records in the record set by their id in ascending order
    * recordSet.sortById(1); // returns self, the records are sorted in ascending order
    * base.close();
    */
 exports.RecordSet.prototype.sortById = function (asc) { return Object.create(require(&#x27;qminer&#x27;).RecordSet.prototype); };
/**
    * Sorts the records according to their weight.
    * @param {number} [asc=1] - If &#x60;asc&#x60; &gt; 0, it sorts in ascending order. Otherwise, it sorts in descending order.
    * @returns {module:qm.RecordSet} Self. Records are sorted according to record weight and &#x60;asc&#x60;.
    */
 exports.RecordSet.prototype.sortByFq = function (asc) { return Object.create(require(&#x27;qminer&#x27;).RecordSet.prototype); };
/**
    * Sorts the records according to a specific record field.
    * @param {string} fieldName - The field by which the sort will work.
    * @param {number} [arc=-1] - if &#x60;asc&#x60; &gt; 0, it sorts in ascending order. Otherwise, it sorts in descending order.
    * @returns {module:qm.RecordSet} Self. Records are sorted according to &#x60;fieldName&#x60; and &#x60;arc&#x60;.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a new base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;TVSeries&quot;,
    *        fields: [
    *            { name: &quot;Title&quot;, type: &quot;string&quot;, primary: true },
    *            { name: &quot;NumberOfEpisodes&quot;, type: &quot;int&quot; }
    *        ]
    *    }]
    * });
    * // add some records in the store
    * base.store(&quot;TVSeries&quot;).push({ Title: &quot;Archer&quot;, NumberOfEpisodes: 75 });
    * base.store(&quot;TVSeries&quot;).push({ Title: &quot;The Simpsons&quot;, NumberOfEpisodes: 574 });
    * base.store(&quot;TVSeries&quot;).push({ Title: &quot;New Girl&quot;, NumberOfEpisodes: 94 });
    * base.store(&quot;TVSeries&quot;).push({ Title: &quot;Rick and Morty&quot;, NumberOfEpisodes: 11 });
    * base.store(&quot;TVSeries&quot;).push({ Title: &quot;Game of Thrones&quot;, NumberOfEpisodes: 47 });
    * // get the records of the &quot;TVSeries&quot; store as a record set
    * var recordSet = base.store(&quot;TVSeries&quot;).allRecords;
    * // sort the records by their &quot;Title&quot; field in ascending order
    * recordSet.sortByField(&quot;Title&quot;, true); // returns self, record are sorted by their &quot;Title&quot;
    * base.close();
    */
 exports.RecordSet.prototype.sortByField = function (fieldName, asc) { return Object.create(require(&#x27;qminer&#x27;).RecordSet.prototype); };
/**
    * Sorts the records according to the given callback function.
    * @param {function} callback - The function used to sort the records. It takes two parameters:
    * &amp;lt;br&gt;1. &#x60;rec&#x60; - The first record.
    * &amp;lt;br&gt;2. &#x60;rec2&#x60; - The second record.
    * &amp;lt;br&gt;The function return type &#x60;boolean&#x60;.
    * @returns {module:qm.RecordSet} Self. The records are sorted according to the &#x60;callback&#x60; function.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a new base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;TVSeries&quot;,
    *        fields: [
    *            { name: &quot;Title&quot;, type: &quot;string&quot;, primary: true },
    *            { name: &quot;NumberOfEpisodes&quot;, type: &quot;int&quot; }
    *        ]
    *    }]
    * });
    * // add some records in the store
    * base.store(&quot;TVSeries&quot;).push({ Title: &quot;Archer&quot;, NumberOfEpisodes: 75 });
    * base.store(&quot;TVSeries&quot;).push({ Title: &quot;The Simpsons&quot;, NumberOfEpisodes: 574 });
    * base.store(&quot;TVSeries&quot;).push({ Title: &quot;New Girl&quot;, NumberOfEpisodes: 94 });
    * base.store(&quot;TVSeries&quot;).push({ Title: &quot;Rick and Morty&quot;, NumberOfEpisodes: 11 });
    * base.store(&quot;TVSeries&quot;).push({ Title: &quot;Game of Thrones&quot;, NumberOfEpisodes: 47 });
    * // get the records of the &quot;TVSeries&quot; store as a record set
    * var recordSet = base.store(&quot;TVSeries&quot;).allRecords;
    * // sort the records by their number of episodes
    * recordSet.sort(function (rec, rec2) { return rec.NumberOfEpisodes &amp;lt; rec2.NumberOfEpisodes; }); // returns self, records are sorted by the number of episodes
    * base.close();
    */
 exports.RecordSet.prototype.sort = function (callback) { return Object.create(require(&#x27;qminer&#x27;).RecordSet.prototype); };
/**
    * Keeps only records with ids between or equal two values.
    * @param {number} [minId] - The minimum id.
    * @param {number} [maxId] - The maximum id.
    * @returns {module:qm.RecordSet} Self.
    * &amp;lt;br&gt;1. Contains only the records of the original with IDs between &#x60;minId&#x60; and &#x60;maxId&#x60;, if parameters are given.
    * &amp;lt;br&gt;2. Contains all the records of the original, if no parameter is given.
    * @example
    * // import qm require
    * var qm = require(&#x27;qminer&#x27;);
    * // create a new base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;FrankSinatraGreatestHits&quot;,
    *        fields: [
    *            { name: &quot;Title&quot;, type: &quot;string&quot; },
    *            { name: &quot;Length&quot;, type: &quot;int&quot; }
    *        ]
    *    }]
    * });
    * // put some records in the &quot;FrankSinatraGreatesHits&quot; store
    * base.store(&quot;FrankSinatraGreatestHits&quot;).push({ Title: &quot;Strangers in the Night&quot;, Length: 145 });
    * base.store(&quot;FrankSinatraGreatestHits&quot;).push({ Title: &quot;Summer Wind&quot;, Length: 173 });
    * base.store(&quot;FrankSinatraGreatestHits&quot;).push({ Title: &quot;It Was a Very Good Year&quot;, Length: 265 });
    * base.store(&quot;FrankSinatraGreatestHits&quot;).push({ Title: &quot;Somewhere in Your Heart&quot;, Length: 146 });
    * base.store(&quot;FrankSinatraGreatestHits&quot;).push({ Title: &quot;Forget Domani&quot;, Length: 156 });
    * base.store(&quot;FrankSinatraGreatestHits&quot;).push({ Title: &quot;Somethin&#x27; Stupid&quot;, Length: 155 });
    * base.store(&quot;FrankSinatraGreatestHits&quot;).push({ Title: &quot;This Town&quot;, Length: 186 });
    * // get the records of the store as a record set
    * var recordSet = base.store(&quot;FrankSinatraGreatestHits&quot;).allRecords;
    * // from the record set keep the records with indeces between or equal 2 and 5
    * recordSet.filterById(2, 5);
    * base.close();
    */
 exports.RecordSet.prototype.filterById = function (minId, maxId) { return Object.create(require(&#x27;qminer&#x27;).RecordSet.prototype); };
/**
    * Keeps only the records with weight between two values.
    * @param {number} [minFq] - The minimum value.
    * @param {number} [maxFq] - The maximum value.
    * @returns {module:qm.RecordSet} Self.
    * &amp;lt;br&gt;1. Contains only the records of the original with weights between &#x60;minFq&#x60; and &#x60;maxFq&#x60;, if parameters are given.
    * &amp;lt;br&gt;2. Contains all the records of the original, if no parameter is given.
    */
 exports.RecordSet.prototype.filterByFq = function (minFq, maxFq) { return Object.create(require(&#x27;qminer&#x27;).RecordSet.prototype); };
/**
    * Keeps only the records with a specific value of some field.
    * @param {string} fieldName - The field by which the records will be filtered.
    * @param {(string | number)} minVal -
    * &amp;lt;br&gt;1. If the field type is a &#x60;string&#x60;, the exact string to compare. Type &#x60;number&#x60;.
    * &amp;lt;br&gt;2. If the field type is a &#x60;number&#x60;, the minimal value for comparison. Type &#x60;number&#x60;.
    * &amp;lt;br&gt;3. TODO Time field
    * @param {number} maxVal - Only in combination with &#x60;minVal&#x60; for non-string fields. The maximal value for comparison.
    * @returns {module:qm.RecordSet} Self.
    * &amp;lt;br&gt;1. If the &#x60;fieldName&#x60; field type is &#x60;number&#x60;, contains only the records with the &#x60;fieldName&#x60; value between &#x60;minVal&#x60; and &#x60;maxVal&#x60;.
    * &amp;lt;br&gt;2. If the &#x60;fieldName&#x60; field type is &#x60;string&#x60;, contains only the records with &#x60;fieldName&#x60; equal to &#x60;minVal&#x60;.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a new base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;WeatherForcast&quot;,
    *        fields: [
    *            { name: &quot;Weather&quot;, type: &quot;string&quot; },
    *            { name: &quot;Date&quot;, type: &quot;datetime&quot; },
    *            { name: &quot;TemperatureDegrees&quot;, type: &quot;int&quot; },
    *        ]
    *    }]
    * });
    * // put some records in the &quot;WeatherForecast&quot; store
    * base.store(&quot;WeatherForcast&quot;).push({ Weather: &quot;Partly Cloudy&quot;, Date: &quot;2015-05-27T11:00:00&quot;, TemperatureDegrees: 19 });
    * base.store(&quot;WeatherForcast&quot;).push({ Weather: &quot;Partly Cloudy&quot;, Date: &quot;2015-05-28T11:00:00&quot;, TemperatureDegrees: 22 });
    * base.store(&quot;WeatherForcast&quot;).push({ Weather: &quot;Mostly Cloudy&quot;, Date: &quot;2015-05-29T11:00:00&quot;, TemperatureDegrees: 25 });
    * base.store(&quot;WeatherForcast&quot;).push({ Weather: &quot;Mostly Cloudy&quot;, Date: &quot;2015-05-30T11:00:00&quot;, TemperatureDegrees: 25 });
    * base.store(&quot;WeatherForcast&quot;).push({ Weather: &quot;Scattered Showers&quot;, Date: &quot;2015-05-31T11:00:00&quot;, TemperatureDegrees: 24 });
    * base.store(&quot;WeatherForcast&quot;).push({ Weather: &quot;Mostly Cloudy&quot;, Date: &quot;2015-06-01T11:00:00&quot;, TemperatureDegrees: 27 });
    * // get the record set containing the records from the &quot;WeatherForcast&quot; store
    * var recordSet = base.store(&quot;WeatherForcast&quot;).allRecords;
    * // filter only the records, where the weather is Mostly Cloudy
    * recordSet.filterByField(&quot;Weather&quot;, &quot;Mostly Cloudy&quot;); // returns self, containing only the records, where the weather is &quot;Mostly Cloudy&quot;
    * base.close();
    */
 exports.RecordSet.prototype.filterByField = function (fieldName, minVal, maxVal) { return Object.create(require(&#x27;qminer&#x27;).RecordSet.prototype); };
/**
    * Keeps only the records that pass the callback function.
    * @param {function} callback - The filter function. It takes one parameter:
    * &amp;lt;br&gt;1. &#x60;rec&#x60; - The record in the record set. Type {@link module:qm.Record}.
    * &amp;lt;br&gt; Returns a &#x60;boolean&#x60; value.
    * @returns {module:qm.RecordSet} Self. Contains only the records that pass the callback function.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a new base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;ArcheryChampionship&quot;,
    *        fields: [
    *            { name: &quot;Name&quot;, type: &quot;string&quot; },
    *            { name: &quot;ScorePerRound&quot;, type: &quot;float_v&quot; }
    *        ]
    *    }]
    * });
    * // set new records in the store
    * base.store(&quot;ArcheryChampionship&quot;).push({ Name: &quot;Robin Hood&quot;, ScorePerRound: [50, 48, 48] });
    * base.store(&quot;ArcheryChampionship&quot;).push({ Name: &quot;Oliver Queen&quot;, ScorePerRound: [44, 46, 44] });
    * base.store(&quot;ArcheryChampionship&quot;).push({ Name: &quot;Legolas&quot;, ScorePerRound: [50, 50, 48] });
    * // create a record set out of the records of the store
    * var recordSet = base.store(&quot;ArcheryChampionship&quot;).allRecords;
    * // filter the records: which archers have scored 48 points in the third round
    * recordSet.filter(function (rec) { return rec.ScorePerRound[2] == 48; }); // keeps only the records, where the score of the third round is equal 48
    * base.close();
    */
 exports.RecordSet.prototype.filter = function (callback) { return Object.create(require(&#x27;qminer&#x27;).RecordSet.prototype); };
/**
    * Splits the record set into smaller record sets.
    * @param {function} callback - The splitter function. It takes two parameters:
    * &amp;lt;br&gt;1. &#x60;rec&#x60; - The first record. Type {@link module:qm.Record}.
    * &amp;lt;br&gt;2. &#x60;rec2&#x60; - The second record. Type {@link module:qm.Record}.
    * &amp;lt;br&gt; Returns a &#x60;boolean&#x60; value.
    * @returns {Array.&amp;lt;module:qm.RecordSet&gt;} An array containing the smaller record sets. The records are split according the callback function.
    * @example
    * // import qm module
    * var qm = require(&quot;qminer&quot;);
    * // create a new base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;SocialGames&quot;,
    *        fields: [
    *            { name: &quot;Title&quot;, type: &quot;string&quot; },
    *            { name: &quot;Type&quot;, type: &quot;string&quot; },
    *            { name: &quot;MinPlayers&quot;, type: &quot;int&quot; },
    *            { name: &quot;MaxPlayers&quot;, type: &quot;int&quot; }
    *        ]
    *    }]
    * });
    * // set new records in the store
    * base.store(&quot;SocialGames&quot;).push({ Title: &quot;DungeonsAndDragons&quot;, Type: &quot;Role-Playing&quot;, MinPlayers: 5, MaxPlayers: 5 });
    * base.store(&quot;SocialGames&quot;).push({ Title: &quot;Dobble&quot;, Type: &quot;Card&quot;, MinPlayers: 2, MaxPlayers: 8 });
    * base.store(&quot;SocialGames&quot;).push({ Title: &quot;Settlers of Catan&quot;, Type: &quot;Board&quot;, MinPlayers: 3, MaxPlayers: 4 });
    * base.store(&quot;SocialGames&quot;).push({ Title: &quot;Munchkin&quot;, Type: &quot;Card&quot;, MinPlayers: 3, MaxPlayers: 6 });
    * // create a record set out of the records of the store
    * var recordSet = base.store(&quot;SocialGames&quot;).allRecords;
    * // sort the records by MinPlayers in ascending order
    * recordSet.sortByField(&quot;MinPlayers&quot;, true);
    * // split the record set by the minimum number of players
    * // returns an array containing three record sets: the first containing the &quot;DungeonsAndDragons&quot; record,
    * // the second containing the &quot;Settlers of Catan&quot; and &quot;Munchkin&quot; records and the third containing the
    * // &quot;Dobble&quot; record
    * var arr = recordSet.split(function (rec, rec2) { return rec.MinPlayers &amp;lt; rec2.MinPlayers; });
    * base.close();
    */
 exports.RecordSet.prototype.split = function (callback) {return [Object.create(require(&#x27;qminer&#x27;).RecordSet.prototype)]; };
/**
    * Deletes the records, that are also in the second record set.
    * @param {module:qm.RecordSet} rs - The second record set.
    * @returns {module:qm.RecordSet} Self. Contains only the records, that are not in &#x60;rs&#x60;.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a new base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;BookWriters&quot;,
    *        fields: [
    *            { name: &quot;Name&quot;, type: &quot;string&quot; },
    *            { name: &quot;Genre&quot;, type: &quot;string&quot; },
    *            { name: &quot;Books&quot;, type: &quot;string_v&quot; }
    *        ]
    *    }]
    * });
    * // set new records in the store
    * base.store(&quot;BookWriters&quot;).push({ Name: &quot;Terry Pratchett&quot;, Genre: &quot;Fantasy&quot;, Books: [&quot;The Colour of Magic&quot;, &quot;Going Postal&quot;, &quot;Mort&quot;, &quot;Guards! Guards!&quot;] });
    * base.store(&quot;BookWriters&quot;).push({ Name: &quot;Douglas Adams&quot;, Genre: &quot;Sci-fi&quot;, Books: [&quot;The Hitchhiker&#x27;s Guide to the Galaxy&quot;, &quot;So Long, and Thanks for All the Fish&quot;] });
    * base.store(&quot;BookWriters&quot;).push({ Name: &quot;Fyodor Dostoyevsky&quot;, Genre: &quot;Drama&quot;, Books: [&quot;Crime and Punishment&quot;, &quot;Demons&quot;] });
    * base.store(&quot;BookWriters&quot;).push({ Name: &quot;J.R.R. Tolkien&quot;, Genre: &quot;Fantasy&quot;, Books: [&quot;The Hobbit&quot;, &quot;The Two Towers&quot;, &quot;The Silmarillion&quot; ] });
    * base.store(&quot;BookWriters&quot;).push({ Name: &quot;George R.R. Martin&quot;, Genre: &quot;Fantasy&quot;, Books: [&quot;A Game of Thrones&quot;, &quot;A Feast of Crows&quot;] });
    * base.store(&quot;BookWriters&quot;).push({ Name: &quot;J. K. Rowling&quot;, Genre: &quot;Fantasy&quot;, Books: [&quot;Harry Potter and the Philosopher&#x27;s Stone&quot;] });
    * base.store(&quot;BookWriters&quot;).push({ Name: &quot;Ivan Cankar&quot;, Genre: &quot;Drama&quot;, Books: [&quot;On the Hill&quot;, &quot;The King of Betajnova&quot;, &quot;The Serfs&quot;] });
    * // create one record set containing all records of store
    * var recordSet = base.store(&quot;BookWriters&quot;).allRecords;
    * // create one record set containing the records with genre &quot;Fantasy&quot;
    * var fantasy = base.store(&quot;BookWriters&quot;).allRecords.filterByField(&quot;Genre&quot;, &quot;Fantasy&quot;);
    * // delete the records in recordSet, that are also in fantasy
    * recordSet.deleteRecords(fantasy); // returns self, containing only three records: &quot;Douglas Adams&quot;, &quot;Fyodor Dostoyevsky&quot; and &quot;Ivan Cankar&quot;
    * base.close();
    */
 exports.RecordSet.prototype.deleteRecords = function (rs) { return Object.create(require(&#x27;qminer&#x27;).RecordSet.prototype); };
/**
    * Returns the record set as a JSON.
    * @returns {Object} The record set as a JSON.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a new base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;Musicians&quot;,
    *        fields: [
    *            { name: &quot;Name&quot;, type: &quot;string&quot;, primary: true },
    *            { name: &quot;DateOfBirth&quot;, type: &quot;datetime&quot; },
    *            { name: &quot;GreatestHits&quot;, type: &quot;string_v&quot; }
    *        ]
    *    }]
    * });
    * // create some records
    * base.store(&quot;Musicians&quot;).push({ Name: &quot;Jimmy Page&quot;, DateOfBirth:  &quot;1944-01-09T00:00:00&quot;, GreatestHits: [&quot;Stairway to Heaven&quot;, &quot;Whole Lotta Love&quot;] });
    * base.store(&quot;Musicians&quot;).push({ Name: &quot;Beyonce&quot;, DateOfBirth: &quot;1981-09-04T00:00:00&quot;, GreatestHits: [&quot;Single Ladies (Put a Ring on It)&quot;] });
    * // create a record set out of the records in the &quot;Musicians&quot; store
    * var recordSet = base.store(&quot;Musicians&quot;).allRecords;
    * // create a JSON object out of the record set
    * var json = recordSet.toJSON();
    * base.close();
    */
 exports.RecordSet.prototype.toJSON = function () { return {}; };
/**
    * Executes a function on each record in record set.
    * @param {function} callback - Function to be executed. It takes two parameters:
    * &amp;lt;br&gt;1. &#x60;rec&#x60; - The current record. Type {@link module:qm.Record}.
    * &amp;lt;br&gt;2. &#x60;idx&#x60; - The index of the current record (&amp;lt;i&gt;optional&amp;lt;/i&gt;). Type &#x60;number&#x60;.
    * @returns {module:qm.RecordSet} Self.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a new base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;People&quot;,
    *        fields: [
    *            { name: &quot;Name&quot;, type: &quot;string&quot; },
    *            { name: &quot;Gender&quot;, type: &quot;string&quot; }
    *        ]
    *    }]
    * });
    * // put some records in the store
    * base.store(&quot;People&quot;).push({ Name: &quot;Eric Sugar&quot;, Gender: &quot;Male&quot; });
    * base.store(&quot;People&quot;).push({ Name: &quot;Jane Tokyo&quot;, Gender: &quot;Female&quot; });
    * base.store(&quot;People&quot;).push({ Name: &quot;Mister Tea&quot;, Gender: &quot;Male&quot; });
    * // create a record set out of the records of the store
    * var recordSet = base.store(&quot;People&quot;).allRecords;
    * // change the Name of all records into &quot;Anonymous&quot;
    * recordSet.each(function (rec) { rec.Name = &quot;Anonymous&quot;; }); // returns self, all record&#x27;s Name are &quot;Anonymous&quot;
    * base.close();
    */
 exports.RecordSet.prototype.each = function (callback) { return Object.create(require(&#x27;qminer&#x27;).RecordSet.prototype); }
/**
    * Creates an array of function outputs created from the records in record set.
    * @param {function} callback - Function that generates the array. It takes two parameters:
    * &amp;lt;br&gt;1. &#x60;rec&#x60; - The current record. Type {@link module:qm.Record}.
    * &amp;lt;br&gt;2. &#x60;idx&#x60; - The index of the current record (&amp;lt;i&gt;optional&amp;lt;/i&gt;). Type &#x60;number&#x60;.
    * @returns {Array&amp;lt;Object&gt;} The array created by the callback function.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a new base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;People&quot;,
    *        fields: [
    *            { name: &quot;Name&quot;, type: &quot;string&quot; },
    *            { name: &quot;Gender&quot;, type: &quot;string&quot; }
    *        ]
    *    }]
    * });
    * // put some records in the store
    * base.store(&quot;People&quot;).push({ Name: &quot;Eric Sugar&quot;, Gender: &quot;Male&quot; });
    * base.store(&quot;People&quot;).push({ Name: &quot;Jane Tokyo&quot;, Gender: &quot;Female&quot; });
    * base.store(&quot;People&quot;).push({ Name: &quot;Mister Tea&quot;, Gender: &quot;Male&quot; });
    * // create a record set out of the records of the store
    * var recordSet = base.store(&quot;People&quot;).allRecords;
    * // make an array of record Names
    * var arr = recordSet.map(function (rec) { return rec.Name; }); // returns an array: [&quot;Eric Sugar&quot;, &quot;Jane Tokyo&quot;, &quot;Mister Tea&quot;]
    * base.close();
    */
 exports.RecordSet.prototype.map = function (callback) { return [Object];  }
/**
    * Creates the set intersection of two record sets.
    * @param {module:qm.RecordSet} rs - The other record set.
    * @returns {module:qm.RecordSet} The intersection of the two record sets.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a new base with one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;Movies&quot;,
    *        fields: [
    *            { name: &quot;Title&quot;, type: &quot;string&quot; },
    *            { name: &quot;Length&quot;, type: &quot;int&quot; },
    *            { name: &quot;Director&quot;, type: &quot;string&quot; }
    *        ]
    *    }]
    * });
    * // put some records in the store
    * base.store(&quot;Movies&quot;).push({ Title: &quot;The Nightmare Before Christmas&quot;, Length: 76, Director: &quot;Henry Selick&quot; });
    * base.store(&quot;Movies&quot;).push({ Title: &quot;Jurassic Part&quot;, Length: 127, Director: &quot;Steven Spielberg&quot; });
    * base.store(&quot;Movies&quot;).push({ Title: &quot;The Avengers&quot;, Length: 143, Director: &quot;Joss Whedon&quot; });
    * base.store(&quot;Movies&quot;).push({ Title: &quot;The Clockwork Orange&quot;, Length: 136, Director: &quot;Stanley Kubrick&quot; });
    * base.store(&quot;Movies&quot;).push({ Title: &quot;Full Metal Jacket&quot;, Length: 116, Director: &quot;Stanely Kubrick&quot; });
    * // create a record set out of the records in store, where length of the movie is greater than 110
    * var greaterSet = base.store(&quot;Movies&quot;).allRecords.filterByField(&quot;Length&quot;, 110, 150);
    * // create a record set out of the records in store, where the length of the movie is lesser than 130
    * var lesserSet = base.store(&quot;Movies&quot;).allRecords.filterByField(&quot;Length&quot;, 0, 130);
    * // get the intersection of greaterSet and lesserSet
    * var intersection = greaterSet.setIntersect(lesserSet); // returns a record set, containing the movies with lengths between 110 and 130
    * base.close();
    */
 exports.RecordSet.prototype.setIntersect = function (rs) { return Object.create(require(&#x27;qminer&#x27;).RecordSet.prototype); };
/**
    * Creates the set union of two record sets.
    * @param {module:qm.RecordSet} rs - The second record set.
    * @returns {module:qm.RecordSet} The union of the two record sets.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;TVSeries&quot;,
    *        fields: [
    *            { name: &quot;Title&quot;, type: &quot;string&quot;, &quot;primary&quot;: true },
    *            { name: &quot;NumberOfEpisodes&quot;, type: &quot;int&quot; }
    *        ]
    *    }]
    * });
    * // add some records in the store
    * base.store(&quot;TVSeries&quot;).push({ Title: &quot;Archer&quot;, NumberOfEpisodes: 75 });
    * base.store(&quot;TVSeries&quot;).push({ Title: &quot;The Simpsons&quot;, NumberOfEpisodes: 574 });
    * base.store(&quot;TVSeries&quot;).push({ Title: &quot;New Girl&quot;, NumberOfEpisodes: 94 });
    * base.store(&quot;TVSeries&quot;).push({ Title: &quot;Rick and Morty&quot;, NumberOfEpisodes: 11 });
    * base.store(&quot;TVSeries&quot;).push({ Title: &quot;Game of Thrones&quot;, NumberOfEpisodes: 47 });
    * // create a record set out of the records in store, where the number of episodes is lesser than 47
    * var lesserSet = base.store(&quot;TVSeries&quot;).allRecords.filterByField(&quot;NumberOfEpisodes&quot;, 0, 47);
    * // create a record set out of the records in store, where the number of episodes is greater than 100
    * var greaterSet = base.store(&quot;TVSeries&quot;).allRecords.filterByField(&quot;NumberOfEpisodes&quot;, 100, 600);
    * // get the union of lesserSet and greaterSet
    * var union = lesserSet.setUnion(greaterSet); // returns a record set, which is the union of the two record sets
    * base.close();
    */
 exports.RecordSet.prototype.setUnion = function (rs) { return Object.create(require(&#x27;qminer&#x27;).RecordSet.prototype); };
/**
    * Creates the set difference between two record sets.
    * @param {module:qm.RecordSet} rs - The other record set.
    * @returns {module:qm.RecordSet} The difference between the two record sets.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a new base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;BookWriters&quot;,
    *        fields: [
    *            { name: &quot;Name&quot;, type: &quot;string&quot; },
    *            { name: &quot;Genre&quot;, type: &quot;string&quot; },
    *            { name: &quot;Books&quot;, type: &quot;string_v&quot; }
    *        ]
    *    }]
    * });
    * // set new records in the store
    * base.store(&quot;BookWriters&quot;).push({ Name: &quot;Terry Pratchett&quot;, Genre: &quot;Fantasy&quot;, Books: [&quot;The Colour of Magic&quot;, &quot;Going Postal&quot;, &quot;Mort&quot;, &quot;Guards! Guards!&quot;] });
    * base.store(&quot;BookWriters&quot;).push({ Name: &quot;Douglas Adams&quot;, Genre: &quot;Sci-fi&quot;, Books: [&quot;The Hitchhiker&#x27;s Guide to the Galaxy&quot;, &quot;So Long, and Thanks for All the Fish&quot;] });
    * base.store(&quot;BookWriters&quot;).push({ Name: &quot;Fyodor Dostoyevsky&quot;, Genre: &quot;Drama&quot;, Books: [&quot;Crime and Punishment&quot;, &quot;Demons&quot;] });
    * base.store(&quot;BookWriters&quot;).push({ Name: &quot;J.R.R. Tolkien&quot;, Genre: &quot;Fantasy&quot;, Books: [&quot;The Hobbit&quot;, &quot;The Two Towers&quot;, &quot;The Silmarillion&quot; ] });
    * base.store(&quot;BookWriters&quot;).push({ Name: &quot;George R.R. Martin&quot;, Genre: &quot;Fantasy&quot;, Books: [&quot;A Game of Thrones&quot;, &quot;A Feast of Crows&quot;] });
    * base.store(&quot;BookWriters&quot;).push({ Name: &quot;J. K. Rowling&quot;, Genre: &quot;Fantasy&quot;, Books: [&quot;Harry Potter and the Philosopher&#x27;s Stone&quot;] });
    * base.store(&quot;BookWriters&quot;).push({ Name: &quot;Ivan Cankar&quot;, Genre: &quot;Drama&quot;, Books: [&quot;On the Hill&quot;, &quot;The King of Betajnova&quot;, &quot;The Serfs&quot;] });
    * // create one record set containing all records of store
    * var recordSet = base.store(&quot;BookWriters&quot;).allRecords;
    * // create one record set containing the records with genre &quot;Fantasy&quot;
    * var fantasy = base.store(&quot;BookWriters&quot;).allRecords.filterByField(&quot;Genre&quot;, &quot;Fantasy&quot;);
    * // create a new record set containing the difference of recordSet and fantasy
    * var difference = recordSet.setDiff(fantasy); // returns a record set, containing the records of Douglas Adams, Fyodor Dostoyevsky and Ivan Cankar
    * base.close();
    */
 exports.RecordSet.prototype.setDiff = function (rs) { return Object.create(require(&#x27;qminer&#x27;).RecordSet.prototype); };
/**
    * Creates a vector containing the field values of records.
    * @param {string} fieldName - The field from which to take the values. It&#x27;s type must be one-dimensional, e.g.  &#x60;int&#x60;, &#x60;float&#x60;, &#x60;string&#x60;...
    * @returns {module:la.Vector} The vector containing the field values of records. The type it contains is dependant of the field type.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;TVSeries&quot;,
    *        fields: [
    *            { name: &quot;Title&quot;, type: &quot;string&quot;, &quot;primary&quot;: true },
    *            { name: &quot;NumberOfEpisodes&quot;, type: &quot;int&quot; }
    *        ]
    *    }]
    * });
    * // add some records in the store
    * base.store(&quot;TVSeries&quot;).push({ Title: &quot;Archer&quot;, NumberOfEpisodes: 75 });
    * base.store(&quot;TVSeries&quot;).push({ Title: &quot;The Simpsons&quot;, NumberOfEpisodes: 574 });
    * base.store(&quot;TVSeries&quot;).push({ Title: &quot;New Girl&quot;, NumberOfEpisodes: 94 });
    * base.store(&quot;TVSeries&quot;).push({ Title: &quot;Rick and Morty&quot;, NumberOfEpisodes: 11 });
    * base.store(&quot;TVSeries&quot;).push({ Title: &quot;Game of Thrones&quot;, NumberOfEpisodes: 47 });
    * // create a record set of the records of store
    * var recordSet = base.store(&quot;TVSeries&quot;).allRecords;
    * // create a vector containing the number of episodes for each series
    * // the vector will look like [75, 574, 94, 11, 47]
    * var vector = recordSet.getVector(&quot;NumberOfEpisodes&quot;);
    * base.close();
    */
 exports.RecordSet.prototype.getVector = function (fieldName) { return Object.create(require(&#x27;qminer&#x27;).la.Vector.prototype); };
/**
    * Creates a vector containing the field values of records.
    * @param {string} fieldName - The field from which to take the values. It&#x27;s type must be numeric, e.g. &#x60;int&#x60;, &#x60;float&#x60;, &#x60;float_v&#x60;, &#x60;num_sp_v&#x60;...
    * @returns {(module:la.Matrix|module:la.SparseMatrix)} The matrix containing the field values of records.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a new base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;ArcheryChampionship&quot;,
    *        fields: [
    *            { name: &quot;Name&quot;, type: &quot;string&quot; },
    *            { name: &quot;ScorePerRound&quot;, type: &quot;float_v&quot; }
    *        ]
    *    }]
    * });
    * // set new records in the store
    * base.store(&quot;ArcheryChampionship&quot;).push({ Name: &quot;Robin Hood&quot;, ScorePerRound: [50, 48, 48] });
    * base.store(&quot;ArcheryChampionship&quot;).push({ Name: &quot;Oliver Queen&quot;, ScorePerRound: [44, 46, 44] });
    * base.store(&quot;ArcheryChampionship&quot;).push({ Name: &quot;Legolas&quot;, ScorePerRound: [50, 50, 48] });
    * // create a record set of the records in store
    * var recordSet = base.store(&quot;ArcheryChampionship&quot;).allRecords;
    * // create a matrix from the &quot;ScorePerRound&quot; field
    * // the i-th column of the matrix is the data of the i-th record in record set
    * // the matrix will look like
    * // 50  44  50
    * // 48  46  50
    * // 48  44  48
    * var matrix = recordSet.getMatrix(&quot;ScorePerRound&quot;);
    * base.close();
    */
 exports.RecordSet.prototype.getMatrix = function (fieldName) { return Object.create(require(&#x27;qminer&#x27;).la.Matrix.prototype); };
/**
    * Returns the store, where the records in the record set are stored. Type {@link module:qm.Store}.
    */
 exports.RecordSet.prototype.store = Object.create(require(&#x27;qminer&#x27;).Store.prototype);
/**
    * Returns the number of records in record set. Type &#x60;number&#x60;.
    */
 exports.RecordSet.prototype.length = 0;
/**
    * Checks if the record set is empty. If the record set is empty, then it returns true. Otherwise, it returns false. Type &#x60;boolean&#x60;.
    */
 exports.RecordSet.prototype.empty = true;
/**
    * Checks if the record set is weighted. If the record set is weighted, then it returns true. Otherwise, it returns false. Type &#x60;boolean&#x60;.
    */
 exports.RecordSet.prototype.weighted = true;
/**
* Store Iterators allows you to iterate through the records in the store. &amp;lt;br&gt;
* &amp;lt;b&gt;Factory pattern&amp;lt;/b&gt;: this class cannot be construced using the new keyword. It is constructed by calling
* a specific method or attribute, e.g. calling {@link module:qm.Store#forwardIter} to construct the Iterator.
* @class
* @example
* // import qm module
* qm = require(&#x27;qminer&#x27;);
* // create a new base with a simple store
* var base = new qm.Base({ mode: &quot;createClean&quot; });
* base.createStore({
*     name: &quot;People&quot;,
*     fields: [
*         { name: &quot;Name&quot;, type: &quot;string&quot; },
*         { name: &quot;Gender&quot;, type: &quot;string&quot; }
*     ]
* });
* // add new records to the store
* base.store(&quot;People&quot;).push({ Name: &quot;Geronimo&quot;, Gender: &quot;Male&quot; });
* base.store(&quot;People&quot;).push({ Name: &quot;Pochahontas&quot;, Gender: &quot;Female&quot; });
* base.store(&quot;People&quot;).push({ Name: &quot;John Rolfe&quot;, Gender: &quot;Male&quot; });
* base.store(&quot;People&quot;).push({ Name: &quot;John Smith&quot;, Gender: &quot;Male&quot;});
* // factory based construction with forwardIter
* var iter = base.store(&quot;People&quot;).forwardIter;
* base.close();
*/
 exports.Iterator = function () { return Object.create(require(&#x27;qminer&#x27;).Iterator.prototype); };
/**
    * Moves to the next record.
    * @returns {boolean}
    * &amp;lt;br&gt;1. &#x60;True&#x60;, if the iteration successfully moves to the next record.
    * &amp;lt;br&gt;2. &#x60;False&#x60;, if there is no record left.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a new base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;TheWitcherSaga&quot;,
    *        fields: [
    *            { name: &quot;Title&quot;, type: &quot;string&quot; },
    *            { name: &quot;YearOfRelease&quot;, type: &quot;int&quot; },
    *            { name: &quot;EnglishEdition&quot;, type: &quot;bool&quot; }
    *        ]
    *    }]
    * });
    * // put some records in the store
    * base.store(&quot;TheWitcherSaga&quot;).push({ Title: &quot;Blood of Elves&quot;, YearOfRelease: 1994, EnglishEdition: true });
    * base.store(&quot;TheWitcherSaga&quot;).push({ Title: &quot;Time of Contempt&quot;, YearOfRelease: 1995, EnglishEdition: true });
    * base.store(&quot;TheWitcherSaga&quot;).push({ Title: &quot;Baptism of Fire&quot;, YearOfRelease: 1996, EnglishEdition: true });
    * base.store(&quot;TheWitcherSaga&quot;).push({ Title: &quot;The Swallow&#x27;s Tower&quot;, YearOfRelease: 1997, EnglishEdition: false });
    * base.store(&quot;TheWitcherSaga&quot;).push({ Title: &quot;Lady of the Lake&quot;, YearOfRelease: 1999, EnglishEdition: false });
    * base.store(&quot;TheWitcherSaga&quot;).push({ Title: &quot;Season of Storms&quot;, YearOfRelease: 2013, EnglishEdition: false });
    * // create an iterator for the store
    * var iter = base.store(&quot;TheWitcherSaga&quot;).forwardIter;
    * // go to the first record in the store
    * iter.next(); // returns true
    * base.close();
    */
 exports.Iterator.prototype.next = function () { return true; };
/**
    * Gives the store of the iterator. Type {@link module:qm.Store}.
    */
 exports.Iterator.prototype.store = Object.create(require(&#x27;qminer&#x27;).Store.prototype);
/**
    * Gives the current record. Type {@link module:qm.Record}.
    */
 exports.Iterator.prototype.record = Object.create(require(&#x27;qminer&#x27;).Record.prototype);
/**
* Feature extractor types. Used for constructing {@link module:qm.FeatureSpace} objects.
* @typedef {Object} FeatureExtractor
* @property {module:qm~FeatureExtractorConstant} constant - The constant type.
* @property {module:qm~FeatureExtractorRandom} random - The random type.
* @property {module:qm~FeatureExtractorNumeric} numeric - The numeric type.
* @property {module:qm~FeatureExtractorCategorical} categorical - The categorical type.
* @property {module:qm~FeatureExtractorMultinomial} multinomial - The multinomial type.
* @property {module:qm~FeatureExtractorText} text - The text type.
* @property {module:qm~FeatureExtractorJoin} join - The join type.
* @property {module:qm~FeatureExtractorPair} pair - The pair type.
* @property {module:qm~FeatureExtractorJsfunc} jsfunc - The jsfunc type.
* @property {module:qm~FeatureExtractorDateWindow} dateWindow - The date window type.
* @property {module:qm~FeatureExtractorSparseVector} sparseVector - The sparse vector type.
*
*/
/**
* @typedef {Object} FeatureExtractorConstant
* The feature extractor of type &#x60;&#x27;contant&#x27;&#x60;. Used for constructing {@link module:qm.FeatureSpace} objects.
* @property {string} type - The type of the extractor. &amp;lt;b&gt;Important&amp;lt;/b&gt;: It must be equal &#x60;&#x27;constant&#x27;&#x60;.
* @property {number} [const = 1.0] - A constant number.
* @property {string} source - The store name.
* @example
* var qm = require(&#x27;qminer&#x27;);
* // create a simple base, where each record contains only a persons name
* var base = new qm.Base({
*   mode: &#x27;createClean&#x27;,
*   schema: [{
*      name: &quot;Person&quot;,
*      fields: [{ name: &quot;Name&quot;, type: &quot;string&quot; }]
*   }]
* });
* // create a feature space containing the constant extractor, where the constant is equal 5
* var ftr = new qm.FeatureSpace(base, { type: &quot;constant&quot;, source: &quot;Person&quot;, const: 5 });
* base.close();
*/
/**
* @typedef {Object} FeatureExtractorRandom
* The feature extractor of type &#x60;&#x27;random&#x27;&#x60;. Used for constructing {@link module:qm.FeatureSpace} objects.
* @property {string} type - The type of the extractor. &amp;lt;b&gt;Important&amp;lt;/b&gt;: It must be equal &#x60;&#x27;random&#x27;&#x60;.
* @property {number} [seed = 0] - The seed number used to construct the random number.
* @property {string} source - The store name.
* @example
* var qm = require(&#x27;qminer&#x27;);
* // create a simple base, where each record contains only a persons name
* var base = new qm.Base({
*   mode: &#x27;createClean&#x27;,
*   schema: [{
*      name: &quot;Person&quot;,
*      fields: [{ name: &quot;Name&quot;, type: &quot;string&quot; }]
*   }]
* });
* // create a feature space containing the random extractor
* var ftr = new qm.FeatureSpace(base, { type: &quot;random&quot;, source: &quot;Person&quot; });
* base.close();
*/
/**
* @typedef {Object} FeatureExtractorNumeric
* The feature extractor of type &#x60;&#x27;numeric&#x27;&#x60;. Used for constructing {@link module:qm.FeatureSpace} objects.
* @property {string} type - The type of the extractor. &amp;lt;b&gt;Important&amp;lt;/b&gt;: It must be equal &#x60;&#x27;numeric&#x27;&#x60;.
* @property {string} [normalize = &#x27;none&#x27;] - Normalize values between 0.0 and 1.0 if set to &#x60;&#x27;scale&#x27;&#x60;. Standardize values to mean = 0 and sdiv = 1 if set to &#x60;&#x27;var&#x27;&#x60;.
* @property {number} [min] - The minimal value used to form the normalization.
* @property {number} [max] - The maximal value used to form the normalization.
* @property {string} field - The name of the field from which to take the value.
* @property {string} source - The store name.
* @example
* var qm = require(&#x27;qminer&#x27;);
* // create a simple base, where each record contains the student name and it&#x27;s grade
* var base = new qm.Base({
*    mode: &#x27;createClean&#x27;,
*    schema: [{
*       name: &quot;Class&quot;,
*       fields: [
*          { name: &quot;Name&quot;, type: &quot;string&quot; },
*          { name: &quot;Grade&quot;, type: &quot;int&quot; }
*       ]
*    }]
* });
* // create a feature space containing the numeric extractor, where the values are
* // normalized, the values are taken from the field &quot;Grade&quot;
* var ftr = new qm.FeatureSpace(base, { type: &quot;numeric&quot;, source: &quot;Class&quot;, normalize: &quot;scale&quot;, field: &quot;Grade&quot; });
* base.close();
*/
/**
* @typedef {Object} FeatureExtractorSparseVector
* The feature extractor of type &#x60;&#x27;num_sp_v&#x27;&#x60;. Used for constructing {@link module:qm.FeatureSpace} objects.
* @property {string} type - The type of the extractor. &amp;lt;b&gt;Important&amp;lt;/b&gt;: It must be equal &#x60;&#x27;num_sp_v&#x27;&#x60;.
* @property {number} [dimension = 0] - Dimensionality of sparse vectors.
* @property {boolean} [normalize = false] - Normalize vectors to L2 norm of 1.0.
* @property {string} field - The name of the field from which to take the value.
* @property {string} source - The store name.
* @example
* var qm = require(&#x27;qminer&#x27;);
* // create a simple base, where each record contains the student name and it&#x27;s grade
* var base = new qm.Base({
*    mode: &#x27;createClean&#x27;,
*    schema: [{
*       &quot;name&quot;: &quot;Class&quot;,
*       &quot;fields&quot;: [
*          { &quot;name&quot;: &quot;Name&quot;, &quot;type&quot;: &quot;string&quot; },
*          { &quot;name&quot;: &quot;Features&quot;, &quot;type&quot;: &quot;num_sp_v&quot; }
*       ]
*    }]
* });
* // create a feature space containing the numeric extractor, where the values are
* // normalized, the values are taken from the field &quot;Grade&quot;
* var ftr = new qm.FeatureSpace(base, { type: &quot;num_sp_v&quot;, source: &quot;Class&quot;, normalize: false, field: &quot;Features&quot; });
* base.close();
*/
/**
* @typedef {Object} FeatureExtractorCategorical
* The feature extractor of type &#x60;&#x27;categorical&#x27;&#x60;. Used for constructing {@link module:qm.FeatureSpace} objects.
* @property {string} type - The type of the extractor. &amp;lt;b&gt;Important&amp;lt;/b&gt;: It must be equal &#x60;&#x27;categorical&#x27;&#x60;.
* @property {Array.&amp;lt;Object&gt;} [values] - A fixed set of values, which form a fixed feature set. No dimensionality changes if new values are seen in the upgrades.
* @property {number} [hashDimension] - A hashing code to set the fixed dimensionality. All values are hashed and divided modulo hasDimension to get the corresponding dimension.
* @property {string} field - The name of the field form which to take the values.
* @property {string} source - The store name.
* @example
* var qm = require(&#x27;qminer&#x27;);
* // create a simple base, where each record contains the student name and it&#x27;s study group
* // here we know the student is part of only one study group
* var base = new qm.Base({
*    mode: &#x27;createClean&#x27;,
*    schema: [{
*       name: &quot;Class&quot;,
*       fields: [
*          { name: &quot;Name&quot;, type: &quot;string&quot; },
*          { name: &quot;StudyGroup&quot;, type: &quot;string&quot; }
*       ]
*    }]
* });
* // create a feature space containing the categorical extractor, where it&#x27;s values
* // are taken from the field &quot;StudyGroup&quot;: &quot;A&quot;, &quot;B&quot;, &quot;C&quot; and &quot;D&quot;
* var ftr = new qm.FeatureSpace(base, { type: &quot;categorical&quot;, source: &quot;Class&quot;, field: &quot;StudyGroup&quot; });
* base.close();
*/
/**
* @typedef {Object} FeatureExtractorMultinomial
* The feature extractor of type &#x60;&#x27;multinomial&#x27;&#x60;. Used for constructing {@link module:qm.FeatureSpace} objects.
* @property {string} type - The type of the extractor. &amp;lt;b&gt;Important&amp;lt;/b&gt;: It must be equal &#x60;&#x27;multinomial&#x27;&#x60;.
* @property {boolean} [normalize = &#x27;false&#x27;] - Normalize the resulting vector of the extractor to have L2 norm 1.0.
* @property {string} [transform] - Transformation to apply to each dimension of the feature vector.
* &amp;lt;br&gt; Transformation options are:
* &amp;lt;br&gt; - &#x27;log&#x27; - Compute a logarithm of the frequencies using the following formula: log(1+x)
* &amp;lt;br&gt; - &#x27;binary&#x27; - Do not compute frequencies, but only a binary indicator whether the category appears
* @property {Array.&amp;lt;Object&gt;} [values] - A fixed set of values, which form a fixed feature set, no dimensionality changes if new values are seen in the updates. Cannot be used the same time as datetime.
* @property {number} [hashDimension] - A hashing code to set the fixed dimensionality. All values are hashed and divided modulo hashDimension to get the corresponding dimension.
* @property {Object} [datetime = false] - Same as &#x60;&#x27;values&#x27;&#x60;, only with predefined values which are extracted from date and time (&#x60;month&#x60;, &#x60;day of month&#x60;, &#x60;day of week&#x60;, &#x60;time of day&#x60;, &#x60;hour&#x60;).
* &amp;lt;br&gt; This fixes the dimensionality of feature extractor at the start, making it not dimension as new dates are seen. Cannot be used the same time as values.
* @property {(string|Array.&amp;lt;String&gt;)} field - The name of the field from which to take the key value.
* @property {(string|Array.&amp;lt;String&gt;)} [valueField] - The name of the field from which to take the numeric value.
* &amp;lt;br&gt; Defaults to 1.0 for non-zero elements in the vector.
* @property {string} source - The store name.
* @example
* var qm = require(&#x27;qminer&#x27;);
* // create a simple base, where each record contains the student name and an array of study groups
* // here we know a student can be part of multiple study groups
* var base = new qm.Base({
*    mode: &#x27;createClean&#x27;,
*    schema: [{
*       name: &quot;Class&quot;,
*       fields: [
*          { name: &quot;Name&quot;, type: &quot;string&quot; },
*          { name: &quot;StudyGroups&quot;, type: &quot;string_v&quot; }
*       ]
*    }]
* });
* // create a feature space containing the multinomial extractor, where the values are normalized,
* // and taken from the field &quot;StudyGroup&quot;: &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;
* var ftr = new qm.FeatureSpace(base, {
*              type: &quot;multinomial&quot;, source: &quot;Class&quot;, field: &quot;StudyGroups&quot;, normalize: true, values: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;]
*           });
* base.close();
*/
/**
* @typedef {Object} FeatureExtractorText
* The feature extractor of type &#x60;&#x27;text&#x27;&#x60;. Used for constructing {@link module:qm.FeatureSpace} objects.
* @property {string} type - The type of the extractor. &amp;lt;b&gt;Important&amp;lt;/b&gt;: It must be equal &#x60;&#x27;text&#x27;&#x60;.
* @property {boolean} [normalize = &#x27;true&#x27;] - Normalize the resulting vector of the extractor to have L2 norm 1.0.
* @property {string} [weight = &#x27;tfidf&#x27;] - Type of weighting used for scoring terms. Possible options are:
* &amp;lt;br&gt;1. &#x60;&#x27;none&#x27;&#x60; - Sets 1 if the term occurs and 0 otherwise.
* &amp;lt;br&gt;2. &#x60;&#x27;tf&#x27;&#x60; - Sets the term frequency in the document.
* &amp;lt;br&gt;3. &#x60;&#x27;idf&#x27;&#x60; - Sets the inverse document frequency in the document.
* &amp;lt;br&gt;4. &#x60;&#x27;tfidf&#x27;&#x60; - Sets the product of the &#x60;tf&#x60; and &#x60;idf&#x60; frequency.
* @property {number} [hashDimension] - A hashing code to set the fixed dimensionality. All values are hashed and divided modulo hashDimension to get the corresponding dimension.
* @property {string} field - The name of the field from which to take the value.
* @property {module:qm~FeatureTokenizer} tokenizer - The settings for extraction of text.
* @property {string} [mode] - How are multi-record cases combined into single vector. Possible options:
* &amp;lt;br&gt;1. &#x60;&#x27;concatenate&#x27;&#x60; - Multi-record cases are merged into one document.
* &amp;lt;br&gt;2. &#x60;&#x27;centroid&#x27;&#x60; - Treat each case as a seperate document.
* &amp;lt;br&gt;3. &#x60;&#x27;tokenized&#x27;&#x60; - use the tokenizer option.
* @property {string} [stream] - Details on forgetting old IDFs when running on stream. Possible options:
* &amp;lt;br&gt;1. &#x60;&#x27;field&#x27;&#x60; - Field name which is providing timestamp. If missing, system time is used (&amp;lt;i&gt;optional&amp;lt;/i&gt;).
* &amp;lt;br&gt;2. &#x60;&#x27;factor&#x27;&#x60; - Forgetting factor, by which the olf IDFs are multiplied after each iteration.
* &amp;lt;br&gt;3. &#x60;&#x27;interval&#x27;&#x60; - The time between iterations when the factor is applied, standard JSON time format is used to specify the interval duration.
* @property {string} source - The store name.
* @example
* var qm = require(&#x27;qminer&#x27;);
* // create a simple base, where each record contains the title of the article and it&#x27;s content
* var base = new qm.Base({
*    mode: &#x27;createClean&#x27;,
*    schema: [{
*       name: &quot;Articles&quot;,
*       fields: [
*          { name: &quot;Title&quot;, type: &quot;string&quot; },
*          { name: &quot;Text&quot;, type: &quot;string&quot; }
*       ]
*    }]
* });
* // create a feature spave containing the text (bag of words) extractor, where the values are normalized,
* // weighted with &#x27;tfidf&#x27; and the tokenizer is of &#x27;simple&#x27; type, it uses english stopwords.
* var ftr = new qm.FeatureSpace(base, {
*              type: &quot;text&quot;, source: &quot;Articles&quot;, field: &quot;Text&quot;, normalize: true, weight: &quot;tfidf&quot;,
*              tokenizer: { type: &quot;simple&quot;, stopwords: &quot;en&quot;}
*           });
* base.close();
*/
/**
* @typedef {Object} FeatureExtractorJoin
* The feature extractor of type &#x60;&#x27;join&#x27;&#x60;. Used for constructing {@link module:qm.FeatureSpace} objects.
* @property {string} type - The type of the extractor. &amp;lt;b&gt;Important&amp;lt;/b&gt;: It must be equal &#x60;&#x27;join&#x27;&#x60;.
* @property {number} [bucketSize = 1] - The size of the bucket in which we group consecutive records.
* @property {string} source - The store name.
* @example
* // import qm module
* var qm = require(&#x27;qminer&#x27;);
*/
/**
* @typedef {Object} FeatureExtractorPair
* The feature extractor of type &#x60;&#x27;pair&#x27;&#x60;. Used for constructing {@link module:qm.FeatureSpace} objects.
* @property {string} type - The type of the extractor. &amp;lt;b&gt;Important&amp;lt;/b&gt;: It must be equal &#x60;&#x27;pair&#x27;&#x60;.
* @property {module:qm~FeatureExtractors} first - The first feature extractor.
* @property {module:qm~FeatureExtractors} second - The second feature extractor.
* @property {source} source - The store name.
* @example
* var qm = require(&#x27;qminer&#x27;);
*/
/**
* @typedef {Object} FeatureExtractorDateWindow
* The feature extractor of type &#x60;&#x27;dateWindow&#x27;&#x60;. Used for constructing {@link module:qm.FeatureSpace} objects.
* @property {string} type - The type of the extractor. &amp;lt;b&gt;Important&amp;lt;/b&gt;: It must be equal &#x60;&#x27;dateWindow&#x27;&#x60;.
* @property {string} [unit = &#x27;day&#x27;] - How granular is the time window. Possible options are &#x60;&#x27;day&#x27;&#x60;, &#x60;&#x27;week&#x27;&#x60;, &#x60;&#x27;month&#x27;&#x60;, &#x60;&#x27;year&#x27;&#x60;, &#x60;&#x27;12hours&#x27;&#x60;, &#x60;&#x27;6hours&#x27;&#x60;, &#x60;&#x27;4hours&#x27;&#x60;, &#x60;&#x27;2hours&#x27;&#x60;,
* &#x60;&#x27;hour&#x27;&#x60;, &#x60;&#x27;30minutes&#x27;&#x60;, &#x60;&#x27;15minutes&#x27;&#x60;, &#x60;&#x27;10minutes&#x27;&#x60;, &#x60;&#x27;minute&#x27;&#x60;, &#x60;&#x27;second&#x27;&#x60;.
* @property {number} [window = 1] - The size of the window.
* @property {boolean} [normalize = &#x27;false&#x27;] - Normalize the resulting vector of the extractor to have L2 norm 1.0. //TODO
* @property {number} start - //TODO
* @property {number} end - //TODO
* @property {string} source - The store name.
* @example
* // import qm module
* var qm = require(&#x27;qminer&#x27;);
*/
/**
* @typedef {Object} FeatureExtractorJsfunc
* The feature extractor of type &#x60;&#x27;jsfunc&#x27;&#x60;. Used for constructing {@link module:qm.FeatureSpace} objects.
* @property {string} type - The type of the extractor. &amp;lt;b&gt;Important&amp;lt;/b&gt;: It must be equal &#x60;&#x27;jsfunc&#x27;&#x60;.
* @property {string} name - The features name.
* @property {function} fun - The javascript function callback. It takes one parameter:
* &amp;lt;br&gt;1. &#x60;rec&#x60; - The record. Type {@link module:qm.Record}.
* It returns &#x60;number&#x60; or {@link module:la.Vector}.
* @property {number} [dim = 1] - The dimension of the feature extractor.
* @property {string} source - The store name.
* @example
* var qm = require(&#x27;qminer&#x27;);
* // create a simple base, where each record contains the name of the student and his study groups
* // each student is part of multiple study groups
* var base = new qm.Base({
*    mode: &#x27;createClean&#x27;,
*    schema: [{
*       name: &quot;Class&quot;,
*       fields: [
*          { name: &quot;Name&quot;, type: &quot;string&quot; },
*          { name: &quot;StudyGroups&quot;, type: &quot;string_v&quot; }
*       ]
*    }]
* });
* // create a feature space containing the jsfunc extractor, where the function counts the number
* // of study groups each student is part of. The functions name is &quot;NumberOFGroups&quot;, it&#x27;s dimension
* // is 1 (returns only one value, not an array)
* var ftr = new qm.FeatureSpace(base, {
*              type: &quot;jsfunc&quot;, source: &quot;Class&quot;, name: &quot;NumberOfGroups&quot;, dim: 1,
*              fun: function (rec) { return rec.StudyGroups.length; }
*           });
* base.close();
*/
/**
* The settings for extraction of text used in {@link module:qm~FeatureExtractorText}.
* @typedef {Object} FeatureTokenizer
* @property {string} [type = &#x27;simple&#x27;] - The type of the encoding text. Possible options:
* &amp;lt;br&gt;1. &#x60;&#x27;simple&#x27;&#x60; - The simple encoding.
* &amp;lt;br&gt;2. &#x60;&#x27;html&#x27;&#x60; - The html encoding.
* &amp;lt;br&gt;3.B2&#x60;&#x27;unicode&#x27;&#x60; - The unicode encoding.
* @property {string | Array.&amp;lt;string&gt;} [stopwords = &#x27;en&#x27;] - The stopwords used for extraction. Possible options:
* &amp;lt;br&gt;1. &#x60;&#x27;none&#x27;&#x60; - No pre-defined stopword list. Type &#x60;string&#x60;.
* &amp;lt;br&gt;2. &#x60;&#x27;en&#x27;&#x60; - The english pre-defined stopword list. Type &#x60;string&#x60;.
* &amp;lt;br&gt;3. &#x60;&#x27;si&#x27;&#x60; - The slovene pre-defined stopword list. Type &#x60;string&#x60;.
* &amp;lt;br&gt;4. &#x60;&#x27;es&#x27;&#x60; - The spanish pre-defined stopword list. Type &#x60;string&#x60;.
* &amp;lt;br&gt;5. &#x60;&#x27;de&#x27;&#x60; - The german pre-defined stopword list. Type &#x60;string&#x60;.
* &amp;lt;br&gt;6. &#x60;array&#x60; - An array of stopwords. The array must be given as a parameter. Type &#x60;Array of strings&#x60;.
* @property {string} [stemmer = &#x27;none&#x27;] - The stemmer used for extraction. Possible options:
* &amp;lt;br&gt;1. &#x60;&#x27;true&#x27;&#x60; - Using the porter stemmer.
* &amp;lt;br&gt;2. &#x60;&#x27;porter&#x27;&#x60; - Using the porter stemmer.
* &amp;lt;br&gt;3. &#x60;&#x27;none&#x27;&#x60; - Using no stemmer.
* @property {boolean} [uppercase = &#x27;true&#x27;] - Changing all words to uppercase.
*/
/**
* Feature Space
* @classdesc Represents the feature space. It contains any of the {@link module:qm~FeatureExtractor} objects.
* @class
* @param {module:qm.Base} base - The base where the features are extracted from.
* @param {(Array.&amp;lt;module:qm~FeatureExtractor&gt; | module:fs.FIn)} arg - Constructor arguments. There are two ways of constructing:
* &amp;lt;br&gt;1. Using an array of {@link module:qm~FeatureExtractor} objects,
* &amp;lt;br&gt;2. using a file input stream {@link module:fs.FIn}.
* @example
* // import qm module
* var qm = require(&#x27;qminer&#x27;);
* // construct a base with the store
* var base = new qm.Base({
*   mode: &quot;createClean&quot;,
*   schema: {
*     name: &quot;FtrSpace&quot;,
*     fields: [
*       { name: &quot;Value&quot;, type: &quot;float&quot; },
*       { name: &quot;Category&quot;, type: &quot;string&quot; },
*       { name: &quot;Categories&quot;, type: &quot;string_v&quot; },
*     ],
*     joins: [],
*     keys: []
*   }
* });
* // populate the store
* Store = base.store(&quot;FtrSpace&quot;);
* Store.push({ Value: 1.0, Category: &quot;a&quot;, Categories: [&quot;a&quot;, &quot;q&quot;] });
* Store.push({ Value: 1.1, Category: &quot;b&quot;, Categories: [&quot;b&quot;, &quot;w&quot;] });
* Store.push({ Value: 1.2, Category: &quot;c&quot;, Categories: [&quot;c&quot;, &quot;e&quot;] });
* Store.push({ Value: 1.3, Category: &quot;a&quot;, Categories: [&quot;a&quot;, &quot;q&quot;] });
* // create a feature space
* var ftr = new qm.FeatureSpace(base, { type: &quot;numeric&quot;, source: &quot;FtrSpace&quot;, field: &quot;Value&quot; });
* base.close();
*/
 exports.FeatureSpace = function (base, arg) { return Object.create(require(&#x27;qminer&#x27;).FeatureSpace.prototype); };
/**
    * Returns the dimension of the feature space. Type &#x60;number&#x60;.
    */
 exports.FeatureSpace.prototype.dim = 0;
/**
    * Returns an array of the dimensions of each feature extractor in the feature space. Type &#x60;Array of numbers&#x60;.
    */
 exports.FeatureSpace.prototype.dims = [0];
/**
    * Serialize the feature space to an output stream.
    * @param {module:fs.FOut} fout - The output stream.
    * @returns {module:fs.FOut} The output stream &#x60;fout&#x60;.
    */
 exports.FeatureSpace.prototype.save = function (fout) { return Object.create(require(&#x27;qminer&#x27;).fs.FOut.prototype); };
/**
    * Clears the feature space.
    * @returns {module:qm.FeatureSpace} Self. Features space has been cleared.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a new base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;Runners&quot;,
    *        fields: [
    *            { name: &quot;ID&quot;, type: &quot;int&quot;, primary: true },
    *            { name: &quot;Name&quot;, type: &quot;string&quot; },
    *            { name: &quot;BestTime&quot;, type: &quot;float&quot; }
    *        ]
    *    }]
    * });
    * // put some records in the &quot;Runners&quot; store
    * base.store(&quot;Runners&quot;).push({ ID: 110020, Name: &quot;Eric Ericsson&quot;, BestTime: 134.33 });
    * base.store(&quot;Runners&quot;).push({ ID: 123307, Name: &quot;Fred Friedrich&quot;, BestTime: 101.11 });
    * base.store(&quot;Runners&quot;).push({ ID: 767201, Name: &quot;Appel Banana&quot;, BestTime: 1034.56 });
    * // create a feature space
    * var ftr = new qm.FeatureSpace(base, { type: &quot;numeric&quot;, source: &quot;Runners&quot;, field: &quot;BestTime&quot; });
    * // update the feature space
    * ftr.updateRecords(base.store(&quot;Runners&quot;).allRecords);
    * // clear the feature space (return the feature space to it&#x27;s default values)
    * ftr.clear();
    * base.close();
    */
 exports.FeatureSpace.prototype.clear = function () { return Object.create(require(&#x27;qminer&#x27;).FeatureSpace.prototype); };
/**
    * Adds a new feature extractor to the feature space.
    * @param {module:qm~FeatureExtractor} ftExt - The added feature extractor.
    * @returns {module:qm.FeatureSpace} Self.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a new base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;WeatherForcast&quot;,
    *        fields: [
    *            { name: &quot;Weather&quot;, type: &quot;string&quot; },
    *            { name: &quot;Date&quot;, type: &quot;datetime&quot; },
    *            { name: &quot;TemperatureDegrees&quot;, type: &quot;int&quot; }
    *        ]
    *    }]
    * });
    * // put some records in the &quot;WeatherForecast&quot; store
    * base.store(&quot;WeatherForcast&quot;).push({ Weather: &quot;Partly Cloudy&quot;, Date: &quot;2015-05-27T11:00:00&quot;, TemperatureDegrees: 19 });
    * base.store(&quot;WeatherForcast&quot;).push({ Weather: &quot;Partly Cloudy&quot;, Date: &quot;2015-05-28T11:00:00&quot;, TemperatureDegrees: 22 });
    * base.store(&quot;WeatherForcast&quot;).push({ Weather: &quot;Mostly Cloudy&quot;, Date: &quot;2015-05-29T11:00:00&quot;, TemperatureDegrees: 25 });
    * base.store(&quot;WeatherForcast&quot;).push({ Weather: &quot;Mostly Cloudy&quot;, Date: &quot;2015-05-30T11:00:00&quot;, TemperatureDegrees: 25 });
    * base.store(&quot;WeatherForcast&quot;).push({ Weather: &quot;Scattered Showers&quot;, Date: &quot;2015-05-31T11:00:00&quot;, TemperatureDegrees: 24 });
    * base.store(&quot;WeatherForcast&quot;).push({ Weather: &quot;Mostly Cloudy&quot;, Date: &quot;2015-06-01T11:00:00&quot;, TemperatureDegrees: 27 });
    * // create a feature space
    * var ftr = new qm.FeatureSpace(base, { type: &quot;numeric&quot;, source: &quot;WeatherForcast&quot;, field: &quot;TemperatureDegrees&quot; });
    * // add a new feature extractor to the feature space
    * // it adds the new feature extractor to the pre-existing feature extractors in the feature space
    * ftr.addFeatureExtractor({ type: &quot;text&quot;, source: &quot;WeatherForcast&quot;, field: &quot;Weather&quot;, normalize: true, weight: &quot;tfidf&quot; });
    * base.close();
    */
 exports.FeatureSpace.prototype.addFeatureExtractor = function (ftExt) { return Object.create(require(&#x27;qminer&#x27;).FeatureSpace.prototype); };
/**
    * Updates the feature space definitions and extractors by adding one record.
    * &amp;lt;br&gt; For text feature extractors, it can update it&#x27;s vocabulary by taking into account the new text.
    * &amp;lt;br&gt; For numeric feature extractors, it can update the minimal and maximal values used to form the normalization.
    * &amp;lt;br&gt; For jsfunc feature extractors, it can update a parameter used in it&#x27;s function.
    * &amp;lt;br&gt; For dateWindow feature extractor, it can update the start and the end of the window period to form the normalization.
    * @param {module:qm.Record} rec - The record, which updates the feature space.
    * @returns {module:qm.FeatureSpace} Self. The feature space has been updated.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a new base
    * var base = new qm.Base({
    *   mode: &quot;createClean&quot;,
    *   schema: {
    *     name: &quot;FtrSpace&quot;,
    *     fields: [
    *       { name: &quot;Value&quot;, type: &quot;float&quot; },
    *       { name: &quot;Category&quot;, type: &quot;string&quot; },
    *       { name: &quot;Categories&quot;, type: &quot;string_v&quot; },
    *     ]
    *   }
    * });
    * // populate the store
    * Store = base.store(&quot;FtrSpace&quot;);
    * Store.push({ Value: 1.0, Category: &quot;a&quot;, Categories: [&quot;a&quot;, &quot;q&quot;] });
    * Store.push({ Value: 1.1, Category: &quot;b&quot;, Categories: [&quot;b&quot;, &quot;w&quot;] });
    * Store.push({ Value: 1.2, Category: &quot;c&quot;, Categories: [&quot;c&quot;, &quot;e&quot;] });
    * Store.push({ Value: 1.3, Category: &quot;a&quot;, Categories: [&quot;a&quot;, &quot;q&quot;] });
    * // create a new feature space
    * var ftr = new qm.FeatureSpace(base, [
    *   { type: &quot;numeric&quot;, source: &quot;FtrSpace&quot;, normalize: true, field: &quot;Value&quot; },
    *   { type: &quot;categorical&quot;, source: &quot;FtrSpace&quot;, field: &quot;Category&quot;, values: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] },
    *   { type: &quot;multinomial&quot;, source: &quot;FtrSpace&quot;, field: &quot;Categories&quot;, normalize: true, values: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;q&quot;, &quot;w&quot;, &quot;e&quot;] }
    * ]);
    * // update the feature space with the first three record of the store
    * ftr.updateRecord(Store[0]);
    * ftr.updateRecord(Store[1]);
    * ftr.updateRecord(Store[2]);
    * // get the feature vectors of these records
    * ftr.extractVector(Store[0]); // returns the vector [0, 1, 0, 0, 1 / Math.sqrt(2), 0, 0, 1 / Math.sqrt(2), 0, 0]
    * ftr.extractVector(Store[1]); // returns the vector [1/2, 0, 1, 0, 0, 1 / Math.sqrt(2), 0, 0, 1 / Math.sqrt(2), 0]
    * ftr.extractVector(Store[2]); // returns the vector [1, 0, 0, 1, 0, 0, 1 / Math.sqrt(2), 0, 0, 1 / Math.sqrt(2)]
    * base.close();
    */
 exports.FeatureSpace.prototype.updateRecord = function (rec) { return Object.create(require(&#x27;qminer&#x27;).FeatureSpace.prototype); };
/**
    * Updates the feature space definitions and extractors by adding all the records of a record set.
    * &amp;lt;br&gt; For text feature extractors, it can update it&#x27;s vocabulary by taking into account the new text.
    * &amp;lt;br&gt; For numeric feature extractors, it can update the minimal and maximal values used to form the normalization.
    * &amp;lt;br&gt; For jsfunc feature extractors, it can update a parameter used in it&#x27;s function.
    * &amp;lt;br&gt; For dateWindow feature extractor, it can update the start and the end of the window period to form the normalization.
    * @param {module:qm.RecordSet} rs - The record set, which updates the feature space.
    * @returns {module:qm.FeatureSpace} Self. The feature space has been updated.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a new base
    * var base = new qm.Base({
    *   mode: &quot;createClean&quot;,
    *   schema: {
    *     name: &quot;FtrSpace&quot;,
    *     fields: [
    *       { name: &quot;Value&quot;, type: &quot;float&quot; },
    *       { name: &quot;Category&quot;, type: &quot;string&quot; },
    *       { name: &quot;Categories&quot;, type: &quot;string_v&quot; },
    *     ]
    *   }
    * });
    * // populate the store
    * Store = base.store(&quot;FtrSpace&quot;);
    * Store.push({ Value: 1.0, Category: &quot;a&quot;, Categories: [&quot;a&quot;, &quot;q&quot;] });
    * Store.push({ Value: 1.1, Category: &quot;b&quot;, Categories: [&quot;b&quot;, &quot;w&quot;] });
    * Store.push({ Value: 1.2, Category: &quot;c&quot;, Categories: [&quot;c&quot;, &quot;e&quot;] });
    * Store.push({ Value: 1.3, Category: &quot;a&quot;, Categories: [&quot;a&quot;, &quot;q&quot;] });
    * // create a new feature space
    * var ftr = new qm.FeatureSpace(base, [
    *     { type: &quot;numeric&quot;, source: &quot;FtrSpace&quot;, normalize: true, field: &quot;Value&quot; },
    *     { type: &quot;categorical&quot;, source: &quot;FtrSpace&quot;, field: &quot;Category&quot;, values: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] },
    *     { type: &quot;multinomial&quot;, source: &quot;FtrSpace&quot;, field: &quot;Categories&quot;, normalize: true, values: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;q&quot;, &quot;w&quot;, &quot;e&quot;] }
    * ]);
    * // update the feature space with the record set
    * ftr.updateRecords(Store.allRecords);
    * // get the feature vectors of these records
    * ftr.extractVector(Store[0]); // returns the vector [0, 1, 0, 0, 1 / Math.sqrt(2), 0, 0, 1 / Math.sqrt(2), 0, 0]
    * ftr.extractVector(Store[1]); // returns the vector [1/3, 0, 1, 0, 0, 1 / Math.sqrt(2), 0, 0, 1 / Math.sqrt(2), 0]
    * ftr.extractVector(Store[2]); // returns the vector [2/3, 0, 0, 1, 0, 0, 1 / Math.sqrt(2), 0, 0, 1 / Math.sqrt(2)]
    * ftr.extractVector(Store[3]); // returns the vector [1, 1, 0, 0, 1 / Math.sqrt(2), 0, 0, 1 / Math.sqrt(2), 0, 0]
    * base.close();
    */
 exports.FeatureSpace.prototype.updateRecords = function (rs) { return Object.create(require(&#x27;qminer&#x27;).FeatureSpace.prototype); };
/**
    * Creates a sparse feature vector from the given record.
    * @param {module:qm.Record} rec - The given record.
    * @param {number} [idx] - When given, only use specified feature extractor.
    * @returns {module:la.SparseVector} The sparse feature vector gained from &#x60;rec&#x60; and &#x60;idx&#x60;.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a base containing the store Class. Let the Name field be the primary field.
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;Class&quot;,
    *        fields: [
    *            { name: &quot;Name&quot;, type: &quot;string&quot;, primary: true },
    *            { name: &quot;StudyGroup&quot;, type: &quot;string&quot; }
    *        ]
    *    }]
    * });
    * // add some records to the store
    * base.store(&quot;Class&quot;).push({ Name: &quot;Dean&quot;, StudyGroup: &quot;A&quot; });
    * base.store(&quot;Class&quot;).push({ Name: &quot;Chang&quot;, StudyGroup: &quot;D&quot; });
    * base.store(&quot;Class&quot;).push({ Name: &quot;Magnitude&quot;, StudyGroup: &quot;C&quot; });
    * base.store(&quot;Class&quot;).push({ Name: &quot;Leonard&quot;, StudyGroup: &quot;B&quot; });
    * // create a new feature space
    * // the feature space is of dimensions [0, 4]; 4 is the dimension of the categorical feature extractor
    * // and 0 is the dimension of text feature extractor (the text feature extractor doesn&#x27;t have any words,
    * // need to be updated for use).
    * var ftr = new qm.FeatureSpace(base, [
    *    { type: &quot;text&quot;, source: &quot;Class&quot;, field: &quot;Name&quot;, normalize: false },
    *    { type: &quot;categorical&quot;, source: &quot;Class&quot;, field: &quot;StudyGroup&quot;, values: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;] }
    * ]);
    * // get the sparse extractor vector for the first record in store
    * // the sparse vector will be [(0, 1)] - uses only the categorical feature extractor. There are no
    * // features in the text feature extractor.
    * var vec = ftr.extractSparseVector(base.store(&quot;Class&quot;)[0]);
    * base.close();
    */
 exports.FeatureSpace.prototype.extractSparseVector = function (rec, idx) { return Object.create(require(&#x27;qminer&#x27;).la.SparseVector.prototype); }
/**
    * Creates a feature vector from the given record.
    * @param {module:qm.Record} rec - The given record.
    * @param {number} [idx] - when given, only use specified feature extractor.
    * @returns {module:la.Vector} The feature vector gained from &#x60;rec&#x60; and &#x60;idx&#x60;.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a base containing the store Class. Let the Name field be the primary field.
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;Class&quot;,
    *        fields: [
    *            { name: &quot;Name&quot;, type: &quot;string&quot;, primary: true },
    *            { name: &quot;StudyGroup&quot;, type: &quot;string&quot; }
    *        ]
    *    }]
    * });
    * // add some records to the store
    * base.store(&quot;Class&quot;).push({ Name: &quot;Jeff&quot;, StudyGroup: &quot;A&quot; });
    * base.store(&quot;Class&quot;).push({ Name: &quot;Britta&quot;, StudyGroup: &quot;D&quot; });
    * base.store(&quot;Class&quot;).push({ Name: &quot;Abed&quot;, StudyGroup: &quot;C&quot; });
    * base.store(&quot;Class&quot;).push({ Name: &quot;Annie&quot;, StudyGroup: &quot;B&quot; });
    * // create a new feature space
    * // the feature space is of dimensions [0, 4]; 4 is the dimension of the categorical feature extractor
    * // and 0 is the dimension of text feature extractor (the text feature extractor doesn&#x27;t have any words,
    * // need to be updated for use).
    * var ftr = new qm.FeatureSpace(base, [
    *    { type: &quot;text&quot;, source: &quot;Class&quot;, field: &quot;Name&quot;, normalize: false },
    *    { type: &quot;categorical&quot;, source: &quot;Class&quot;, field: &quot;StudyGroup&quot;, values: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;] }
    * ]);
    * // get the extractor vector for the first record in store
    * // the sparse vector will be [1, 0, 0, 0] - uses only the categorical feature extractor. There are no
    * // features in the text feature extractor.
    * var vec = ftr.extractVector(base.store(&quot;Class&quot;)[0]);
    * base.close();
    */
 exports.FeatureSpace.prototype.extractVector = function (rec, idx) { return Object.create(require(&#x27;qminer&#x27;).la.Vector.prototype); };
/**
     * Extracts a single feature using the feature extractor.
     * @param {Integer} idx - Index of the feature extractor.
     * @param {Number} val - Value to extract.
     * @returns {object} The extracted single feature.
     */
 exports.FeatureSpace.prototyp.extractFeature = function (idx, val) { }
/**
    * Extracts the sparse feature vectors from the record set and returns them as columns of the sparse matrix.
    * @param {module:qm.RecordSet} rs - The given record set.
    * @param {number} [idx] - When given, only use specified feature extractor.
    * @returns {module:la.SparseMatrix} The sparse matrix, where the i-th column is the sparse feature vector of the i-th record in &#x60;rs&#x60;.
    * @example
    * // import qm module
    * var qm = require(&quot;qminer&quot;);
    * // create a base containing the store Class. Let the Name field be the primary field.
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;Class&quot;,
    *        fields: [
    *            { name: &quot;Name&quot;, type: &quot;string&quot;, primary: true },
    *            { name: &quot;StudyGroups&quot;, type: &quot;string_v&quot; }
    *        ]
    *    }]
    * });
    * // add some records to the store
    * base.store(&quot;Class&quot;).push({ Name: &quot;Dean&quot;, StudyGroups: [&quot;A&quot;, &quot;D&quot;] });
    * base.store(&quot;Class&quot;).push({ Name: &quot;Chang&quot;, StudyGroups: [&quot;B&quot;, &quot;D&quot;] });
    * base.store(&quot;Class&quot;).push({ Name: &quot;Magnitude&quot;, StudyGroups: [&quot;B&quot;, &quot;C&quot;] });
    * base.store(&quot;Class&quot;).push({ Name: &quot;Leonard&quot;, StudyGroups: [&quot;A&quot;, &quot;B&quot;] });
    * // create a feature space containing the multinomial feature extractor
    * var ftr = new qm.FeatureSpace(base, { type: &quot;multinomial&quot;, source: &quot;Class&quot;, field: &quot;StudyGroups&quot;, values: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;] });
    * // create a sparse feature matrix out of the records of the store by using the feature space
    * // returns a sparse matrix equal to
    * // [[(0, 1), (3, 1)], [(1, 1), (3, 1)], [(1, 1), (2, 1)], [(0, 1), (1, 1)]]
    * var sparseMatrix = ftr.extractSparseMatrix(base.store(&quot;Class&quot;).allRecords);
    * base.close();
    */
 exports.FeatureSpace.prototype.extractSparseMatrix = function (rs, idx) { return Object.create(require(&#x27;qminer&#x27;).la.SparseMatrix.prototype); };
/**
    * Extracts the feature vectors from the recordset and returns them as columns of a dense matrix.
    * @param {module:qm.RecordSet} rs - The given record set.
    * @param {number} [idx] - when given, only use specified feature extractor.
    * @returns {module:la.Matrix} The dense matrix, where the i-th column is the feature vector of the i-th record in &#x60;rs&#x60;.
    * @example
    * // import qm module
    * var qm = require(&quot;qminer&quot;);
    * // create a base containing the store Class. Let the Name field be the primary field.
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;Class&quot;,
    *        fields: [
    *            { name: &quot;Name&quot;, type: &quot;string&quot;, primary: true },
    *            { name: &quot;StudyGroups&quot;, type: &quot;string_v&quot; }
    *        ]
    *    }]
    * });
    * // add some records to the store
    * base.store(&quot;Class&quot;).push({ Name: &quot;Dean&quot;, StudyGroups: [&quot;A&quot;, &quot;D&quot;] });
    * base.store(&quot;Class&quot;).push({ Name: &quot;Chang&quot;, StudyGroups: [&quot;B&quot;, &quot;D&quot;] });
    * base.store(&quot;Class&quot;).push({ Name: &quot;Magnitude&quot;, StudyGroups: [&quot;B&quot;, &quot;C&quot;] });
    * base.store(&quot;Class&quot;).push({ Name: &quot;Leonard&quot;, StudyGroups: [&quot;A&quot;, &quot;B&quot;] });
    * // create a feature space containing the multinomial feature extractor
    * var ftr = new qm.FeatureSpace(base, { type: &quot;multinomial&quot;, source: &quot;Class&quot;, field: &quot;StudyGroups&quot;, values: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;] });
    * // create a feature matrix out of the records of the store by using the feature space
    * // returns a sparse matrix equal to
    * // 1  0  0  1
    * // 0  1  1  1
    * // 0  0  1  0
    * // 1  1  0  0
    * var matrix = ftr.extractMatrix(base.store(&quot;Class&quot;).allRecords);
    * base.close();
    */
 exports.FeatureSpace.prototype.extractMatrix = function (rs, idx) { return Object.create(require(&#x27;qminer&#x27;).la.Matrix.prototype); };
/**
    * Gives the name of feature extractor at given position.
    * @param {number} idx - The index of the feature extractor in feature space (zero based).
    * @returns {String} The name of the feature extractor at position &#x60;idx&#x60;.
    * @example
    * // import qm module
    * var qm = require(&quot;qminer&quot;);
    * // create a new base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;People&quot;,
    *        fields: [
    *            { name: &quot;Name&quot;, type: &quot;string&quot; },
    *            { name: &quot;Gendre&quot;, type: &quot;string&quot; },
    *            { name: &quot;Age&quot;, type: &quot;int&quot; }
    *        ]
    *    }]
    * });
    * // create a feature space containing a categorical and numeric feature extractor
    * var ftr = new qm.FeatureSpace(base, [
    *    { type: &quot;numeric&quot;, source: &quot;People&quot;, field: &quot;Age&quot; },
    *    { type: &quot;categorical&quot;, source: &quot;People&quot;, field: &quot;Gendre&quot;, values: [&quot;Male&quot;, &quot;Female&quot;] }
    * ]);
    * // get the name of the feature extractor with index 1
    * var extractorName = ftr.getFeatureExtractor(1); // returns &quot;Categorical[Gendre]&quot;
    * base.close();
    */
 exports.FeatureSpace.prototype.getFeatureExtractor = function (idx) { return &#x27;&#x27;; };
/**
    * Gives the name of the feature at the given position.
    * @param {number} idx - The index of the feature in feature space (zero based).
    * @returns {String} The name of the feature at the position &#x60;idx&#x60;.
    * @example
    * // import qm module
    * var qm = require(&quot;qminer&quot;);
    * // create a base containing the store Class. Let the Name field be the primary field.
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;Class&quot;,
    *        fields: [
    *            { name: &quot;Name&quot;, type: &quot;string&quot;, primary: true },
    *            { name: &quot;StudyGroups&quot;, type: &quot;string_v&quot; }
    *        ]
    *    }]
    * });
    * // add some records to the store
    * base.store(&quot;Class&quot;).push({ Name: &quot;Dean&quot;, StudyGroups: [&quot;A&quot;, &quot;D&quot;] });
    * base.store(&quot;Class&quot;).push({ Name: &quot;Chang&quot;, StudyGroups: [&quot;B&quot;, &quot;D&quot;] });
    * base.store(&quot;Class&quot;).push({ Name: &quot;Magnitude&quot;, StudyGroups: [&quot;B&quot;, &quot;C&quot;] });
    * base.store(&quot;Class&quot;).push({ Name: &quot;Leonard&quot;, StudyGroups: [&quot;A&quot;, &quot;B&quot;] });
    * // create a feature space containing the multinomial feature extractor
    * var ftr = new qm.FeatureSpace(base, [
    * { type: &quot;text&quot;, source: &quot;Class&quot;, field: &quot;Name&quot; },
    * { type: &quot;multinomial&quot;, source: &quot;Class&quot;, field: &quot;StudyGroups&quot;, values: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;] }
    * ]);
    * // get the feature at position 2
    * var feature = ftr.getFeature(2); // returns &quot;C&quot;, because the text extractor has no features at the moment
    * // update the feature space with the records of the store; see the method updateRecords
    * ftr.updateRecords(base.store(&quot;Class&quot;).allRecords);
    * // get the feature at position 2
    * var feature2 = ftr.getFeature(2); // returns &quot;magnitude&quot;
    * base.close();
    */
 exports.FeatureSpace.prototype.getFeature = function (idx) { return &#x27;&#x27;; };
/**
    * Performs the inverse operation of &#x60;ftrVec&#x60;. Works only for numeric feature extractors.
    * @param {(module:la.Vector | Array.&amp;lt;Object&gt;)} ftr - The feature vector or an array with feature values.
    * @returns {Array.&amp;lt;Object&gt;} The inverse of &#x60;ftr&#x60; as an array.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a new base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;TheWitcherSaga&quot;,
    *        fields: [
    *            { name: &quot;Title&quot;, type: &quot;string&quot; },
    *            { name: &quot;YearOfRelease&quot;, type: &quot;int&quot; },
    *            { name: &quot;EnglishEdition&quot;, type: &quot;bool&quot; }
    *        ]
    *    }]
    * });
    * // put some records in the store
    * base.store(&quot;TheWitcherSaga&quot;).push({ Title: &quot;Blood of Elves&quot;, YearOfRelease: 1994, EnglishEdition: true });
    * base.store(&quot;TheWitcherSaga&quot;).push({ Title: &quot;Time of Contempt&quot;, YearOfRelease: 1995, EnglishEdition: true });
    * base.store(&quot;TheWitcherSaga&quot;).push({ Title: &quot;Baptism of Fire&quot;, YearOfRelease: 1996, EnglishEdition: true });
    * base.store(&quot;TheWitcherSaga&quot;).push({ Title: &quot;The Swallow&#x27;s Tower&quot;, YearOfRelease: 1997, EnglishEdition: false });
    * base.store(&quot;TheWitcherSaga&quot;).push({ Title: &quot;Lady of the Lake&quot;, YearOfRelease: 1999, EnglishEdition: false });
    * base.store(&quot;TheWitcherSaga&quot;).push({ Title: &quot;Season of Storms&quot;, YearOfRelease: 2013, EnglishEdition: false });
    * // create a feature space with the numeric feature extractor and update the feature space with the records in store
    * // for update, look the method updateRecords in feature space
    * var ftr = new qm.FeatureSpace(base, { type: &quot;numeric&quot;, source: &quot;TheWitcherSaga&quot;, field: &quot;YearOfRelease&quot;, normalize: true });
    * ftr.updateRecords(base.store(&quot;TheWitcherSaga&quot;).allRecords);
    * // get a feature vector for the second record
    * // because of the numeric feature extractor having normalize: true and of the records update of feature space, the values
    * // are not equal to those of the records, i.e. the value 1995 is now 0.105263
    * var ftrVec = ftr.extractVector(base.store(&quot;TheWitcherSaga&quot;)[1]);
    * // get the inverse of the feature vector
    * // the function returns the values to their first value, i.e. 0.105263 returns to 1995
    * var inverse = ftr.invertFeatureVector(ftrVec); // returns a vector [1995]
    * base.close();
    */
 exports.FeatureSpace.prototype.invertFeatureVector = function (ftr) { return Object.create(require(&#x27;qminer&#x27;).la.Vector.prototype); };
/**
    * Calculates the inverse of a single feature using a specific feature extractor.
    * @param {number} idx - The index of the specific feature extractor.
    * @param {Object} val - The value to be inverted.
    * @returns {Object} The inverse of &#x60;val&#x60; using the feature extractor with index &#x60;idx&#x60;.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a new base containing one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;TheWitcherSaga&quot;,
    *        fields: [
    *            { name: &quot;Title&quot;, type: &quot;string&quot; },
    *            { name: &quot;YearOfRelease&quot;, type: &quot;int&quot; },
    *            { name: &quot;EnglishEdition&quot;, type: &quot;bool&quot; }
    *        ]
    *    }]
    * });
    * // put some records in the store
    * base.store(&quot;TheWitcherSaga&quot;).push({ Title: &quot;Blood of Elves&quot;, YearOfRelease: 1994, EnglishEdition: true });
    * base.store(&quot;TheWitcherSaga&quot;).push({ Title: &quot;Time of Contempt&quot;, YearOfRelease: 1995, EnglishEdition: true });
    * base.store(&quot;TheWitcherSaga&quot;).push({ Title: &quot;Baptism of Fire&quot;, YearOfRelease: 1996, EnglishEdition: true });
    * base.store(&quot;TheWitcherSaga&quot;).push({ Title: &quot;The Swallow&#x27;s Tower&quot;, YearOfRelease: 1997, EnglishEdition: false });
    * base.store(&quot;TheWitcherSaga&quot;).push({ Title: &quot;Lady of the Lake&quot;, YearOfRelease: 1999, EnglishEdition: false });
    * base.store(&quot;TheWitcherSaga&quot;).push({ Title: &quot;Season of Storms&quot;, YearOfRelease: 2013, EnglishEdition: false });
    * // create a feature space with the numeric feature extractor and update the feature space with the records in store
    * // for update, look the method updateRecords in feature space
    * var ftr = new qm.FeatureSpace(base, { type: &quot;numeric&quot;, source: &quot;TheWitcherSaga&quot;, field: &quot;YearOfRelease&quot;, normalize: true });
    * ftr.updateRecords(base.store(&quot;TheWitcherSaga&quot;).allRecords);
    * // because of the numeric feature extractor having normalize: true and of the records update of feature space,
    * // the values are not equal to those of the records
    * // invert the value 0 using the numeric feature extractor
    * var inverse = ftr.invertFeature(0, 0); // returns the value 1994
    * base.close();
    */
 exports.FeatureSpace.prototype.invertFeature = function (idx, val) {};
/**
    * Filters the vector to keep only the elements from the feature extractor.
    * @param {(module:la.Vector | module:la.SparseVector)} vec - The vector from where the function filters the elements.
    * @param {number} idx - The index of the feature extractor.
    * @param {boolean} [keepOffset = &#x27;true&#x27;] - For keeping the original indexing in the new vector.
    * @returns {(module:la.Vector | module:la.SparseVector)}
    * &amp;lt;br&gt;1. {@link module:la.Vector}, if &#x60;vec&#x60; is {@link module:la.Vector}.
    * &amp;lt;br&gt;2. {@link module:la.SparseVector}, if &#x60;vec&#x60; is {@link module:la.SparseVector}.
    * @example
    * // import qm module
    * var qm = require(&#x27;qminer&#x27;);
    * // create a new base with one store
    * var base = new qm.Base({
    *    mode: &quot;createClean&quot;,
    *    schema: [{
    *        name: &quot;Academics&quot;,
    *        fields: [
    *            { name: &quot;Name&quot;, type: &quot;string&quot; },
    *            { name: &quot;Age&quot;, type: &quot;int&quot; },
    *            { name: &quot;Gendre&quot;, type: &quot;string&quot; },
    *            { name: &quot;Skills&quot;, type: &quot;string_v&quot; }
    *        ]
    *    }]
    * });
    * // create a new feature space
    * var ftr = new qm.FeatureSpace(base, [
    *     { type: &quot;numeric&quot;, source: &quot;Academics&quot;, field: &quot;Age&quot; },
    *     { type: &quot;categorical&quot;, source: &quot;Academics&quot;, field: &quot;Gendre&quot;, values: [&quot;Male&quot;, &quot;Female&quot;] },
    *     { type: &quot;multinomial&quot;, source: &quot;Academics&quot;, field: &quot;Skills&quot;, values: [&quot;Mathematics&quot;, &quot;Programming&quot;, &quot;Philosophy&quot;, &quot;Languages&quot;, &quot;Politics&quot;, &quot;Cooking&quot;] }
    *     ]);
    * // create a new dense vector
    * var vec = new qm.la.Vector([40, 0, 1, 0, 1, 1, 1, 0, 0]);
    * // filter the elements from the second feature extractor
    * var vec2 = ftr.filter(vec, 1); // returns vector [0, 0, 1, 0, 0, 0, 0, 0, 0]
    * // filter the elements from the second feature extractor, without keeping the offset
    * var vec3 = ftr.filter(vec, 1, false); // returns vector [0, 1]
    * // create a new sparse vector
    * var spVec = new qm.la.SparseVector([[0, 40], [2, 1], [4, 1], [5, 1], [6, 1]]);
    * // filter the elements from the second feature extractor
    * var spVec2 = ftr.filter(spVec, 1); // returns sparse vector [[2, 1]]
    * // filter the elements from the second feature extractor, without keeping the offset
    * var spVec3 = ftr.filter(spVec, 1, false); // returns sparse vector [[1, 1]]
    * base.close();
    */
 exports.FeatureSpace.prototype.filter = function (vec, idx, keepOffset) { return (vec instanceof require(&#x27;qminer&#x27;).la.Vector) ? require(&#x27;qminer&#x27;).la.Vector : require(&#x27;qminer&#x27;).la.SparseVector; };
/**
    * Extracts string features from the record.
    * @param {module:qm.Record} rec - The record.
    * @returns {Array.&amp;lt;string&gt;} An array containing the strings gained by the extractor.
    * @ignore
    */
 exports.FeatureSpace.prototype.extractStrings = function (rec) {return [&#x27;&#x27;]; };


    //==================================================================
    // BASE
    //==================================================================

    /**
    * @typedef {object} BaseLoadCSVParam
    * The parameter given to {@link module:qm.Base#loadCSV}.
    * @property {string} file - The name of the input file.
    * @property {string} store - Name of the store which will be created.
    * @property {module:qm.Base} base - QMiner base object that creates the store.
    * @property {string} [delimiter = &#x27;,&#x27;] - Optional delimiter.
    * @property {string} [quote = &#x27;&quot;&#x27;] - Optional character to escape values that contain a delimiter.
    */

    /**
     * Loads the store from a CSV file.
     * @param {module:qm~BaseLoadCSVParam} opts - Options object.
     * @param {function} [callback] - Callback function, called on errors and when the procedure finishes.
     */
    exports.Base.prototype.loadCSV = function (opts, callback) {
    	// console.log(&#x27;Loading CSV file ...&#x27;);

    	if (opts.delimiter == null) opts.delimiter = &#x27;,&#x27;;
    	if (opts.quote == null) opts.quote = &#x27;&quot;&#x27;;
    	if (opts.ignoreFields == null) opts.ignoreFields = [];
    	if (opts.file == null) throw new Error(&#x27;Missing parameter file!&#x27;);

    	if (callback == null) {
            callback = function (e) {
                if (e != null) {
                    // console.log(e.stack);
                }
            }
        }

    	try {
    		var base = this;

	    	var fname = opts.file;
			var storeName = opts.store;

			var fieldTypes = null;
			var store = null;
			var buff = [];

			var ignoreFields = {};
			for (var i = 0; i &amp;lt; opts.ignoreFields.length; i++)
				ignoreFields[opts.ignoreFields] = null;

			// read the CSV file and fill the store
			var headers = null;

			function transformLine(line) {
				var transformed = {};

				for (var i = 0; i &amp;lt; line.length; i++) {
					var header = headers[i];
					var value = line[i];

					if (fieldTypes != null &amp;amp;&amp;amp; fieldTypes[header] != null) {
						transformed[header] = fieldTypes[header] == &#x27;float&#x27; ? parseFloat(value) : value;
					} else {
						transformed[header] = (isNaN(value) || value.length == 0) ? value : parseFloat(value);
					}
				}

				return transformed;
			}

    		function initFieldTypes(data) {
    			if (fieldTypes == null) fieldTypes = {};

    			for (var key in data) {
    				var val = data[key];
    				if (fieldTypes[key] == null) {
    					if (val.length == 0)
    						fieldTypes[key] = null;
    					else if (isNaN(val))
    						fieldTypes[key] = &#x27;string&#x27;;
    					else
    						fieldTypes[key] = &#x27;float&#x27;;

    				}
    			}

    			if (fieldTypesInitialized()) {
    				// console.log(&#x27;Fields initialized: &#x27; + JSON.stringify(fieldTypes));
                }
    		}

    		function fieldTypesInitialized() {
    			if (fieldTypes == null) return false;

    			for (var key in fieldTypes) {
    				if (fieldTypes[key] == null)
    					return false;
    			}

    			return true;
    		}

			function getUninitializedFlds() {
    			var result = [];

    			for (var key in fieldTypes) {
    				if (fieldTypes[key] == null)
    					result.push(key);
    			}

    			return result;
    		}

			function createStore(rec) {
    			try {
	    			var storeDef = {
	    				name: storeName,
	    				fields: []
	    			};

	    			for (var fieldName in rec) {
	    				storeDef.fields.push({
							name: fieldName,
							type: fieldTypes[fieldName],
							&quot;null&quot;: true,
	    				});
	    			}

	    			// console.log(&#x27;Creating store with definition &#x27; + JSON.stringify(storeDef) + &#x27; ...&#x27;);

	    			base.createStore(storeDef);
	    			store = base.store(storeName);

	    			// insert all the record in the buffer into the store
	    			buff.forEach(function (data) {
	    				store.push(data);
	    			});
    			} catch (e) {
					callback(e);
    			}
    		}

			var storeCreated = false;
			var line = 0;
			// console.log(&#x27;Saving CSV to store &#x27; + storeName + &#x27; &#x27; + fname + &#x27; ...&#x27;);

			var fin = new fs.FIn(fname);
			fs.readCsvLines(fin, {
				onLine: function (lineArr) {
					try {
						if (line++ == 0) {	// the first line are the headers
							headers = [];
							for (var i = 0; i &amp;lt; lineArr.length; i++) {
								headers.push(lineArr[i].replace(/\s+/g, &#x27;_&#x27;).replace(/\.|%|\(|\)|\/|-|\+/g, &#x27;&#x27;)) 	// remove invalid characters
							}
							// console.log(&#x27;Headers initialized: &#x27; + JSON.stringify(headers));
						}
						else {
							if (line % 1000 == 0) {
								// console.log(line + &#x27;&#x27;);
                            }
                            
							var data = transformLine(lineArr);

							if (fieldTypes == null)
								initFieldTypes(data);

							if (store == null &amp;amp;&amp;amp; fieldTypesInitialized())
								createStore(data);
							else if (!fieldTypesInitialized())
								initFieldTypes(data);

							if (store != null) {
								store.push(data);
							} else
								buff.push(data);
						}
					} catch (e) {
						// console.log(&#x27;Exception while reading CSV lines: &#x27; + e.stack);
						callback(e);
					}
				},
				onEnd: function () {
					// finished
					// console.log(&#x27;Finished!&#x27;);

					if (callback != null) {
			   			if (!fieldTypesInitialized()) {
				   			var fieldNames = getUninitializedFlds();
				   			callback(new Error(&#x27;Finished with uninitialized fields: &#x27; +
								JSON.stringify(fieldNames)) + &#x27;, add them to ignore list!&#x27;);
				   			return;
				   		} else {
				   			callback(undefined, store);
				   		}
			   		}
				}
			});

			fin.close();
    	} catch (e) {
			callback(e);
    	}
    };

    //==================================================================
    // STORE
    //==================================================================

    /**
     * Adds a stream aggregate to a store.
     * @param {function} trigger - The trigger containing the method {@link module:qm.StreamAggr#onAdd} and optional
     * {@link module:qm.StreamAggr#onUpdate} and {@link module:qm.StreamAggr#onDelete}.
     */
    exports.Store.prototype.addTrigger = function (trigger) {
        // name is automatically generated
        // saveJson isn&#x27;t needed
        var Callbacks = {
            onAdd: trigger.onAdd,
            saveJson: function (limit) { return {}; }
        };
        if (trigger.onUpdate != undefined) { Callbacks[&quot;onUpdate&quot;] = trigger.onUpdate; }
        if (trigger.onDelete != undefined) { Callbacks[&quot;onDelete&quot;] = trigger.onDelete; }
        var streamAggr = new exports.StreamAggr(this.base, Callbacks, this.name);
    }

    /**
     * Adds a stream aggregate to the store. For use example see {@link module:qm.StreamAggr} constructor example.
     * @param {(module:qm~StreamAggregator | function)} arg - Constructor arguments. There are two argument types:
     * &amp;lt;br&gt;1. Using the {@link module:qm~StreamAggregator} object,
     * &amp;lt;br&gt;2. using a function/JavaScript class. The function has defined The object containing the schema of the stream aggregate or the function object defining the operations of the stream aggregate.
     */ 
    exports.Store.prototype.addStreamAggr = function (params) {
        return new exports.StreamAggr(this.base, params, this.name);
    }

    /**
     * Inspects the stores.
     * @param {number} depth - The depth of inspection. How many times to recurse while formatting the store object.
     * @returns {string} String representation of the store.
     */
    exports.Store.prototype.inspect = function (depth) {
        var d = (depth == null) ? 0 : depth;
        return util.inspect(this, { depth: d, &#x27;customInspect&#x27;: false });
    }

    /**
     * Load given file line by line, parse each line to JSON and push it to the store.
     * @param {String} file - Name of the JSON line file.
     * @param {Number} [limit] - Maximal number of records to load from file.
     * @returns {number} Number of records loaded from file.
     */
    exports.Store.prototype.loadJson = function (file, limit) {
        var fin = fs.openRead(file);
        var count = 0;
        while (!fin.eof) {
            var line = fin.readLine();
            if (line == &quot;&quot;) { continue; }
            try {
                var rec = JSON.parse(line);
                this.push(rec);
                // count, GC and report
                count++;
                if (limit != undefined &amp;amp;&amp;amp; count == limit) { break; }
            } catch (err) {
                throw new Error(&quot;Error parsing line number: &quot; + count + &quot;, line content:[&quot; + line + &quot;]: &quot; + err);                
            }
        }
        return count;
    }

    //==================================================================
    // RECORD SET
    //==================================================================

    /**
     * Stores the record set as a CSV file.
     *
     * @param {Object} opts - Arguments.
     * @property {String} opts.fname - Name of the output file.
     * @property {Boolean} [opts.includeHeaders = true] - Indicates wether to include the header in the first line.
     * @property {String} [opts.timestampType = &#x27;timestamp&#x27;] - Date format. Possible options: 
     * &amp;lt;br&gt;1. &#x60;&#x27;ISO&#x27;&#x60; - Datetime fields will be printed as ISO dates,
     * &amp;lt;br&gt;2. &#x60;&#x27;timestamp&#x27;&#x60; - Datetime fields will be printed as timestamps.
     * @property {String} [opts.escapeChar = &quot;] - Character which escapes quotes.
     */
    exports.RecSet.prototype.saveCsv = function (opts) {
    	if (opts == null || opts.fname == null) throw new Error(&#x27;Missing parameter fname!&#x27;);
    	if (opts.includeHeaders == null) opts.includeHeaders = true;
    	if (opts.timestampType == null) opts.timestampType = &#x27;timestamp&#x27;;
    	if (opts.escapeChar == null) opts.escapeChar = &#x27;&quot;&#x27;;

    	var escapeStr = opts.escapeChar + &#x27;&quot;&#x27;;
    	
    	// read field descriptions
    	var fields = this.store.fields;
    	var fieldDesc = [];
    	for (var i = 0; i &amp;lt; fields.length; i++) {
    		var desc = fields[i];
    		var type = desc.type;

    		if (type != &#x27;float&#x27; &amp;amp;&amp;amp; type != &#x27;int&#x27; &amp;amp;&amp;amp; type != &#x27;bool&#x27; &amp;amp;&amp;amp; type != &#x27;datetime&#x27; &amp;amp;&amp;amp;
    				type != &#x27;string&#x27;)
    			throw new Error(&#x27;Invalid field type: &#x27; + type);
    		if (desc.internal) continue;

    		fieldDesc.push({name: desc.name, type: desc.type});
    	}

    	var nFields = fieldDesc.length;
    	var useTimestamp = opts.timestampType != &#x27;ISO&#x27;;

    	var fout = new fs.FOut(opts.fname);

    	// write the headers
    	if (opts.includeHeaders) {
    		var headerLine = &#x27;&#x27;;
    		for (var i = 0; i &amp;lt; nFields; i++) {
    			headerLine += &#x27;&quot;&#x27; + fieldDesc[i].name.replace(/&quot;/g, escapeStr) + &#x27;&quot;&#x27;;
    			if (i &amp;lt; nFields - 1)
    				headerLine += &#x27;,&#x27;;
    		}
    		fout.writeLine(headerLine);
    	}

    	// write the lines
    	var len = this.length;
    	var recN = 0;
    	this.each(function (rec) {
    		var line = &#x27;&#x27;;
    		for (var i = 0; i &amp;lt; nFields; i++) {
    			var fldVal = rec[fieldDesc[i].name];
    			var type = fieldDesc[i].type;

    			if (fldVal != null) {
	    			if (type == &#x27;float&#x27; || type == &#x27;int&#x27; || type == &#x27;bool&#x27;) {
	    				line += fldVal;
	    			} else if (type == &#x27;datetime&#x27;) {
	    				line += useTimestamp ? fldVal.getTime() : fldVal.toISOString();
	    			} else if (type == &#x27;string&#x27;) {
	    				line += &#x27;&quot;&#x27; + fldVal.replace(/&quot;/g, escapeStr) + &#x27;&quot;&#x27;;
	    			} else {
	    				throw new Error(&#x27;Invalid type of field: &#x27; + type);
	    			}
    			}

    			if (i &amp;lt; nFields - 1)
    				line += &#x27;,&#x27;;
    		}

    		if (recN++ &amp;lt; len - 1)
    			fout.writeLine(line);
    		else
    			fout.write(line);
    	});

    	fout.flush();
    	fout.close();
    }

    //==================================================================
    // CIRCULAR RECORD BUFFER
    //==================================================================

    /**
    * @classdesc Circular buffer for storing records. Size of buffer is defined at
    * start and is denoted in number of records. When buffer is full, old records
    * are removed from the buffer and new records are stored in their place. For
    * adding and deleting a callback is called. Records are stored by their IDs.
    * @class
    * @param {Object} [params] - Constructor parameters.
    * @param {module:qm.Store} param.store - Store for the records in the buffer.
    * @param {number} param.size - Size of the buffer (number of records).
    * @param {function} [param.onAdd] - Callback executed when new record is
    * added to the buffer. Callback is give two parameters: 
    * &amp;lt;br&gt;&#x60;rec&#x60; - The record. Type {@link module:qm.Record}.
    * &amp;lt;br&gt;&#x60;circRecBuff&#x60; - The circular record buffer instance. Type {@link module:qm.CircularRecordBuffer}.
    * @param {function} [param.onDelete] - Callback executed when record is removed
    * from the buffer. Callback is give two parameters:
    * &amp;lt;br&gt;&#x60;rec&#x60; - The record. Type {@link module:qm.Record}.
    * &amp;lt;br&gt;&#x60;circRecBuff&#x60; - The circular record buffer instance. Type {@link module:qm.CircularRecordBuffer}.
    * @example
	* // TODO
    */
    exports.CircularRecordBuffer = function (params) {
        // check we have all encessary parameters
        if (params.store == undefined) { throw new Error(&quot;CircularRecordBuffer requires store in constructor&quot;); }
        if (!(params.store instanceof qm.Store)) { throw new Error(&quot;CircularRecordBuffer requires store in constructor&quot; + params.store); }
        if (params.size == undefined) { throw new Error(&quot;CircularRecordBuffer requires size in constructor&quot;); }
        if (!(params.size &gt;= 1)) { throw new Error(&quot;CircularRecordBuffer positive size in constructor&quot;); }
        // parameters
        this.store = params.store;
        this.size = params.size;
        this.buffer = new qm.la.IntVector();
        this.next = 0;
        // Callbacks
        this.onAdd = (params.onAdd == undefined) ? function () {} : params.onAdd;
        this.onDelete = (params.onDelete == undefined) ? function () {} : params.onDelete;

        /**
        * Load circular buffer from input stream. Assumes store, onAdd and onDelete
        * were already initialized in constructor.
        * @param {module:fs.FIn} fin - input stream.
        * @example 
        * // TODO
        */
        this.load = function (fin) {
            var finParam = fin.readJson();
            this.size = finParam.size;
            this.next = finParam.next;
            this.buffer.load(fin);
        }

        /**
        * Saves circular buffer to the output stream. Does not save store, onAdd
        * and onDelete callbacks.
        * @param {module:fs.FOut} fout - Output stream.
        * @returns {module:fs.FOut} The output stream &#x60;fout&#x60;.
        * @example
        * // TODO
        */
        this.save = function (fout) {
            fout.writeJson({
                size: this.size,
                next: this.next
            });
            this.buffer.save(fout);
            return fout;
        }

        /**
    	* Add new record to the buffer.
        * @param {module:qm.Record} rec - New record.
        * @example
        * // TODO
    	*/
        this.push = function (rec) {
            if (this.buffer.length &amp;lt; this.size) {
                // we did not fill buffer yet, just add new element
                this.buffer.push(rec.$id);
                this.onAdd(rec, this);
            } else {
                // we are full, first delete the oldest record.
                var oldRec = this.store[this.buffer[this.next]];
                this.onDelete(oldRec, this);
                // remember new record
                this.buffer[this.next] = rec.$id;
                this.onAdd(rec, this);
                // move pointer to the oldest record forwards
                this.next++;
                if (this.next == this.size) { this.next = 0; }
            }
        }
    }

    //==================================================================
    // FEATURE SPACE
    //==================================================================

    //#- &#x60;qm.FeatureSpace.getSparseVectorFeatures(spVec)&#x60; -- Return array of feature
	//#  names based on feature space &#x60;fsp&#x60; where the elements of a sparse feature
	//#  vector &#x60;spVec&#x60; are non-zero.
    exports.FeatureSpace.prototype.getSparseVectorFeatures = function (spVec) {
        // get index vector
        var idxVec = spVec.idxVec();
        var cols = [];
        for (var elN = 0; elN &amp;lt; idxVec.length; elN++) {
            cols.push(this.getFeature(idxVec[elN]));
        }
        return cols;
    }

    //==================================================================
    // EXPORTS
    //==================================================================

    // deprecated, here for backwards compatibility
    exports.load = function () {
        var _obj = {};
        _obj.jsonFileLimit = function (store, file, limit) {
            return store.loadJson(file, limit);
        }
        _obj.jsonFile = function (store, file) {
            return store.loadJson(file);
        }
        return _obj;
    }();

    exports.delLock = function () {
        if (nodefs.existsSync(&#x27;lock&#x27;)) {
            try {
                nodefs.unlinkSync(&#x27;lock&#x27;);
            } catch (e) {
                console.log(e);
            }
        }
    }

    exports.rmDir = function (dirPath) {
        try { var files = nodefs.readdirSync(dirPath); }
        catch (e) { return; }
        if (files.length &gt; 0)
            for (var i = 0; i &amp;lt; files.length; i++) {
                var filePath = dirPath + &#x27;/&#x27; + files[i];
                if (nodefs.statSync(filePath).isFile())
                    nodefs.unlinkSync(filePath);
                else
                    rmDir(filePath);
            }
        nodefs.rmdirSync(dirPath);
    };

	function forbidConstructor(obj) {
		proto = obj.prototype;
		obj = function () {throw  new Error(&#x27;constructor is private, &#x27; + obj.prototype.constructor.name +  &#x27; is factory based.&#x27;);}
		obj.prototype = proto;
		return obj;
	}

	// Forbids constructors that would crash node - these objects are factory constructed
	exports.Store = forbidConstructor(exports.Store);
	exports.RecSet = forbidConstructor(exports.RecSet);

    
</code></pre>
            </article>
                                        </div>
                                </div>
                                <nav id="jsdoc-toc-nav" role="navigation"></nav>
                        </div>
                </div>
                    <footer id="jsdoc-footer" class="jsdoc-footer">
                            <div id="jsdoc-footer-container">
                                    <p>
                                      
                                    </p>
                            </div>
                    </footer>
                <script src="scripts/jquery.min.js"></script>
                <script src="scripts/jquery.cookie.js"></script>
                <script src="scripts/tree.jquery.js"></script>
                <script src="scripts/prettify.js"></script>
                <script src="scripts/jsdoc-toc.js"></script>
                <script src="scripts/linenumber.js"></script>
                <script src="scripts/scrollanchor.js"></script>
        </body>
</html>
