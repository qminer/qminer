<!doctype html>
<html>
        <head>
                <meta name="generator" content="JSDoc 3">
                <meta charset="utf-8">
                <title>Source: ladoc.js</title>
                <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Karla:400,400i,700,700i" type="text/css">
                <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Noto+Serif:400,400i,700,700i" type="text/css">
                <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Inconsolata:500" type="text/css">
                <link href="css/baseline.css" rel="stylesheet">
        </head>
        <body onload="prettyPrint()">
                <nav id="jsdoc-navbar" role="navigation" class="jsdoc-navbar">
    <div id="jsdoc-navbar-container">
        <div id="jsdoc-navbar-content">
            <a href="index.html" class="jsdoc-navbar-package-name">Home</a>
        </div>
    </div>
</nav>

                <div id="jsdoc-body-container">
                        <div id="jsdoc-content">
                                <div id="jsdoc-content-container">
                                        <div id="jsdoc-banner" role="banner">
                                        </div>
                                        <div id="jsdoc-main" role="main">
            <header class="page-header">
                <h1>Source: ladoc.js</h1>
            </header>
            <article>
                <pre class="prettyprint linenums"><code>/**
 * Copyright (c) 2015, Jozef Stefan Institute, Quintelligence d.o.o. and contributors
 * All rights reserved.
 *
 * This source code is licensed under the FreeBSD license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
* Linear algebra module.
* @module la
* @example
* // import la module
* var la &#x3D; require(&#x27;qminer&#x27;).la;
* // create a random matrix
* var mat &#x3D; new la.Matrix({ rows: 10, cols: 5, random: true });
* // create a vector
* var vec &#x3D; new la.Vector([1, 2, 3, 0, -1]);
* // multiply the matrix and vector
* var vec2 &#x3D; mat.multiply(vec);
* // calculate the svd decomposition of the matrix
* var svd &#x3D; la.svd(mat, 3);
*/
/**
    * Computes the truncated SVD decomposition.
    * @param {module:la.Matrix | module:la.SparseMatrix} mat - The matrix.
    * @param {number} k - The number of singular vectors to be computed.
    * @param {Object} [json] - The JSON object.
    * @param {number} [json.iter &#x3D; 100] - The number of iterations used for the algorithm.
    * @param {number} [json.tol &#x3D; 1e-6] - The tolerance number.
    * @param {function} [callback] - The callback function, that takes the error parameters (err) and the result parameter (res).
    * &amp;lt;i&gt;Only for the asynchronous function.&amp;lt;/i&gt;
    * @returns {Object} The JSON object &#x60;svdRes&#x60; which contains the SVD decomposition U*S*V^T matrices:
    * &amp;lt;br&gt;&#x60;svdRes.U&#x60; - The dense matrix of the decomposition. Type {@link module:la.Matrix}.
    * &amp;lt;br&gt;&#x60;svdRes.V&#x60; - The dense matrix of the decomposition. Type {@link module:la.Matrix}.
    * &amp;lt;br&gt;&#x60;svdRes.s&#x60; - The vector containing the singular values of the decomposition. Type {@link module:la.Vector}.
    * @example &amp;lt;caption&gt;Asynchronous function&amp;lt;/caption&gt;
    * // import the modules
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a random matrix
    * var A &#x3D; new la.Matrix({ rows: 10, cols: 5, random: true });
    * // set the parameters for the calculation
    * var k &#x3D; 2; // number of singular vectors
    * var param &#x3D; { iter: 1000, tol: 1e-4 };
    * // calculate the svd
    * la.svd(A, k, param, function (err, result) {
    *    if (err) { console.log(err); }
    *    // successful calculation
    *    var U &#x3D; result.U;
    *    var V &#x3D; result.V;
    *    var s &#x3D; result.s;
    * });
    * @example &amp;lt;caption&gt;Synchronous function&amp;lt;/caption&gt;
    * // import the modules
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a random matrix
    * var A &#x3D; new la.Matrix({ rows: 10, cols: 5, random: true });
    * // set the parameters for the calculation
    * var k &#x3D; 2; // number of singular vectors
    * var param &#x3D; { iter: 1000, tol: 1e-4 };
    * // calculate the svd
    * var result &#x3D; la.svd(A, k, param);
    * // successful calculation
    * var U &#x3D; result.U;
    * var V &#x3D; result.V;
    * var s &#x3D; result.s;
    */
 exports.prototype.svd &#x3D; function (mat, k, json) { return { U: Object.create(require(&#x27;qminer&#x27;).la.Matrix.prototype), V: Object.create(require(&#x27;qminer&#x27;).la.Matrix.prototype), s: Object.create(require(&#x27;qminer&#x27;).la.Vector.prototype) } }
/**
    * Computes the QR decomposition.
    * @param {module:la.Matrix} mat - The matrix.
    * @param {number} [tol &#x3D; 1e-6] - The tolerance number.
    * @returns {Object} A JSON object &#x60;qrRes&#x60; which contains the decomposition matrices:
    * &amp;lt;br&gt;&#x60;qrRes.Q&#x60; - The orthogonal matrix Q of the QR decomposition. Type {@link module:la.Matrix}.
    * &amp;lt;br&gt;&#x60;qrRes.R&#x60; - The upper triangular matrix R of the QR decomposition. Type {@link module:la.Matrix}.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a random matrix
    * var mat &#x3D; new la.Matrix({ rows: 10, cols: 5, random: true });
    * // calculate the QR decomposition of mat
    * var qrRes &#x3D; la.qr(mat);
    */
 exports.prototype.qr &#x3D; function (mat, tol) { return { Q: Object.create(require(&#x27;qminer&#x27;).la.Matrix.prototype), R: Object.create(require(&#x27;qminer&#x27;).la.Matrix.prototype) } }

/**
 * Copyright (c) 2015, Jozef Stefan Institute, Quintelligence d.o.o. and contributors
 * All rights reserved.
 *
 * This source code is licensed under the FreeBSD license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
* Matrix constructor parameter object.
* @typedef {Object} matrixArg
* @property {number} rows - Number of rows.
* @property {number} cols - Number of columns.
* @property {boolean} [random&#x3D;false] - Generate a random matrix with entries sampled from a uniform [0,1] distribution. If set to false, a zero matrix is created.
*/
/**
* Matrix class.
* @classdesc Represents a dense matrix (2d array), wraps a C++ object implemented in glib/base/ds.h.
* @class
* @param {(module:la~matrixArg | Array&amp;lt;Array&amp;lt;number&gt;&gt; | module:la.Matrix)} [arg] - Constructor arguments. There are three ways of constructing:
* &amp;lt;br&gt;1. Using the parameter object {@link module:la~matrixArg},
* &amp;lt;br&gt;2. using a nested array of matrix elements (row major). Example: [[1,2],[3,4]] has two rows, the first row is [1,2],
* &amp;lt;br&gt;3. using a dense matrix (copy constructor).
* @example
* // import la module
* var la &#x3D; require(&#x27;qminer&#x27;).la;
* // create new matrix with matrixArg
* var mat &#x3D; new la.Matrix({&quot;rows&quot;: 3, &quot;cols&quot;: 2, &quot;random&quot;: true}); // creates a 3 x 2 matrix with random values
* // create a new matrix with nested arrays
* var mat2 &#x3D; new la.Matrix([[1, 7, 4], [-10, 0, 3]]); // creates a 2 x 3 matrix with the designated values
*/
 exports.Matrix &#x3D; function(arg) { return Object.create(require(&#x27;qminer&#x27;).la.Matrix.prototype); }
/**
    * Returns an element of matrix.
    * @param {number} rowIdx - Row index (zero based).
    * @param {number} colIdx - Column index (zero based).
    * @returns {number} The matrix element.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new matrix
    * var mat &#x3D; new la.Matrix([[2, 3], [-2, -2], [-3, 1]]);
    * // get the value at the index (2, 1)
    * var value &#x3D; mat.at(2, 1); // returns the value 1
    */
 exports.Matrix.prototype.at &#x3D; function(rowIdx, colIdx) { return 0.0; }
/**
    * Sets an element or a block of matrix.
    * @param {number} rowIdx - Row index (zero based).
    * @param {number} colIdx - Column index (zero based).
    * @param {(number | module:la.Matrix)} arg - A number or a matrix. If arg is of type {@link module:la.Matrix}, it gets copied, where the argument&#x27;s upper left corner, &amp;lt;code&gt;arg.at(0,0)&amp;lt;/code&gt;, gets copied to position (&amp;lt;code&gt;rowIdx&amp;lt;/code&gt;, &amp;lt;code&gt;colIdx&amp;lt;/code&gt;).
    * @returns {module:la.Matrix} Self. The (&amp;lt;code&gt;rowIdx&amp;lt;/code&gt;, &amp;lt;code&gt;colIdx&amp;lt;/code&gt;) value/block is changed.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new matrix
    * var mat &#x3D; new la.Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]);
    * var arg &#x3D; new la.Matrix([[10, 11], [12, 13]]);
    * mat.put(0, 1, arg);
    * // updates the matrix to
    * // 1  10  11
    * // 4  12  13
    * // 7   8   9
    */
 exports.Matrix.prototype.put &#x3D; function(rowIdx, colIdx, arg) { return Object.create(require(&#x27;qminer&#x27;).la.Matrix.prototype); }
/**
    * Right-hand side multiplication of matrix with parameter.
    * @param {(number | module:la.Vector | module:la.SparseVector | module:la.Matrix | module:la.SparseMatrix)} arg - Multiplication input. Supports scalar, vector and matrix input.
    * @returns {(module:la.Matrix | module:la.Vector)}
    * &amp;lt;br&gt;1. {@link module:la.Matrix}, if &amp;lt;code&gt;arg&amp;lt;/code&gt; is a number, {@link module:la.Matrix} or {@link module:la.SparseMatrix}.
    * &amp;lt;br&gt;2. {@link module:la.Vector}, if &amp;lt;code&gt;arg&amp;lt;/code&gt; is a {@link module:la.Vector} or {@link module:la.SparseVector}.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new matrix
    * var mat &#x3D; new la.Matrix([[1, 2], [-1, 5]]);
    * // create a new vector
    * var vec &#x3D; new la.Vector([1, -1]);
    * //multiply mat and vec
    * var vec2 &#x3D; mat.multiply(vec); // returns vector [-1, -6]
    */
 exports.Matrix.prototype.multiply &#x3D; function(arg) { return (arg instanceof require(&#x27;qminer&#x27;).la.Vector | arg instanceof require(&#x27;qminer&#x27;).la.SparseVector) ? Object.create(require(&#x27;qminer&#x27;).la.Vector.prototype) : Object.create(require(&#x27;qminer&#x27;).la.Matrix.prototype); }
/**
    * Matrix transpose and right-hand side multiplication of matrix with parameter.
    * @param {(number | module:la.Vector | module:la.SparseVector | module:la.Matrix | module:la.SparseMatrix)} arg - Multiplication input. Supports scalar, vector and matrix input.
    * @returns {(module:la.Matrix | module:la.Vector)}
    * &amp;lt;br&gt;1. {@link module:la.Matrix}, if &amp;lt;code&gt;arg&amp;lt;/code&gt; is a number, {@link module:la.Matrix} or a {@link module:la.SparseMatrix}.
    * &amp;lt;br&gt;2. {@link module:la.Vector}, if &amp;lt;code&gt;arg&amp;lt;/code&gt; is a {@link module:la.Vector} or a {@link module:la.SparseVector}.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new matrix
    * var mat &#x3D; new la.Matrix([[1, 2], [-1, 5]]);
    * // create a new vector
    * var vec &#x3D; new la.Vector([1, -1]);
    * //multiply mat and vec
    * var vec2 &#x3D; mat.multiplyT(vec); // returns vector [2, -3]
    */
 exports.Matrix.prototype.multiplyT &#x3D; function(arg) { return (arg instanceof require(&#x27;qminer&#x27;).la.Vector | arg instanceof require(&#x27;qminer&#x27;).la.SparseVector) ? Object.create(require(&#x27;qminer&#x27;).la.Vector.prototype) : Object.create(require(&#x27;qminer&#x27;).la.Matrix.prototype); }
/**
    * Adds two matrices.
    * @param {module:la.Matrix} mat - The second matrix.
    * @returns {module:la.Matrix} The sum of the matrices.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create two matrices
    * var mat &#x3D; new la.Matrix([[1, 2], [-1, 5]]);
    * var mat2 &#x3D; new la.Matrix([[1, -1], [3, 2]]);
    * // add the matrices
    * // the return matrix is
    * // 2   1
    * // 2   7
    * var sum &#x3D; mat.plus(mat2);
    */
 exports.Matrix.prototype.plus &#x3D; function(mat2) { return Object.create(require(&#x27;qminer&#x27;).la.Matrix.prototype); }
/**
    * Substracts two matrices.
    * @param {module:la.Matrix} mat - The second matrix.
    * @returns {module:la.Matrix} The difference of the matrices.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create two matrices
    * var mat &#x3D; new la.Matrix([[1, 2], [-1, 5]]);
    * var mat2 &#x3D; new la.Matrix([[1, -1], [3, 2]]);
    * // substract the matrices
    * // the return matrix is
    * //  0   3
    * // -4   3
    * var diff &#x3D; mat.minus(mat2);
    */
 exports.Matrix.prototype.minus &#x3D; function(mat2) { return Object.create(require(&#x27;qminer&#x27;).la.Matrix.prototype); }
/**
    * Transposes the matrix.
    * @returns {module:la.Matrix} Transposed matrix.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a matrix
    * var mat &#x3D; new la.Matrix([[2, -5], [3, 1]]);
    * // transpose the matrix
    * // the return matrix is
    * //  2   3
    * // -5   1
    * var trans &#x3D; mat.transpose();
    */
 exports.Matrix.prototype.transpose &#x3D; function() { return Object.create(require(&#x27;qminer&#x27;).la.Matrix.prototype); }
/**
    * Solves the linear system.
    * @param {module:la.Vector} vec - The right-hand side of the equation.
    * @returns {module:la.Vector} The solution of the linear system.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new matrix
    * var M &#x3D; new la.Matrix([[1, 2], [-1, -5]]);
    * // create a new vector
    * var b &#x3D; new la.Vector([-1, -6]);
    * // solve the linear system M*x &#x3D; b
    * var x &#x3D; M.solve(b); // returns vector [1, -1]
    */
 exports.Matrix.prototype.solve &#x3D; function (vec) { return Object.create(require(&#x27;qminer&#x27;).la.Vector.prototype); }
/**
    * Calculates the matrix row norms.
    * @returns {module:la.Vector} Vector, where the value at i-th index is the norm of the i-th row of matrix.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new matrix
    * var mat &#x3D; new la.Matrix([[3, 4], [4, 15/2]]);
    * // get the row norms of the matrix
    * var rowNorms &#x3D; mat.rowNorms(); // returns the vector [5, 17/2]
    */
 exports.Matrix.prototype.rowNorms &#x3D; function () { return Object.create(require(&#x27;qminer&#x27;).la.Vector.prototype); }
/**
    * Calculates the matrix column norms.
    * @returns {module:la.Vector} Vector, where the value at i-th index is the norm of the i-th column of matrix.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new matrix
    * var mat &#x3D; new la.Matrix([[3, 4], [4, 15/2]]);
    * // get the row norms of the matrix
    * var rowNorms &#x3D; mat.colNorms(); // returns the vector [5, 17/2]
    */
 exports.Matrix.prototype.colNorms &#x3D; function () { return Object.create(require(&#x27;qminer&#x27;).la.Vector.prototype); }
/**
    * Normalizes each column of matrix.
    * @returns {module:la.Matrix} Self. The columns of matrix are normalized.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new matrix
    * var mat &#x3D; new la.Matrix([[3, 4], [4, 15/2]]);
    * // normalize the columns of the matrix
    * // the matrix is going to be of the form:
    * // 3/5     8/17
    * // 4/5    15/17
    * mat.normalizeCols();
    */
 exports.Matrix.prototype.normalizeCols &#x3D; function () { return Object.create(require(&#x27;qminer&#x27;).la.Matrix.prototype); }
/**
    * Returns the matrix as string.
    * @returns {string} Dense matrix as string.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new matrix
    * var mat &#x3D; new la.Matrix([[1, 2], [3, 5]]);
    * // get matrix as string
    * var text &#x3D; mat.toString(); // returns &#x60;1 2 \n3 5 \n\n&#x60;
    */
 exports.Matrix.prototype.toString &#x3D; function () { return &quot;&quot;; }
/**
    * Transforms the matrix from dense to sparse format.
    * @returns {module:la.SparseMatrix} Sparse column matrix representation of dense matrix.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create the matrix
    * var mat &#x3D; new la.Matrix([[1, 2], [0, 3], [-4, 0]]);
    * // transform the matrix into the sparse form
    * var spMat &#x3D; mat.sparse();
    */
 exports.Matrix.prototype.sparse &#x3D; function () { return Object.create(require(&#x27;qminer&#x27;).la.SparseMatrix.prototype); }
/**
    * Returns the frobenious norm of matrix.
    * @returns {number} Frobenious norm of matrix.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create the matrix
    * var mat &#x3D; new la.Matrix([[1, 2], [3, 4]]);
    * // get the frobenious norm of the matrix
    * var frob &#x3D; mat.frob(); // returns the value Math.sqrt(30)
    */
 exports.Matrix.prototype.frob &#x3D; function () { return 0.0; }
/**
    * Gives the number of rows of matrix. Type &#x60;number&#x60;.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create the matrix
    * var mat &#x3D; new la.Matrix([[1, 2], [3, 1], [-4, 5]]);
    * // get the number of rows
    * var rowN &#x3D; mat.rows; // returns 3
    */
 exports.Matrix.prototype.rows &#x3D; 0;
/**
    * Gives the number of columns of matrix. Type &#x60;number&#x60;.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create the matrix
    * var mat &#x3D; new la.Matrix([[1, 2], [3, 1], [-4, 5]]);
    * // get the number of cols
    * var colsN &#x3D; mat.cols; // returns 2
    */
 exports.Matrix.prototype.cols &#x3D; 0;
/**
    * Gives the index of the maximum element in the given row.
    * @param {number} rowIdx - Row index (zero based).
    * @returns {number} Column index (zero based) of the maximum value in the &amp;lt;code&gt;rowIdx&amp;lt;/code&gt;-th row of matrix.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create the matrix
    * var mat &#x3D; new la.Matrix([[1, 2], [3, 1], [-4, 5]]);
    * // get the column id of the maximum value of the second row
    * var maxRow &#x3D; mat.rowMaxIdx(1); // returns the value 0
    */
 exports.Matrix.prototype.rowMaxIdx &#x3D; function (rowIdx) { return 0; }
/**
    * Gives the index of the maximum element in the given column.
    * @param {number} colIdx - Column index (zero based).
    * @returns {number} Row index (zero based) of the maximum value in &amp;lt;code&gt;colIdx&amp;lt;/code&gt;-th column of matrix.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create the matrix
    * var mat &#x3D; new la.Matrix([[1, 2], [3, 1], [-4, 5]]);
    * // get the row id of the maximum value of the second column
    * var maxRow &#x3D; mat.colMaxIdx(1); // returns the value 2
    */
 exports.Matrix.prototype.colMaxIdx &#x3D; function (colIdx) { return 0; }
/**
    * Returns the corresponding column of matrix as vector.
    * @param {number} colIdx - Column index (zero based).
    * @returns {module:la.Vector} The &amp;lt;code&gt;colIdx&amp;lt;/code&gt;-th column of matrix.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create the matrix
    * var mat &#x3D; new la.Matrix([[1, 2], [3, 1], [-4, 5]]);
    * // get the second column of the matrix
    * var col &#x3D; mat.getCol(1);
    */
 exports.Matrix.prototype.getCol &#x3D; function (colIdx) { return Object.create(require(&#x27;qminer&#x27;).la.Vector.prototype); }
/**
    * Sets the column of the matrix.
    * @param {number} colIdx - Column index (zero based).
    * @param {module:la.Vector} vec - The new column of matrix.
    * @returns {module:la.Matrix} Self. The &amp;lt;code&gt;colIdx&amp;lt;/code&gt;-th column is changed.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a matrix
    * var mat &#x3D; new la.Matrix([[1, -3, 2], [9, 2, -4],  [-2, 3, 3]]);
    * // create a vector
    * var vec &#x3D; new la.Vector([-3, 2, 2]);
    * // set the first column of the matrix with the vector
    * // the changed matrix is now
    * // -3   -3    2
    * //  2    2   -4
    * //  2    3    3
    * mat.setCol(0, vec);
    */
 exports.Matrix.prototype.setCol &#x3D; function (colIdx, vec) { return Object.create(require(&#x27;qminer&#x27;).la.Matrix.prototype); }
/**
    * Gets the submatrix from the column ids.
    * @param {module:la.IntVector} intVec - The vector containing the column ids.
    * @returns {module:la.Matrix} The submatrix containing the the columns of the original matrix.
    * @example
    * //import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a random matrix
    * var mat &#x3D; new la.Matrix({ rows: 10, cols: 10, random: true });
    * // get the submatrix containing the 1, 2 and 4 column
    * var submat &#x3D; mat.getColSubmatrix(new la.IntVector([0, 1, 3]));
    */
 exports.Matrix.prototype.getColSubmatrix &#x3D; function (intVec) { return Object.create(require(&#x27;qminer&#x27;).la.Matrix.prototype); }
/**
    * Gets the submatrix from the column ids.
    * @param {number} minRow - The minimum row index.
    * @param {number} maxRow - The maximum row index.
    * @param {number} minCol - The minimum column index.
    * @param {number} maxCol - The maximum column index.
    * @returns {module:la.Matrix} The submatrix of the original matrix.
    * @example
    * //import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a random matrix
    * var mat &#x3D; new la.Matrix({ rows: 10, cols: 10, random: true });
    * // get the submatrix containing from the position (1, 2) to (7, 4)
    * var submat &#x3D; mat.getSubmatrix(1, 7, 2, 4);
    */
 exports.Matrix.prototype.getSubmatrix &#x3D; function (minRow, maxRow, minCol, maxCol) { return Object.create(require(&#x27;qminer&#x27;).la.Matrix.prototype); }
/**
    * Returns the corresponding row of matrix as vector.
    * @param {number} rowIdx - Row index (zero based).
    * @returns {module:la.Vector} The &amp;lt;code&gt;rowIdx&amp;lt;/code&gt;-th row of matrix.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create the matrix
    * var mat &#x3D; new la.Matrix([[1, 2], [3, 1], [-4, 5]]);
    * // get the first row of the matrix
    * var row &#x3D; mat.getRow(1);
    */
 exports.Matrix.prototype.getRow &#x3D; function (rowIdx) { return Object.create(require(&#x27;qminer&#x27;).la.Vector.prototype); }
/**
    * Sets the row of matrix.
    * @param {number} rowIdx - Row index (zero based).
    * @param {module:la.Vector} vec - The new row of matrix.
    * @returns {module:la.Matrix} Self. The &amp;lt;code&gt;rowIdx&amp;lt;/code&gt;-th row is changed.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a matrix
    * var mat &#x3D; new la.Matrix([[1, -3, 2], [9, 2, -4],  [-2, 3, 3]]);
    * // create a vector
    * var vec &#x3D; new la.Vector([-3, 2, 2]);
    * // set the first row of the matrix with the vector
    * // the changed matrix is now
    * // -3    2    2
    * //  9    2   -4
    * // -2    3    3
    * mat.setRow(0, vec);
    */
 exports.Matrix.prototype.setRow &#x3D; function (rowIdx, vec) { return Object.create(require(&#x27;qminer&#x27;).la.Matrix.prototype); }
/**
    * Returns the diagonal elements of matrix.
    * @returns {module:la.Vector} Vector containing the diagonal elements.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new matrix
    * var mat &#x3D; new la.Matrix([[1, -1, 0], [15, 8, 3], [0, 1, 0]]);
    * // call diag function
    * var vec &#x3D; mat.diag(); // returns a vector [1, 8, 0]
    */
 exports.Matrix.prototype.diag &#x3D; function () { return Object.create(require(&#x27;qminer&#x27;).la.Vector.prototype); }
/**
    * Saves the matrix as output stream.
    * @param {module:fs.FOut} fout - Output stream.
    * @returns {module:fs.FOut} The output stream &amp;lt;code&gt;fout&amp;lt;/code&gt;.
    * @example
    * // import the modules
    * var fs &#x3D; require(&#x27;qminer&#x27;).fs;
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create new matrix
    * var mat &#x3D; new la.Matrix([[1, 2], [3, 4]]);
    * // open write stream
    * var fout &#x3D; fs.openWrite(&#x27;mat.dat&#x27;);
    * // save matrix and close write stream
    * mat.save(fout).close();
    */
 exports.Matrix.prototype.save &#x3D; function (fout) { return Object.create(require(&#x27;qminer&#x27;).fs.FOut.prototype); }
/**
    * Loads the matrix from input stream.
    * @param {module:fs.FIn} fin - Input stream.
    * @returns {module:la.Matrix} Self. It is made out of the input stream &amp;lt;code&gt;fin&amp;lt;/code&gt;.
    * @example
    * // import the modules
    * var fs &#x3D; require(&#x27;qminer&#x27;).fs;
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create an empty matrix
    * var mat &#x3D; new la.Matrix();
    * // open a read stream (&#x27;mat.dat&#x27; is pre-saved)
    * var fin &#x3D; fs.openRead(&#x27;mat.dat&#x27;);
    * // load the matrix
    * mat.load(fin);
    */
 exports.Matrix.prototype.load &#x3D; function (FIn) { return Object.create(require(&#x27;qminer&#x27;).la.Matrix.prototype); }
/**
* Sparse Vector.
* @classdesc Sparse vector is an array of (int,double) pairs that represent column indices and values.
* @class
* @param {(Array&amp;lt;Array&amp;lt;number&gt;&gt; | module:la.SparseVector)} [arg] - Constructor arguments. There are two ways of constructing:
* &amp;lt;br&gt;1. Using a nested array of vector elements. Example: &#x60;[[0, 2],[2, 3]]&#x60; has two nonzero values, first value is 2 at position 0, second value is 3 at position 2,
* &amp;lt;br&gt;2. using a sparse vector (copy constructor).
* @param {number} [dim] - Maximum length of sparse vector. &amp;lt;i&gt;It is only in combinantion with nested array of vector elements.&amp;lt;/i&gt;
* @example
* // import la module
* var la &#x3D; require(&#x27;qminer&#x27;).la;
* // create new sparse vector with arrays
* var spVec &#x3D; new la.SparseVector([[0, 1], [2, 3], [3, 6]]); // sparse vector [1, 0, 3, 6]
* // create new sparse vector with dim
* var spVec2 &#x3D; new la.SparseVector([[0, 1], [2, 3], [3, 6]], 5); // largest index (zero based) is 4
*/
 exports.SparseVector &#x3D; function(arg, dim) { return Object.create(require(&#x27;qminer&#x27;).la.SparseVector.prototype); }
/**
    * Returns an element of the sparse vector.
    * @param {number} idx - Index (zero based).
    * @returns {number} Sparse vector element.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a sparse vector
    * var vec &#x3D; new la.SparseVector([[0, 1], [3, 2], [4, -5]]);
    * // get the value at the position 3
    * vec.at(3); // returns the value 2
    */
 exports.SparseVector.prototype.at &#x3D; function (idx) { return 0.0; }
/**
    * Puts a new element in sparse vector.
    * @param {number} idx - Index (zero based).
    * @param {number} num - Input value.
    * @returns {module:la.SparseVector} Self. It puts/changes the values with the index &#x60;idx&#x60; to the value &#x60;num&#x60;.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new sparse vector
    * var vec &#x3D; new la.SparseVector([[0, 1], [3, 2], [4, -5]]);
    * // set the new values at position 2
    * vec.put(2, -4);
    */
 exports.SparseVector.prototype.put &#x3D; function (idx, num) { return Object.create(require(&#x27;qminer&#x27;).la.SparseVector.prototype); }
/**
    * Returns the sum of all values in sparse vector.
    * @returns {number} The sum of all values in sparse vector.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new sparse vector
    * var vec &#x3D; new la.SparseVector([[0, 1], [3, 2], [4, -5]]);
    * // get the sum of the values in the vector
    * vec.sum(); // returns -2
    */
 exports.SparseVector.prototype.sum &#x3D; function () { return 0.0; }
/**
    * Returns the inner product of the parameter and the sparse vector.
    * @param {(module:la.Vector | module:la.SparseVector)} arg - The inner product input.
    * @returns {number} The inner product of the two vectors.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create two vectors, one sparse and one dense
    * var sparse &#x3D; new la.SparseVector([[0, 1], [3, 2], [4, -5]]);
    * var dense &#x3D; new la.Vector([3, -4, 2, 0.5, -1]);
    * // get the inner product of the vectors
    * sparse.inner(dense); // returns the value 9
    */
 exports.SparseVector.prototype.inner &#x3D; function (arg) { return 0.0; }
/**
    * Multiplies the sparse vector with a scalar.
    * @param {number} num - The scalar.
    * @returns {module:la.SparseVector} The product of &#x60;num&#x60; and sparse vector.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new sparse vector
    * var spVec &#x3D; new la.SparseVector([[0, 1], [2, 3], [3, 6]]);
    * // multiply sparse vector with scalar 3.14
    * var spVec2 &#x3D; spVec.multiply(3.14); // returns sparse vector [3.14, 0, 9.42, 18.84]
    */
 exports.SparseVector.prototype.multiply &#x3D; function (num) { return Object.create(require(&#x27;qminer&#x27;).la.SparseVector.prototype); }
/**
    * Normalizes the sparse vector.
    * @returns {module:la.SparseVector} Self. The vector is normalized.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new sparse vector
    * var spVec &#x3D; new la.SparseVector([[0, 1], [2, 3], [3, 6]]);
    * // normalize the sparse vector
    * spVec.normalize();
    */
 exports.SparseVector.prototype.normalize &#x3D; function () { return Object.create(require(&#x27;qminer&#x27;).la.SparseVector.prototype); }
/**
    * Returns the number of non-zero values. Type &#x60;number&#x60;.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new sparse vector
    * var vec &#x3D; new la.SparseVector([[0, 2], [3, 1], [7, 5], [11, 4]]);
    * // check the number of nonzero values in sparse vector
    * // returns 4
    * var nonz &#x3D; vec.nnz;
    */
 exports.SparseVector.prototype.nnz &#x3D; 0;
/**
    * Returns the dimension of sparse vector. Type &#x60;number&#x60;.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new sparse vector and designate the dimension of the vector
    * var vec &#x3D; new la.SparseVector([[0, 2], [3, 1], [7, 5], [11, 4]], 15);
    * // get the dimension of the sparse vector
    * // returns 15
    * var dim &#x3D; vec.dim;
    */
 exports.SparseVector.prototype.dim &#x3D; 0;
/**
    * Returns the norm of sparse vector.
    * @returns {number} Norm of sparse vector.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new sparse vector
    * var vec &#x3D; new la.SparseVector([[0, 2], [3, 1], [7, 5], [11, 4]]);
    * // get the norm of the vector
    * var norm &#x3D; vec.norm();
    */
 exports.SparseVector.prototype.norm &#x3D; function () { return 0.0; }
/**
    * Returns the dense vector representation of the sparse vector.
    * @returns {module:la.Vector} The dense vector representation.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new sparse vector
    * var vec &#x3D; new la.SparseVector([[0, 2], [3, 1], [7, 5], [11, 4]]);
    * // create a dense representation of the vector
    * var dense &#x3D; vec.full();
    */
 exports.SparseVector.prototype.full &#x3D; function () { return Object.create(require(&#x27;qminer&#x27;).la.Vector.prototype); }
/**
    * Returns a dense vector of values of non-zero elements of sparse vector.
    * @returns {module:la.Vector} A dense vector of values.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new sparse vector
    * var vec &#x3D; new la.SparseVector([[0, 2], [3, 1], [7, 5], [11, 4]]);
    * // get the non-zero values of the sparse vector
    * var valVec &#x3D; vec.valVec();
    */
 exports.SparseVector.prototype.valVec &#x3D; function () { return Object.create(require(&#x27;qminer&#x27;).la.Vector.prototype); }
/**
    * Returns a dense vector of indices (zero based) of non-zero elements of sparse vector.
    * @returns {module:la.Vector} A dense vector of indeces.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new sprase vector
    * var vec &#x3D; new la.SparseVector([[0, 2], [3, 1], [7, 5], [11, 4]]);
    * // get the non-zero indeces of the sparse vector
    * var idxVec &#x3D; vec.idxVec();
    */
 exports.SparseVector.prototype.idxVec &#x3D; function () { return Object.create(require(&#x27;qminer&#x27;).la.Vector.prototype); }
/**
    * Returns the string representation.
    * @returns {string} The string representation of the sparse vector.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new sparse vector
    * var spVec &#x3D; new la.SparseVector([[0, 1], [2, 3]]);
    * // get the string representation of the vector
    * spVec.toString(); // returns the string &#x27;[(0, 1), (2, 3)]&#x27;
    */
 exports.SparseVector.prototype.toString &#x3D; function () { return &quot;&quot;; }
/**
* Sparse Matrix
* @classdesc Sparse Matrix is represented as a dense vector of sparse vectors which correspond to matrix columns.
* @class
* @param {(Array&amp;lt;Array&amp;lt;Array&amp;lt;number&gt;&gt;&gt; | module:la.SparseMatrix)} [arg] - Constructor arguments. There are two ways of constructing:
* &amp;lt;br&gt;1. using a nested array of sparse vectors (columns). A sparse vector is a nested array of pairs, first value is index, second is value. Example: [[[0, 2]], [[0, 1], [2, 3]]] has 2 columns.
* The second non-zero element in second column has a value 3 at index 2,
* &amp;lt;br&gt;2. using a sparse matrix (copy constructor).
* @param {number} [rows] - Maximal number of rows in sparse vector. &amp;lt;i&gt;It is only in combinantion with nested array of vector elements.&amp;lt;/i&gt;
* @example
* // import la module
* var la &#x3D; require(&#x27;qminer&#x27;).la;
* // create a new sparse matrix with array
* var mat &#x3D; new la.SparseMatrix([[[0, 2]], [[0, 1], [2, 3]]]);
* // create a new sparse matrix with specified max rows
* var mat2 &#x3D; new la.SparseMatrix([[[0, 2]], [[0, 1], [2, 3]]], 3);
*/
 exports.SparseMatrix &#x3D; function(arg) { return Object.create(require(&#x27;qminer&#x27;).la.SparseMatrix.prototype); }
/**
    * Returns an element of the sparse matrix at the given location.
    * @param {number} rowIdx - Row index (zero based).
    * @param {number} colIdx - Column index (zero based).
    * @returns {number} Matrix value.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a sparse matrix
    * var mat &#x3D; new la.SparseMatrix([[[0, 2]], [[0, 1], [2, 3]]]);
    * // get the value at the position (1, 1)
    * mat.at(1, 1); // returns 3
    */
 exports.SparseMatrix.prototype.at &#x3D; function (rowIdx, colIdx) { return 0.0; }
/**
    * Puts an element in sparse matrix.
    * @param {number} rowIdx - Row index (zero based).
    * @param {number} colIdx - Column index (zero based).
    * @param {number} num - Element value.
    * @returns {module:la.SparseMatrix} Self. The value at position (&#x60;rowIdx&#x60;, &#x60;colIdx&#x60;) is changed.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new sparse matrix
    * var mat &#x3D; new la.SparseMatrix([[[0, 3], [1, 2]], [[1, -2], [3, 4]], [[10, 8]]]);
    * // set the value at position (2, 2) to -4
    * mat.put(2, 2, -4);
    */
 exports.SparseMatrix.prototype.put &#x3D; function (rowIdx, colIdx, num) { return Object.create(require(&#x27;qminer&#x27;).la.SparseMatrix.prototype); }
/**
    * Returns the column of the sparse matrix.
    * @param {number} colIdx - The column index (zero based).
    * @returns {module:la.SparseVector} Sparse vector corresponding to the &#x60;colIdx&#x60;-th column of sparse matrix.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a sparse matrix
    * var mat &#x3D; new la.SparseMatrix([[[0, 3], [1, 2]], [[1, -2], [3, 4]], [[10, 8]]]);
    * // get the first column as a vector
    * var first &#x3D; mat.getCol(0); // returns the first column of the sparse matrix
    */
 exports.SparseMatrix.prototype.getCol &#x3D; function (colIdx) { return Object.create(require(&#x27;qminer&#x27;).la.SparseVector.prototype); }
/**
    * Sets a column in sparse matrix.
    * @param {number} colIdx - Column index (zero based).
    * @param {module:la.SparseVector} spVec - The new column sparse vector.
    * @returns {module:la.SparseMatrix} Self. The &#x60;colIdx&#x60;-th column has been replaced with &#x60;spVec&#x60;.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new sparse matrix
    * var mat &#x3D; new la.SparseMatrix([[[0, 3], [1, 2]], [[1, -2], [3, 4]], [[10, 8]]]);
    * // create a new sparse vector to replace the third column
    * var vec &#x3D; new la.SparseVector([[0, 3], [2, -5]]);
    * // set the third column of mat to vec
    * mat.setCol(2, vec); // returns mat with the third column changed
    */
 exports.SparseMatrix.prototype.setCol &#x3D; function (colIdx, spVec) { return Object.create(require(&#x27;qminer&#x27;).la.SparseVector.prototype); }
/**
    * Attaches a column to the sparse matrix.
    * @param {module:la.SparseVector} spVec - Attached column as sparse vector.
    * @returns {module:la.SparseMatrix} Self. The last column is now the added &#x60;spVec&#x60; and the number of columns is now bigger by one.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new sparse vector
    * var mat &#x3D; new la.SparseMatrix([[[0, 2], [3, 5]], [[1, -3]]]);
    * // create a new vector
    * var vec &#x3D; new la.SparseVector([[0, 2], [2, -3]]);
    * // push the newly created vector to the matrix
    * // the new matrix is going to be (in sparse form)
    * // 2    0    2
    * // 0   -3    0
    * // 0    0   -3
    * // 5    0    0
    * mat.push(vec);
    */
 exports.SparseMatrix.prototype.push &#x3D; function (spVec) { return Object.create(require(&#x27;qminer&#x27;).la.SparseMatrix.prototype); }
/**
    * Multiplies argument with sparse maatrix.
    * @param {(number | module:la.Vector | module:la.SparseVector | module:la.Matrix | module:la.SparseMatrix)} arg - Multiplication input.
    * @returns {(module:la.Vector | module:la.Matrix)}
    * &amp;lt;br&gt;1. {@link module:la.Matrix}, if &#x60;arg&#x60; is number, {@link module:la.Matrix} or {@link module:la.SparseMatrix}.
    * &amp;lt;br&gt;2. {@link module:la.Vector}, if &#x60;arg&#x60; is {@link module:la.Vector} or {@link module:la.SparseVector}.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create new sparse matrix
    * var mat &#x3D; new la.SparseMatrix([[[0, 2], [3, 5]], [[1, -3]]]);
    * // create a vector
    * var vec &#x3D; new la.Vector([3, -2]);
    * // multiply the matrix and vector
    * var vec2 &#x3D; mat.multiply(vec);
    */
 exports.SparseMatrix.prototype.multiply &#x3D; function (arg) { return (arg instanceof require(&#x27;qminer&#x27;).la.Vector | arg instanceof require(&#x27;qminer&#x27;).la.SparseVector) ? Object.create(require(&#x27;qminer&#x27;).la.Vector.prototype) : Object.create(require(&#x27;qminer&#x27;).la.Matrix.prototype); }
/**
    * Sparse matrix transpose and multiplies with argument.
    * @param {(number | module:la.Vector | module:la.SparseVector | module:la.Matrix | module:la.SparseMatrix)} arg - Multiplication input.
    * @returns {(module:la.Vector | module:la.Matrix)}
    * &amp;lt;br&gt;1. {@link module:la.Matrix}, if &#x60;arg&#x60; is number, {@link module:la.Matrix} or {@link module:la.SparseMatrix}.
    * &amp;lt;br&gt;2. {@link module:la.Vector}, if &#x60;arg&#x60; is {@link module:la.Vector} or {@link module:la.SparseVector}.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create new sparse matrix
    * var mat &#x3D; new la.SparseMatrix([[[0, 2], [3, 5]], [[1, -3]]]);
    * // create a dense matrix
    * var mat2 &#x3D; new la.Matrix([[0, 1], [2, 3], [4, 5], [-1, 3]]);
    * // transpose mat and multiply it with mat2
    * var mat3 &#x3D; mat.multiplyT(mat2);
    */
 exports.SparseMatrix.prototype.multiplyT &#x3D; function (arg) { return (arg instanceof require(&#x27;qminer&#x27;).la.Vector | arg instanceof require(&#x27;qminer&#x27;).la.SparseVector) ? Object.create(require(&#x27;qminer&#x27;).la.Vector.prototype) : Object.create(require(&#x27;qminer&#x27;).la.Matrix.prototype); }
/**
    * Addition of two matrices.
    * @param {module:la.SparseMatrix} mat - The second sparse matrix.
    * @returns {module:la.SparseMatrix} Sum of the two sparse matrices.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create two sparse matrices
    * var mat &#x3D; new la.SparseMatrix([[[0, 1], [3, 2]], [[1, -3]]]);
    * var mat2 &#x3D; new la.SparseMatrix([[[0, 3]],[[2, 1]]]);
    * // get the sum of the two matrices
    * // returns the sum ( insparse form)
    * // 4    0
    * // 0   -3
    * // 0    1
    * // 2    0
    * var sum &#x3D; mat.plus(mat2);
    */
 exports.SparseMatrix.prototype.plus &#x3D; function (spMat) { return Object.create(require(&#x27;qminer&#x27;).la.SparseMatrix.prototype); }
/**
    * Substraction of two matrices.
    * @param {module:la.SparseMatrix} mat - The second sparse matrix.
    * @returns {module:la.SparseMatrix} The difference of the two sparse matrices.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create two sparse matrices
    * var mat &#x3D; new la.SparseMatrix([[[0, 1], [3, 2]], [[1, -3]]]);
    * var mat2 &#x3D; new la.SparseMatrix([[[0, 3]],[[2, 1]]]);
    * // get the sum of the two matrices
    * // returns the sum ( insparse form)
    * // -2    0
    * //  0   -3
    * //  0   -1
    * //  2    0
    * var diff &#x3D; mat.minus(mat2);
    */
 exports.SparseMatrix.prototype.minus &#x3D; function (spMat) { return Object.create(require(&#x27;qminer&#x27;).la.SparseMatrix.prototype); }
/**
    * Returns the transposed sparse matrix.
    * @returns {module:la.SparseMatrix} Transposed sparse matrix.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new sparse matrix
    * var mat &#x3D; new la.SparseMatrix([[[0, 2], [2, -3]], [[1, 1], [3, -2]]]);
    * // transpose the sparse matrix
    * // returns the transposed matrix (in sparse form)
    * // 2    0   -3    0
    * // 0    1    0   -2
    * mat.transpose();
    */
 exports.SparseMatrix.prototype.transpose &#x3D; function () { return Object.create(require(&#x27;qminer&#x27;).la.SparseMatrix.prototype); }
/**
    * Returns a submatrix containing only selected columns.
    * Columns are identified by a vector of ids.
    * @param {module:la.IntVector} columnIdVec - Integer vector containing selected column ids.
    * @returns {module:la.SparseMatrix} The submatrix containing the the columns of the original matrix.
    * @example
    * //import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new sparse matrix
    * var mat &#x3D; new la.SparseMatrix([[[0, 2], [2, -3]], [[1, 1], [3, -2]]]);
    * // get the submatrix containing the 1, 2 and 4 column
    * var submat &#x3D; mat.getColSubmatrix(new la.IntVector([1]));
    */
 exports.SparseMatrix.prototype.getColSubmatrix &#x3D; function (columnIdVec) { return Object.create(require(&#x27;qminer&#x27;).la.SparseMatrix.prototype); }
/**
    * Clear content of the matrix and sets its row dimension to -1.
    * @returns {module:la.SparseMatrix} Self. All the content has been cleared.
    * @example
    * //import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new sparse matrix
    * var mat &#x3D; new la.SparseMatrix([[[0, 2], [2, -3]], [[1, 1], [3, -2]]]);
    * // clear the matrix
    * mat.clear();
    */
 exports.SparseMatrix.prototype.clear &#x3D; function () { return Object.create(require(&#x27;qminer&#x27;).la.SparseMatrix.prototype); }
/**
    * Returns the vector of column norms of sparse matrix.
    * @returns {module:la.Vector} Vector of column norms. Ihe i-th value of the return vector is the norm of i-th column of sparse matrix.
    * @example
    * //import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new sparse matrix
    * var mat &#x3D; new la.SparseMatrix([[[0, 2], [2, -3]], [[1, 1], [3, -2]]]);
    * // get the column norms
    * var norms &#x3D; mat.colNorms();
    */
 exports.SparseMatrix.prototype.colNorms &#x3D; function () { return Object.create(require(&#x27;qminer&#x27;).la.Vector.prototype); }
/**
    * Normalizes columns of sparse matrix.
    * @returns {module:la.SparseMatrix} Self. The columns of the sparse matrix are normalized.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new sparse matrix
    * var mat &#x3D; new la.SparseMatrix([[[0, 2]], [[0, 1], [2, 3]]]);
    * // normalize matrix columns
    * // The new matrix elements are:
    * // 1  0.316227
    * // 0  0
    * // 0  0.948683
    * mat.normalizeCols();
    */
 exports.SparseMatrix.prototype.normalizeCols &#x3D; function () { return Object.create(require(&#x27;qminer&#x27;).la.SparseMatrix.prototype); }
/**
    * Returns the dense representation of sparse matrix.
    * @returns {module:la.Matrix} Dense representation of sparse matrix.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new sparse matrix
    * var mat &#x3D; new la.SparseMatrix([[[0, 2]], [[0, 1], [2, 3]]]);
    * // create a dense representation of sparse matrix
    * // returns the dense matrix:
    * // 2  1
    * // 0  0
    * // 0  3
    * mat.full();
    */
 exports.SparseMatrix.prototype.full &#x3D; function () { return Object.create(require(&#x27;qminer&#x27;).la.Matrix.prototype); }
/**
    * Returns the frobenious norm of sparse matrix.
    * @returns {number} Frobenious norm of sparse matrix.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new sparse matrix
    * var mat &#x3D; new la.SparseMatrix([[[0, 1], [1, 3]], [[0, 2], [1, 4]]]);
    * // get the frobenious norm of sparse matrix
    * var norm &#x3D; mat.frob(); // returns sqrt(30)
    */
 exports.SparseMatrix.prototype.frob &#x3D; function () { return 0.0; }
/**
    * Gives the number of rows of sparse matrix. Type &#x60;number&#x60;.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new sparse matrix
    * var mat &#x3D; new la.SparseMatrix([[[0, 2]], [[0, 1], [2, 3]]]);
    * // check the number of rows in sparse matrix
    * mat.rows;
    */
 exports.SparseMatrix.prototype.rows &#x3D; 0;
/**
    * Gives the number of columns of sparse matrix. Type &#x60;number&#x60;.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new sparse matrix
    * var mat &#x3D; new la.SparseMatrix([[[0, 2]], [[0, 1], [2, 3]]]);
    * // check the number of columns in sparse matrix
    * mat.cols;
    */
 exports.SparseMatrix.prototype.cols &#x3D; 0;
/**
    * Prints sparse matrix on screen.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new sparse matrix
    * var spMat &#x3D; new la.SparseMatrix([[[0, 1]], [[0, 3], [1, 8]]]);
    * // print sparse matrix on screen
    * // each row represents a nonzero element, where first value is row index, second
    * // value is column index and third value is element value. For this matrix:
    * // 0  0  1.000000
    * // 0  1  3.000000
    * // 1  1  8.000000
    * spMat.print();
    */
 exports.SparseMatrix.prototype.print &#x3D; function () {}
/**
    * Saves the sparse matrix as output stream.
    * @param {module:fs.FOut} fout - Output stream.
    * @param {boolean} [saveMatlab&#x3D;false] - If true, saves using matlab three column text format. Otherwise, saves using binary format.
    * @returns {module:fs.FOut} The output stream &#x60;fout&#x60;.
    * @example
    * // import the modules
    * var fs &#x3D; require(&#x27;qminer&#x27;).fs;
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new sparse matrix
    * var mat &#x3D; new la.SparseMatrix([[[0, 1]], [[0, 3], [1, 12]]]);
    * // open write stream
    * var fout &#x3D; fs.openWrite(&#x27;mat.dat&#x27;);
    * // save matrix and close write stream
    * mat.save(fout).close();
    */
 exports.SparseMatrix.prototype.save &#x3D; function (fout, saveMatlab) { return Object.create(require(&#x27;qminer&#x27;).fs.FOut.prototype); }
/**
    * Loads the sparse matrix from input stream.
    * @param {module:fs.FIn} fin - Input stream.
    * @returns {module:la.Matrix} Self. The content has been loaded using &#x60;fin&#x60;.
    * @example
    * // import the modules
    * var fs &#x3D; require(&#x27;qminer&#x27;).fs;
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create an empty matrix
    * var mat &#x3D; new la.SparseMatrix();
    * // open a read stream (&#x27;mat.dat&#x27; was previously created)
    * var fin &#x3D; fs.openRead(&#x27;mat.dat&#x27;);
    * // load the matrix
    * mat.load(fin);
    */
 exports.SparseMatrix.prototype.load &#x3D; function (FIn) { return Object.create(require(&#x27;qminer&#x27;).la.SparseMatrix.prototype); }
/**
    * Sets the row dimension.
    * @param {number} rowDim - Row dimension.
    * @example
    * // import the modules
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create an empty matrix
    * var mat &#x3D; new la.SparseMatrix();
    * mat.setRowDim(2);
    * mat.rows // prints 2
    */
 exports.SparseMatrix.prototype.setRowDim &#x3D; function (rowDim) { }


    /**
    * Calculates the frobenious norm squared of the matrix.
    * @returns {number} Frobenious norm squared.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a sparse matrix
    * var spMat &#x3D; new la.SparseMatrix([[[0, 1], [1, 5]], [[0, 2], [2, -3]]]);
    * // get the forbenious norm squared of the sparse matrix
    * var frob &#x3D; spMat.frob2();
    */
    exports.SparseMatrix.prototype.frob2 &#x3D; function () {
        return Math.pow(this.frob(), 2);
    }

    /**
    * Returns a string displaying rows, columns and number of non-zero elements of sparse matrix.
    * @returns {string} String displaying row, columns and number of non-zero elements.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new sparse matrix
    * var mat &#x3D; new la.SparseMatrix([[[0, 1]], [[0, 2], [1, 8]]]);
    * // create the string
    * var text &#x3D; mat.toString(); // returns &#x27;rows: -1, cols: 2, nnz: 3&#x27;
    */
    exports.SparseMatrix.prototype.toString &#x3D; function () { return &quot;rows: &quot; + this.rows + &quot;, cols:&quot; + this.cols + &quot;, nnz: &quot; + this.nnz(); }

    /**
    * Returns the number of non-zero elements of sparse matrix.
    * @returns {number} Number of non-zero elements.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a sparse matrix
    * var spMat &#x3D; new la.SparseMatrix([[[0, 1], [1, 5]], [[0, 2], [2, -3]]]);
    * // get the number of non-zero elements
    * // returns 4
    * var nnz &#x3D; spMat.nnz(); 
    */
    exports.SparseMatrix.prototype.nnz &#x3D; function () {
        var nnz &#x3D; 0;
        //iterate over matrix and sum nnz of each column
        for (var colN &#x3D; 0; colN &amp;lt; this.cols; colN++) {
            nnz +&#x3D; this[colN].nnz;
        }
        return nnz;
    };

    /**
	* Prints the sparse vector on-screen.
	* @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
	* // create a new sparse vector
	* var spVec &#x3D; new la.SparseVector([[0, 1], [2, 3]]);
	* // print sparse vector
	* spVec.print(); // shows on-screen [(0, 1), (2, 3)]
	*/
    exports.SparseVector.prototype.print &#x3D; function () { console.log(this.toString()); }

    /**
	* Prints the matrix on-screen.
	* @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
	* // create a new matrix
	* var mat &#x3D; new la.Matrix([[1, 2], [3, 4]]);
	* // print the matrix
    * // each row represents a row in the matrix. For this example:
    * // 1  2
    * // 3  4
	* mat.print();
	*/
    exports.Matrix.prototype.print &#x3D; function () { console.log(this.toString()); }

	/**
	* Returns a copy of the matrix.
	* @returns {module:la.Matrix} Matrix copy.
    * @example 
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a random matrix
    * var mat &#x3D; new la.Matrix({ rows: 5, cols: 4, random: true });
    * // create a copy of the matrix
    * var copy &#x3D; mat.toMat();
	*/
	exports.Matrix.prototype.toMat &#x3D; function () { return new exports.Matrix(this); }

	/**
    * Prints the vector on-screen.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.Vector([1, 2, 3]);
    * // print the vector
    * // For this example it prints:
    * // [1, 2, 3]
    * vec.print();
    */
	exports.Vector.prototype.print &#x3D; function () { console.log(this.toString()); }


    function vec2arr(vec) {
    	var len &#x3D; vec.length;
        var arr &#x3D; [];
        for (var elN &#x3D; 0; elN &amp;lt; len; elN++) {
            arr[elN] &#x3D; vec[elN];
        }
        return arr;
    }

	/**
    * Copies the vector into a JavaScript array of numbers.
    * @returns {Array.&amp;lt;number&gt;} A JavaScript array of numbers.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.Vector([1, 2, 3]);
    * // create a JavaScript array out of vec
    * var arr &#x3D; vec.toArray(); // returns an array [1, 2, 3]
    */
    exports.Vector.prototype.toArray &#x3D; function () {
        return vec2arr(this);
	}
	/**
    * Copies the vector into a JavaScript array of numbers.
    * @returns {Array.&amp;lt;number&gt;} A JavaScript array of integers.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new integer vector
    * var vec &#x3D; new la.IntVector([1, 2, 3]);
    * // create a JavaScript array out of vec
    * var arr &#x3D; vec.toArray(); // returns an array [1, 2, 3] 
    */
	exports.IntVector.prototype.toArray &#x3D; function () {
        return vec2arr(this);
	}
	/**
    * Copies the vector into a JavaScript array of strings.
    * @returns {Array.&amp;lt;string&gt;} A JavaScript array of strings.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.StrVector([&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]);
    * // create a JavaScript array out of vec
    * var arr &#x3D; vec.toArray(); // returns an array [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]
    */
	exports.StrVector.prototype.toArray &#x3D; function () {
        return vec2arr(this);
	}
	/**
    * Copies the vector into a JavaScript array of booleans.
    * @returns {Array.&amp;lt;boolean&gt;} A JavaScript array of booleans.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.BoolVector([true, false, true]);
    * // create a JavaScript array out of vec
    * var arr &#x3D; vec.toArray(); // returns an array [true, false, true]
    */
	exports.BoolVector.prototype.toArray &#x3D; function () {
        return vec2arr(this);
	}

	/**
    * Copies the matrix into a JavaScript array of arrays of numbers.
    * @returns {Array&amp;lt;Array&amp;lt;number&gt;&gt;} A JavaScript array of arrays of numbers.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new matrix
    * var mat &#x3D; new la.Matrix([[1, 2], [3, 4]]);
    * // create a JavaScript array out of matrix
    * var arr &#x3D; mat.toArray(); // returns an array [[1, 2], [3, 4]]
    */
    exports.Matrix.prototype.toArray &#x3D; function () {
        var rows &#x3D; this.rows;
		var cols &#x3D; this.cols;
        var arr &#x3D; [];
        for (var i &#x3D; 0; i &amp;lt; rows; i++) {
			var arr_row &#x3D; [];
			for (var j &#x3D; 0; j &amp;lt; cols; j++) {
				arr_row.push(this.at(i, j));
			}
            arr.push(arr_row);
        }
        return arr;
	}

    /**
    * Copies the vector into a JavaScript array of numbers.
    * @param {module:la.Vector} vec - Copied vector.
    * @returns {Array&amp;lt;number&gt;} A JavaScript array of numbers.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.Vector([1, 2, 3]);
    * // create a JavaScript array out of vec
    * var arr &#x3D; la.copyVecToArray(vec); // returns an array [1, 2, 3]
    */
    exports.copyVecToArray &#x3D; function (vec) { return vec.toArray(); };

    function isInt(value) {
        return !isNaN(value) &amp;amp;&amp;amp;
               parseInt(Number(value)) &#x3D;&#x3D; value &amp;amp;&amp;amp;
               !isNaN(parseInt(value, 10));
    }

    ///////// RANDOM GENERATORS

    /**
    * Returns an object with random numbers.
    * @param {number} [arg1] - Represents dimension of vector or number of rows in matrix. Must be an integer.
    * @param {number} [arg2] - Represents number of columns in matrix. Must be an integer.
    * @returns {(number | module:la.Vector | module:la.Matrix)}
    * &amp;lt;br&gt;1. Number, if no parameters are given.
    * &amp;lt;br&gt;2. {@link module:la.Vector}, if parameter &#x60;arg1&#x60; is given.
    * &amp;lt;br&gt;3. {@link module:la.Matrix}, if parameters &#x60;arg1&#x60; and &#x60;arg2&#x60; are given.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // generate a random number
    * var number &#x3D; la.randn();
    * // generate a random vector of length 7
    * var vector &#x3D; la.randn(7);
    * // generate a random matrix with 7 rows and 10 columns
    * var mat &#x3D; la.randn(7, 10);
    */
    exports.randn &#x3D; function (arg1, arg2) {
        //arguments.length
        var len &#x3D; arguments.length;
        if (len &#x3D;&#x3D;&#x3D; 0) {
            var x1, x2, rad, y1;
            do {
                x1 &#x3D; 2 * Math.random() - 1;
                x2 &#x3D; 2 * Math.random() - 1;
                rad &#x3D; x1 * x1 + x2 * x2;
            } while (rad &gt;&#x3D; 1 || rad &#x3D;&#x3D; 0);
            var c &#x3D; Math.sqrt(-2 * Math.log(rad) / rad);
            return x1 * c;
        } else if (len &#x3D;&#x3D;&#x3D; 1) {
            var dim &#x3D; arguments[0];
            assert(isInt(dim));
            var vec &#x3D; new exports.Vector({ &quot;vals&quot;: dim });
            for (var elN &#x3D; 0; elN &amp;lt; dim; elN++) {
                vec.put(elN, exports.randn());
            }
            return vec;
        } else if (len &#x3D;&#x3D;&#x3D; 2) {
            var rows &#x3D; arguments[0];
            var cols &#x3D; arguments[1];
            assert(isInt(rows));
            assert(isInt(cols));
            var mat &#x3D; new exports.Matrix({ &quot;cols&quot;: cols, &quot;rows&quot;: rows });
            for (var colN &#x3D; 0; colN &amp;lt; cols; colN++) {
                for (var rowN &#x3D; 0; rowN &amp;lt; rows; rowN++) {
                    mat.put(rowN, colN, exports.randn());
                }
            }
            return mat;
        }
    };

    /**
    * Returns a randomly selected integer(s) from an array.
    * @param {number} num - The upper bound of the array. Must be an integer.
    * @param {number} [len] - The number of selected integers. Must be an integer.
    * @returns {(number | la.IntVector)}
    * &amp;lt;br&gt;1. Randomly selected integer from the array &#x60;[0,...,num-1]&#x60;, if no parameters are given.
    * &amp;lt;br&gt;2. {@link module:la.IntVector}, if parameter &#x60;len&#x60; is given. The vector contains random integers from the array &#x60;[0,...,num-1]&#x60; (with repetition).
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // generate a random integer between 0 and 10
    * var number &#x3D; la.randi(10);
    * // generate an integer vector containing 5 random integers between 0 and 10
    * var vec &#x3D; la.randi(10, 5);
    */
    exports.randi &#x3D; function () {
        var len &#x3D; arguments.length;
        if (len &#x3D;&#x3D;&#x3D; 1) {
            var n &#x3D; arguments[0];
            assert(isInt(n), &quot;one integer argument expected&quot;);
            return Math.floor((Math.random() * n));
        } else if (len &#x3D;&#x3D; 2) {
            var n &#x3D; arguments[0];
            var size &#x3D; arguments[1];
            assert(isInt(n), &quot;integer argument[0] expected&quot;);
            assert(isInt(size), &quot;integer argument[1] expected&quot;);
            var result &#x3D; new exports.IntVector({ &quot;vals&quot;: size });
            for (var i &#x3D; 0; i &amp;lt; size; i++) {
                result[i] &#x3D; Math.floor((Math.random() * n));
            }
            return result;
        } else {
            throw new Error(&quot;one integer argument expected&quot;);
        }
    };

    /**
    * Returns a JavaScript array, which is a sample of integers from an array.
    * @param {number} n - The upper bound of the generated array &#x60;[0,...,n-1]&#x60;. Must be an integer.
    * @param {number} k - Length of the sample. Must be smaller or equal to &#x60;n&#x60;.
    * @returns {Array&amp;lt;number&gt;} The sample of &#x60;k&#x60; numbers from &#x60;[0,...,n-1]&#x60;, sampled without replacement.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create an array containing 5 integers between 0 and 15
    * var arr &#x3D; la.randVariation(15, 5);
    */
    exports.randVariation &#x3D; function (n, k) {
        var n &#x3D; arguments[0];
        var k &#x3D; arguments[1];
        assert(isInt(n));
        assert(isInt(k));
        var perm &#x3D; exports.copyVecToArray(exports.randPerm(n));
        var idx &#x3D; perm.slice(0, k);
        return idx;
    };

    /**
    * Returns a permutation of elements.
    * @param {number} k - Number of elements to permutate.
    * @returns {Array&amp;lt;number&gt;} A JavaScript array of integers. Represents a permutation of &#x60;k&#x60; elements.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create an array/permutation of 5 elements
    * var perm &#x3D; la.randPerm(5);
    */
    exports.randPerm &#x3D; function (k) {
        assert(isInt(k));
        // gaussian random vector
        var vec &#x3D; exports.randn(k);
        var res &#x3D; vec.sortPerm();
        return res.perm;
    };

    ///////// COMMON MATRICES

    /**
    * Returns an dense identity matrix.
    * @param {number} dim - The dimension of the identity matrix. Must be a positive integer.
    * @returns {module:la.Matrix} A &#x60;dim&#x60;-by-&#x60;dim&#x60; identity matrix.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // generate a dense identity matrix of dimension 5
    * var id &#x3D; la.eye(5);
    */
    exports.eye &#x3D; function(dim) {
        var identity &#x3D; new exports.Matrix({ &quot;rows&quot;: dim, &quot;cols&quot;: dim });
        for (var rowN &#x3D; 0; rowN &amp;lt; identity.rows; rowN++) {
            identity.put(rowN, rowN, 1.0);
        }
        return identity;
    };

    /**
    * Returns a sparse identity matrix
    * @param {number} dim - The dimension of the identity matrix. Must be a positive integer.
    * @returns {module:la.SparseMatrix} A dim-by-dim identity matrix.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // generate a sparse identity matrix of dimension 5
    * var spId &#x3D; la.speye(5);
    */
    exports.speye &#x3D; function (dim) {
        var vec &#x3D; exports.ones(dim);
        return vec.spDiag();
    };

    /**
    * Returns a sparse zero matrix.
    * @param {number} rows - Number of rows of the sparse matrix.
    * @param {number} [cols &#x3D; rows] - Number of columns of the sparse matrix.
    * @returns {module:la.SparseMatrix} A &#x60;rows&#x60;-by-&#x60;cols&#x60; sparse zero matrix.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a sparse zero matrix with 5 rows and columns
    * var spMat &#x3D; la.sparse(5);
    */
    exports.sparse &#x3D; function (rows, cols) {
        cols &#x3D; typeof cols &#x3D;&#x3D; &#x27;undefined&#x27; ? rows : cols;
        var spmat &#x3D; new exports.SparseMatrix({ &quot;rows&quot;: rows, &quot;cols&quot;: cols });
        return spmat;
    };

    /**
    * Returns a dense zero matrix.
    * @param {number} rows - Number of rows of the matrix.
    * @param {number} [cols &#x3D; rows] - Number of columns of the matrix.
    * @returns {module:la.Matrix} A &#x60;rows&#x60;-by-&#x60;cols&#x60; dense zero matrix.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a sparse zero matrix with 5 rows and 3 columns
    * var mat &#x3D; la.zeros(5, 3);
    */
    exports.zeros &#x3D; function (rows, cols) {
        cols &#x3D; typeof cols &#x3D;&#x3D; &#x27;undefined&#x27; ? rows : cols;
        var mat &#x3D; new exports.Matrix({ &quot;rows&quot;: rows, &quot;cols&quot;: cols });
        return mat;
    };

    /**
    * Returns a vector with all entries set to 1.0.
    * @param {number} dim - Dimension of the vector.
    * @returns {module:la.Vector} A &#x60;dim&#x60;-dimensional vector whose entries are set to 1.0.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a 3-dimensional vector with all entries set to 1.0
    * var vec &#x3D; la.ones(3);
    */
    exports.ones &#x3D; function(k) {
        var ones_k &#x3D; new exports.Vector({ &quot;vals&quot;: k });
        for (var i &#x3D; 0; i &amp;lt; k; i++) {
            ones_k.put(i, 1.0);
        }
        return ones_k;
    };

    /**
    * Constructs a matrix by concatenating a double-nested array of matrices.
    * @param {Array&amp;lt;Array&amp;lt;module:la.Matrix&gt;&gt; } nestedArrMat - An array of block rows, where each block row is an array of matrices.
    * For example: &#x60;[[m_11, m_12], [m_21, m_22]]&#x60; is used to construct a matrix where the (i,j)-th block submatrix is &#x60;m_ij&#x60;.
    * @returns {module:la.Matrix} Concatenated matrix.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create four matrices and concatenate (2 block columns, 2 block rows)
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * var A &#x3D; new la.Matrix([[1,2], [3,4]]);
    * var B &#x3D; new la.Matrix([[5,6], [7,8]]);
    * var C &#x3D; new la.Matrix([[9,10], [11,12]]);
    * var D &#x3D; new la.Matrix([[13,14], [15,16]]);
    * // create a nested matrix
    * // returns the matrix:
    * // 1  2  5  6
    * // 3  4  7  8
    * // 9  10 13 14
    * // 11 12 15 16
    * var mat &#x3D; la.cat([[A,B], [C,D]]);
    */
    exports.cat &#x3D; function (nestedArrMat) {
        var dimx &#x3D; []; //cell row dimensions
        var dimy &#x3D; []; //cell col dimensions
        var cdimx &#x3D; []; //cumulative row dims
        var cdimy &#x3D; []; //cumulative coldims
        var rows &#x3D; nestedArrMat.length;
        var cols &#x3D; nestedArrMat[0].length;
        for (var row &#x3D; 0; row &amp;lt; rows; row++) {
            for (var col &#x3D; 0; col &amp;lt; cols; col++) {
                if (col &gt; 0) {
                    assert(dimx[row] &#x3D;&#x3D; nestedArrMat[row][col].rows, &#x27;inconsistent row dimensions!&#x27;);
                } else {
                    dimx[row] &#x3D; nestedArrMat[row][col].rows;
                }
                if (row &gt; 0) {
                    assert(dimy[col] &#x3D;&#x3D; nestedArrMat[row][col].cols, &#x27;inconsistent column dimensions!&#x27;);
                } else {
                    dimy[col] &#x3D; nestedArrMat[row][col].cols;
                }
            }
        }
        cdimx[0] &#x3D; 0;
        cdimy[0] &#x3D; 0;
        for (var row &#x3D; 1; row &amp;lt; rows; row++) {
            cdimx[row] &#x3D; cdimx[row - 1] + dimx[row - 1];
        }
        for (var col &#x3D; 1; col &amp;lt; cols; col++) {
            cdimy[col] &#x3D; cdimy[col - 1] + dimy[col - 1];
        }

        var res &#x3D; new exports.Matrix({ rows: (cdimx[rows - 1] + dimx[rows - 1]), cols: (cdimy[cols - 1] + dimy[cols - 1]) });
        // copy submatrices
        for (var row &#x3D; 0; row &amp;lt; rows; row++) {
            for (var col &#x3D; 0; col &amp;lt; cols; col++) {
                res.put(cdimx[row], cdimy[col], nestedArrMat[row][col]);
            }
        }
        return res;
    }

    /**
    * Generates an integer vector given range.
    * @param {number} min - Start value. Should be an integer.
    * @param {number} max - End value. Should be an integer.
    * @returns {module:la.IntVector} Integer range vector.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a range vector containing 1, 2, 3
    * var vec &#x3D; la.rangeVec(1, 3);
    */
    exports.rangeVec &#x3D; function (min, max) {
        var len &#x3D; max - min + 1;
        var rangeV &#x3D; new exports.IntVector({ &quot;vals&quot;: len });
        for (var elN &#x3D; 0; elN &amp;lt; len; elN++) {
            rangeV[elN] &#x3D; elN + min;
        }
        return rangeV;
    };

	//////// METHODS

    /**
     * Squares the values in vector.
     * @param {number | module:la.Vector} x - The value/vector.
     * @returns {number | module:la.Vector}
     * &amp;lt;br&gt; 1. If &#x60;x&#x60; is a number, returns square of &#x60;x&#x60;.
     * &amp;lt;br&gt; 2. If &#x60;x&#x60; is a {@link module:la.Vector}, returns a {@link module:la.Vector}, where the i-th value of the vector is the square of &#x60;x[i]&#x60;.
     * @example
     * // import la module
     * var la &#x3D; require(&#x27;qminer&#x27;).la;
     * // create a vector
     * var vec &#x3D; new la.Vector([1, 2, 3]);
     * // square the values of the vector
     * // returns the vector containing  the values 1, 4, 9
     * var sqr &#x3D; la.square(vec);
     */
    exports.square &#x3D; function(x) {
        if (typeof x.length &#x3D;&#x3D; &quot;undefined&quot;) {
            return x * x;
        }
        var res &#x3D; new exports.Vector(x);
        for (var i &#x3D; 0; i &amp;lt; x.length; i++) {
            res[i] &#x3D; x[i] * x[i];
        }
        return res;
    };

    /**
    * Returns a JS array of indices &#x60;idxArray&#x60; that correspond to the max elements in each column of dense matrix. The resulting array has one element for vector input.
    * @param {(module:la.Matrix | module:la.Vector)} X - The matrix or vector.
    * @returns {Array&amp;lt;number&gt;} Array of indexes where maximum is found, one for each column.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a dense matrix
    * var mat &#x3D; new la.Matrix([[1, 2], [2, 0]]);
    * // get the indices of the maximum elements in each column of mat
    * // returns the array:
    * // [1, 0]
    * la.findMaxIdx(mat);
    */
    exports.findMaxIdx &#x3D; function (X) {
        var idxv &#x3D; new Array();
        // X is a dense matrix
        if (typeof X.cols !&#x3D;&#x3D; &quot;undefined&quot;) {
            var cols &#x3D; X.cols;
            for (var colN &#x3D; 0; colN &amp;lt; cols; colN++) {
                idxv.push(X.colMaxIdx(colN));
            }
        }
        // X is a dense vector
        if (typeof X.length !&#x3D;&#x3D; &quot;undefined&quot;) {
            idxv.push(X.getMaxIdx());
        }
        return idxv;
    };

    /**
    * Computes and returns the pairwise squared euclidean distances between columns of &#x60;X1&#x60; and &#x60;X2&#x60; (&#x60;mat3[i,j] &#x3D; ||mat(:,i) - mat2(:,j)||^2&#x60;).
    * @param {module:la.Matrix} X1 - First matrix.
    * @param {module:la.Matrix} X2 - Second matrix.
    * @returns {module:la.Matrix} Matrix with &#x60;X1.cols&#x60; rows and &#x60;X2.cols&#x60; columns containing squared euclidean distances.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // construct two input matrices
    * var X1 &#x3D; new la.Matrix([[1,2], [2,0]]);
    * var X2 &#x3D; new la.Matrix([[1,0.5,0],[0,-0.5,-1]]);
    * // get the pairwise squared distance between the matrices
    * // returns the matrix:
    * // 4 6.5 10
    * // 1 2.5 5
    * la.pdist2(X1, X2);
    */
    exports.pdist2 &#x3D; function (X1, X2) {
        var snorm1 &#x3D; exports.square(X1.colNorms());
        var snorm2 &#x3D; exports.square(X2.colNorms());
        var ones_1 &#x3D; exports.ones(X1.cols);
        var ones_2 &#x3D; exports.ones(X2.cols);
        var D &#x3D; (X1.multiplyT(X2).multiply(-2)).plus(snorm1.outer(ones_2)).plus(ones_1.outer(snorm2));
        return D;
    }

    ///////// ALGORITHMS

    /**
    * Calculates the inverse matrix with SVD.
    * @param {module:la.Matrix} mat - The matrix we want to inverse.
    * @returns {module:la.Matrix} The inverse matrix of &#x60;mat&#x60;.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a random matrix
    * var mat &#x3D; new la.Matrix({ rows: 5, cols: 5, random: true });
    * // get the inverse of mat
    * var inv &#x3D; la.inverseSVD(mat);
    */
    exports.inverseSVD &#x3D; function (mat) {
        var k &#x3D; Math.min(mat.rows, mat.cols);
        var svdRes &#x3D; exports.svd(mat, k, { &quot;iter&quot;: 10, &quot;tol&quot;: 1E-15 });  // returns U, s and V
        var B &#x3D; new exports.Matrix({ &quot;cols&quot;: mat.cols, &quot;rows&quot;: mat.rows });

        // http://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_pseudoinverse#Singular_value_decomposition_.28SVD.29
        var tol &#x3D; 1E-16 * Math.max(mat.cols, mat.rows) * svdRes.s.at(svdRes.s.getMaxIdx());

        // calculate reciprocal values for diagonal matrix &#x3D; inverse diagonal
        for (i &#x3D; 0; i &amp;lt; svdRes.s.length; i++) {
            if (svdRes.s.at(i) &gt; tol) svdRes.s.put(i, 1 / svdRes.s.at(i));
            else svdRes.s.put(0);
        }

        var sum;

        for (i &#x3D; 0; i &amp;lt; svdRes.U.cols; i++) {
            for (j &#x3D; 0; j &amp;lt; svdRes.V.rows; j++) {
                sum &#x3D; 0;
                for (k &#x3D; 0; k &amp;lt; svdRes.U.cols; k++) {
                    if (svdRes.s.at(k) !&#x3D; 0) {
                        sum +&#x3D; svdRes.s.at(k) * svdRes.V.at(i, k) * svdRes.U.at(j, k);
                    }
                }
                B.put(i, j, sum);
            }
        }
        return B;
    }

    /**
    * Solves the PSD symmetric system: A x &#x3D; b, where A is a positive-definite symmetric matrix.
    * @param {(module:la.Matrix | module:la.SparseMatrix)} A - The matrix on the left-hand side of the system.
    * @param {module:la.Vector} b - The vector on the right-hand side of the system.
    * @param {module:la.Vector} [x] - Current solution. Default is a vector of zeros.
    * @param {boolean} [verbose&#x3D;false] - If true, console logs the residuum value.
    * @returns {module:la.Vector} Solution to the system.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a positive-definite symmetric matrix
    * var vecTemp &#x3D; new la.Vector([1, 2, 3]);
    * var mat &#x3D; vecTemp.diag();
    * // create the right-hand side vector 
    * var vec &#x3D; new la.Vector([0.5, 3, -2]);
    * // solve the PSD symmetric system
    * var x &#x3D; la.conjgrad(mat, vec);
    */
    exports.conjgrad &#x3D; function (A, b, x, verbose) {
        verbose &#x3D; verbose &#x3D;&#x3D;&#x3D; undefined ? false : verbose;
    	x &#x3D; x || new exports.Vector({vals: A.cols});
        var r &#x3D; b.minus(A.multiply(x));
        var p &#x3D; new exports.Vector(r); //clone
        var rsold &#x3D; r.inner(r);
        for (var i &#x3D; 0; i &amp;lt; 2 * x.length; i++) {
            var Ap &#x3D; A.multiply(p);
            var alpha &#x3D; rsold / Ap.inner(p);
            x &#x3D; x.plus(p.multiply(alpha));
            r &#x3D; r.minus(Ap.multiply(alpha));
            var rsnew &#x3D; r.inner(r);
            if (verbose) {
                console.log(&quot;resid &#x3D; &quot; + rsnew);
            }
            if (Math.sqrt(rsnew) &amp;lt; 1e-6) {
                break;
            }
            p &#x3D; r.plus(p.multiply(rsnew / rsold));
            rsold &#x3D; rsnew;
        }
        return x;
    }

    

/**
 * Copyright (c) 2015, Jozef Stefan Institute, Quintelligence d.o.o. and contributors
 * All rights reserved.
 *
 * This source code is licensed under the FreeBSD license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
* Vector - array of doubles.
* @classdesc The number vector representation. Wraps a C++ array.
* @class
* @param {(Array.&amp;lt;number&gt; | module:la.Vector)} [arg] - Constructor arguments. There are two ways of constructing:
* &amp;lt;br&gt;1. using an array of vector elements. Example: using &#x60;[1, 2, 3]&#x60; creates a vector of length 3,
* &amp;lt;br&gt;2. using a vector (copy constructor).
* @example
* var la &#x3D; require(&#x27;qminer&#x27;).la;
* // create a new empty vector
* var vec &#x3D; new la.Vector();
* // create a new vector
* var vec2 &#x3D; new la.Vector([1, 2, 3]);
*/
 exports.Vector &#x3D; function() { return Object.create(require(&#x27;qminer&#x27;).la.Vector.prototype); }
 var VectorDefaultVal &#x3D; 0.0; // for intellisense
/**
    * Returns element at index.
    * @param {number} index - Element index (zero-based).
    * @returns {number} Vector element.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.Vector([1, 2, 3]);
    * // get the element at index 1
    * var el &#x3D; vec[1];
    */
 exports.Vector.prototype.at &#x3D; function(number) { return VectorDefaultVal; }
/**
    * Returns a subvector.
    * @param {(Array.&amp;lt;number&gt; | module:la.IntVector)} arg - Index array or vector. Indices can repeat (zero based).
    * @returns {module:la.Vector} Subvector, where the i-th element is the &#x60;arg[i]&#x60;-th element of the instance.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.Vector([1, 2, 3]);
    * // get the subvector of the first two elements
    * var subvec &#x3D; vec.subVec([0, 1]);
    */
 exports.Vector.prototype.subVec &#x3D; function (arg) { return Object.create(this); }
/**
    * Sets an element in vector.
    * @param {number} idx - Index (zero based).
    * @param {number} val - Element value.
    * @returns {module:la.Vector} Self. The values at index &#x60;idx&#x60; has been changed to &#x60;val&#x60;.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.Vector([1, 2, 3]);
    * // set the first element to 10
    * vec.put(0, 10);
    */
 exports.Vector.prototype.put &#x3D; function (idx, val) { return this;}
/**
    * Adds an element to the end of the vector.
    * @param {number} val - The element added to the vector.
    * @returns {number} The new length property of the object upon which the method was called.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.Vector([1, 2, 3]);
    * // push an element to the vector
    * vec.push(10);
    */
 exports.Vector.prototype.push &#x3D; function (val) { return 0; }
/**
    * Changes the vector by removing and adding elements.
    * @param {number} start - Index at which to start changing the array.
    * @param {number} deleteCount - Number of elements to be removed.
    * @param {...number} [itemN] - The element(s) to be add to the array. If no elements are given, splice() will only remove elements from the array.
    * @returns {module:la.Vector} Self. The selected elements are removed/replaced.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.Vector([1, 2, 3]);
    * // splice the vector by removing the last two elements and adding 4, 5
    * vec.splice(1, 2, 4, 5)// returns vector [1, 4, 5]
    */
 exports.Vector.prototype.splice &#x3D; function (start, deleteCount, itemN) { return this; }
/**
    * Adds elements to the beginning of the vector.
    * @param {...number} args - One or more elements to be added to the vector.
    * @returns {number} The new length of vector.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.Vector([1, 2, 3]);
    * // add two elements to the beggining of the vector
    * var len &#x3D; vec.unshift(4, 5); // returns 5
    */
 exports.Vector.prototype.unshift &#x3D; function (args) { return 0; }
/**
    * Appends a second vector to the first one.
    * @param {module:la.Vector} vec - The appended vector.
    * @returns {number} The new length property of the vectors.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create two new vectors
    * var vec &#x3D; new la.Vector([1, 2, 3]);
    * var vec2 &#x3D; new la.Vector([4, 5]);
    * // append the two vectors
    * vec.pushV(vec2);
    */
 exports.Vector.prototype.pushV &#x3D; function (vec) { return 0; }
/**
    * Sums the elements in the vector.
    * @returns {number} The sum of all elements in the instance.
    * @example
    * // import la modules
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.Vector([1, 2, 3]);
    * // sum all the elements of the vector
    * var sum &#x3D; vec.sum();
    */
 exports.Vector.prototype.sum &#x3D; function () { return VectorDefaultVal; }
/**
    * Gets the index of the maximal element.
    * @returns {number} Index of the maximal element in the vector.
    * // import la modules
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.Vector([1, 2, 3]);
    * // get the index of the maximum value
    * var idx &#x3D; vec.getMaxIdx();
    *
    */
 exports.Vector.prototype.getMaxIdx &#x3D; function () { return 0; }
/**
    * Vector sort comparator callback.
    * @callback vectorCompareCb
    * @param {number} arg1 - First argument.
    * @param {number} arg2 - Second argument.
    * @returns {(number | boolean)} If &#x60;vectorCompareCb(arg1, arg2)&#x60; is less than 0 or false, sort &#x60;arg1&#x60; to a lower index than &#x60;arg2&#x60;, i.e. &#x60;arg1&#x60; comes first.
    */
/**
    * Sorts the vector (in place operation).
    * @param {(module:la~vectorCompareCb | boolean)} [arg] - Sort callback or a boolean ascend flag. Default is boolean and true.
    * @returns {module:la.Vector} Self.
    * &amp;lt;br&gt;1. Vector sorted in ascending order, if &#x60;arg&#x60; is boolean and true.
    * &amp;lt;br&gt;2. Vector sorted in descending order, if &#x60;arg&#x60; is boolean and false.
    * &amp;lt;br&gt;3. Vector sorted by using the comparator callback, if &#x60;arg&#x60; is a {@link module:la~vectorCompareCb}.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.Vector([-2.0, 1.0, 3.0]);
    * // sort ascending
    * vec.sort(); // sorts to: [-2.0, 1.0, 3.0]
    * // sort using callback
    * vec.sort(function(arg1, arg2) { return Math.abs(arg1) - Math.abs(arg2); }); // sorts to: [1.0, -2.0, 3.0]
    */
 exports.Vector.prototype.sort &#x3D; function (bool) { return this; }
/**
    * Sorts the vector and returns the sorted vector as well as the permutation.
    * @param {boolean} [asc &#x3D; true] - Sort in ascending order flag.
    * @returns {Object} The object &#x60;VectorSortResult&#x60; containing the properties:
    * &amp;lt;br&gt; &#x60;VectorSortResult.vec&#x60; - The sorted vector,
    * &amp;lt;br&gt; &#x60;VectorSortResult.perm&#x60; - Permutation vector, where &#x60;VectorSortResult.vec[i] &#x3D; instanceVector[VectorSortResult.perm[i]]&#x60;.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.Vector([-2.0, 1.0, 3.0]);
    * // sort ascending
    * var result &#x3D; vec.sortPerm();
    * result.vec;  // [-2.0, 1.0, 3.0]
    * result.perm; // permutation index vector
    */
 exports.Vector.prototype.sortPerm &#x3D; function (asc) { return {vec: Object.create(this), perm: Object.create(require(&#x27;qminer&#x27;).la.IntVector.prototype) }; }
/**
    * Randomly reorders the elements of the vector (inplace).
    * @returns {module:la.Vector} Self. The elements are randomly reordered.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.Vector([-2.0, 1.0, 3.0]);
    * // shuffle the elements
    * vec.shuffle();
    */
 exports.Vector.prototype.shuffle &#x3D; function () { return this; }
/**
    * Deletes elements with sprecific index or more.
    * @param {number} idx - Index (zero based).
    * @returns {module:la.Vector} Self after truncating.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.Vector([1, 2, 3]);
    * // trunc all elements with index 1 or more
    * vec.trunc(1); // returns vector [1]
    */
 exports.Vector.prototype.trunc &#x3D; function (idx) { return this; }
/**
    * Creates a dense matrix A by multiplying two vectors x and y: &#x60;A &#x3D; x * y^T&#x60;.
    * @param {module:la.Vector} vec - Second vector.
    * @returns {module:la.Matrix} Matrix obtained by the outer product of the instance and second vector.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create two new vectors
    * var x &#x3D; new la.Vector([1, 2, 3]);
    * var y &#x3D; new la.Vector([4, 5]);
    * // create the outer product of these vectors
    * var A &#x3D; x.outer(y); // creates the dense matrix [[4, 5], [8, 10], [12, 15]]
    */
 exports.Vector.prototype.outer &#x3D; function (vec) { return Object.create(require(&#x27;qminer&#x27;).la.Matrix.prototype); }
/**
    * Computes the inner product.
    * @param {module:la.Vector} vec - Other vector.
    * @returns {number} Inner product between the instance and the other vector.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create two new vectors
    * var x &#x3D; new la.Vector([1, 2, 3]);
    * var y &#x3D; new la.Vector([4, 5, -1]);
    * // get the inner product of the two vectors
    * var prod &#x3D; x.inner(y); // returns 11
    */
 exports.Vector.prototype.inner &#x3D; function(vec) { return 0; }
/**
    * Returns the cosine between the two vectors.
    * @param {module:la.Vector} vec - Second vector.
    * @returns {number} The cosine between the two vectors.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create two new vectors
    * var x &#x3D; new la.Vector([1, 0]);
    * var y &#x3D; new la.Vector([0, 1]);
    * // calculate the cosine between those two vectors
    * var num &#x3D; x.cosine(y); // returns 0
    */
 exports.Vector.prototype.cosine &#x3D; function (vec) { return 0.0; }
/**
    * Vector addition.
    * @param {module:la.Vector} vec - Second vector.
    * @returns {module:la.Vector} Sum of the instance and the second vector.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create two new vectors
    * var x &#x3D; new la.Vector([1, 2, 3]);
    * var y &#x3D; new la.Vector([4, 5, -1]);
    * // sum the vectors
    * var z &#x3D; x.plus(y);
    */
 exports.Vector.prototype.plus &#x3D; function (vec) { return Object.create(this); }
/**
    * Vector substraction.
    * @param {module:la.Vector} vec - Second vector.
    * @returns {module:la.Vector} The difference of the instance and the other vector.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create two new vectors
    * var x &#x3D; new la.Vector([1, 2, 3]);
    * var y &#x3D; new la.Vector([4, 5, -1]);
    * // substract the vectors
    * var z &#x3D; x.minus(y);
    */
 exports.Vector.prototype.minus &#x3D; function (vec) { return Object.create(this); }
/**
    * Multiplies the vector with a scalar.
    * @param {number} val - Scalar.
    * @returns {module:la.Vector} Product of the vector and scalar.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var x &#x3D; new la.Vector([4, 5, -1]);
    * // multiply the vector with the scalar 3
    * var y &#x3D; x.multiply(3);
    */
 exports.Vector.prototype.multiply &#x3D; function (val) { return Object.create(this); }
/**
    * Normalizes vector.
    * @returns {module:la.Vector} Self. The vector is normalized.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var x &#x3D; new la.Vector([4, 5, -1]);
    * // normalize the vector
    * x.normalize();
    */
 exports.Vector.prototype.normalize &#x3D; function () { return this; }
/**
    * Gives the length of vector. Type &#x60;number&#x60;.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var x &#x3D; new la.Vector([1, 2, 3]);
    * // get the length of the vector
    * var len &#x3D; x.length; // returns 3
    */
 exports.Vector.prototype.length &#x3D; 0;
/**
    * Returns the vector as string.
    * @returns {string} String representation.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.Vector([1, 2, 3]);
    * // create vector as string
    * vec.toString(); // returns &#x27;1, 2, 3&#x27;
    */
 exports.Vector.prototype.toString &#x3D; function () { return &#x27;&#x27;; }
/**
    * Creates a dense diagonal matrix out of the vector.
    * @returns{module:la.Matrix} Diagonal matrix, where the (i, i)-th element is the i-th element of vector.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.Vector([4, 5, -1]);
    * // create a dense matrix with the diagonal equal to vec
    * var mat &#x3D; vec.diag();
    */
 exports.Vector.prototype.diag &#x3D; function () { return Object.create(require(&#x27;qminer&#x27;).la.Matrix.prototype); }
/**
    * Creates a sparse diagonal matrix out of the vector.
    * @returns {module:la.SparseMatrix} Diagonal matrix, where the (i, i)-th element is the i-th element of vector.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.Vector([4, 5, -1]);
    * // create a sparse matrix with the diagonal equal to vec
    * var mat &#x3D; vec.spDiag();
    */
 exports.Vector.prototype.spDiag &#x3D; function () { return Object.create(require(&#x27;qminer&#x27;).la.SparseMatrix.prototype); }
/**
    * Calculates the norm of the vector.
    * @returns {number} The norm of the vector.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.Vector([4, 5, -1]);
    * // get the norm of the vector
    * var norm &#x3D; vec.norm();
    */
 exports.Vector.prototype.norm &#x3D; function () { return 0.0; }
/**
    * Creates the sparse vector representation of the vector.
    * @returns {module:la.SparseVector} The sparse vector representation.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.Vector([4, 5, -1]);
    * // create the sparse representation of the vector
    * var spVec &#x3D; vec.sparse();
    */
 exports.Vector.prototype.sparse &#x3D; function () { return Object.create(require(&#x27;qminer&#x27;).la.SparseVector.prototype); }
/**
    * Creates a matrix with a single column that is equal to the vector.
    * @returns {module:la.Matrix} The matrix with a single column that is equal to the instance.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.Vector([4, 5, -1]);
    * // create a matrix representation of the vector
    * var mat &#x3D; vec.toMat();
    */
 exports.Vector.prototype.toMat &#x3D; function () { return Object.create(require(&#x27;qminer&#x27;).la.Matrix.prototype); }
/**
    * Saves the vector as output stream (binary serialization).
    * @param {module:fs.FOut} fout - Output stream.
    * @returns {module:fs.FOut} The output stream &#x60;fout&#x60;.
    * @example
    * // import fs module
    * var fs &#x3D; require(&#x27;qminer&#x27;).fs;
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.Vector([1, 2, 3]);
    * // open write stream
    * var fout &#x3D; fs.openWrite(&#x27;vec.dat&#x27;);
    * // save vector and close write stream
    * vec.save(fout).close();
    */
 exports.Vector.prototype.save &#x3D; function (fout) {  return Object.create(require(&#x27;qminer&#x27;).fs.FOut.prototype); }
/**
    * Loads the vector from input stream (binary deserialization).
    * @param {module:fs.FIn} fin - Input stream.
    * @returns {module:la.Vector} Self. The vector is filled using the input stream &#x60;fin&#x60;.
    * @example
    * // import fs module
    * var fs &#x3D; require(&#x27;qminer&#x27;).fs;
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create an empty vector
    * var vec &#x3D; new la.Vector();
    * // open a read stream
    * var fin &#x3D; fs.openRead(&#x27;vec.dat&#x27;);
    * // load the vector
    * vec.load(fin);
    */
 exports.Vector.prototype.load &#x3D; function (fin) { return this; }
/**
    * Saves the vector as output stream (ascii serialization).
    * @param {module:fs.FOut} fout - Output stream.
    * @returns {module:fs.FOut} The output stream &#x60;fout&#x60;.
    * @example
    * // import fs module
    * var fs &#x3D; require(&#x27;qminer&#x27;).fs;
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.Vector([1, 2, 3]);
    * // open write stream
    * var fout &#x3D; fs.openWrite(&#x27;vec.dat&#x27;);
    * // save matrix and close write stream
    * vec.saveascii(fout).close();
    */
 exports.Vector.prototype.saveascii &#x3D; function (fout) {  return Object.create(require(&#x27;qminer&#x27;).fs.FOut.prototype); }
/**
    * Loads the vector from input stream (ascii deserialization).
    * @param {module:fs.FIn} fin - Input stream.
    * @returns {module:la.Vector} Self. The vector is filled using the input stream &#x60;fin&#x60;.
    * @example
    * // import fs module
    * var fs &#x3D; require(&#x27;qminer&#x27;).fs;
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create an empty vector
    * var vec &#x3D; new la.Vector();
    * // open a read stream
    * var fin &#x3D; fs.openRead(&#x27;vec.dat&#x27;);
    * // load the matrix
    * vec.loadascii(fin);
    */
 exports.Vector.prototype.loadascii &#x3D; function (fin) { return this; }

/**
 * Copyright (c) 2015, Jozef Stefan Institute, Quintelligence d.o.o. and contributors
 * All rights reserved.
 *
 * This source code is licensed under the FreeBSD license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
* Vector - array of strings.
* @classdesc The string vector representation. Wraps a C++ array.
* @class
* @param {(Array.&amp;lt;string&gt; | module:la.StrVector)} [arg] - Constructor arguments. There are two ways of constructing:
* &amp;lt;br&gt;1. using an array of vector elements. Example: using &#x60;[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]&#x60; creates a vector of length 3,
* &amp;lt;br&gt;2. using a vector (copy constructor).
* @example
* var la &#x3D; require(&#x27;qminer&#x27;).la;
* // create a new empty vector
* var vec &#x3D; new la.StrVector();
* // create a new vector
* var vec2 &#x3D; new la.StrVector([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]);
*/
 exports.StrVector &#x3D; function() { return Object.create(require(&#x27;qminer&#x27;).la.StrVector.prototype); }
 var StrVectorDefaultVal &#x3D; &#x27;&#x27;; // for intellisense
/**
    * Returns element at index.
    * @param {number} index - Element index (zero-based).
    * @returns {string} Vector element.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.StrVector([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]);
    * // get the element at index 1
    * var el &#x3D; vec[1];
    */
 exports.StrVector.prototype.at &#x3D; function(number) { return StrVectorDefaultVal; }
/**
    * Returns a subvector.
    * @param {(Array.&amp;lt;number&gt; | module:la.IntVector)} arg - Index array or vector. Indices can repeat (zero based).
    * @returns {module:la.StrVector} Subvector, where the i-th element is the &#x60;arg[i]&#x60;-th element of the instance.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.StrVector([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]);
    * // get the subvector of the first two elements
    * var subvec &#x3D; vec.subVec([0, 1]);
    */
 exports.StrVector.prototype.subVec &#x3D; function (arg) { return Object.create(this); }
/**
    * Sets an element in vector.
    * @param {number} idx - Index (zero based).
    * @param {string} val - Element value.
    * @returns {module:la.StrVector} Self. The values at index &#x60;idx&#x60; has been changed to &#x60;val&#x60;.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.StrVector([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]);
    * // set the first element to &#x27;xyz&#x27;
    * vec.put(0, &#x27;xyz&#x27;);
    */
 exports.StrVector.prototype.put &#x3D; function (idx, val) { return this;}
/**
    * Adds an element to the end of the vector.
    * @param {string} val - The element added to the vector.
    * @returns {number} The new length property of the object upon which the method was called.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.StrVector([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]);
    * // push an element to the vector
    * vec.push(&#x27;xyz&#x27;);
    */
 exports.StrVector.prototype.push &#x3D; function (val) { return 0; }
/**
    * Changes the vector by removing and adding elements.
    * @param {number} start - Index at which to start changing the array.
    * @param {number} deleteCount - Number of elements to be removed.
    * @param {...number} [itemN] - The element(s) to be add to the array. If no elements are given, splice() will only remove elements from the array.
    * @returns {module:la.StrVector} Self. The selected elements are removed/replaced.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.StrVector([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]);
    * // splice the vector by removing the last two elements and adding &#x27;d&#x27;, &#x27;e&#x27;
    * vec.splice(1, 2, &#x27;d&#x27;, &#x27;e&#x27;)// returns vector [&#x27;a&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]
    */
 exports.StrVector.prototype.splice &#x3D; function (start, deleteCount, itemN) { return this; }
/**
    * Adds elements to the beginning of the vector.
    * @param {...string} args - One or more elements to be added to the vector.
    * @returns {number} The new length of vector.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.StrVector([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]);
    * // add two elements to the beggining of the vector
    * var len &#x3D; vec.unshift(&#x27;d&#x27;, &#x27;e&#x27;); // returns 5
    */
 exports.StrVector.prototype.unshift &#x3D; function (args) { return 0; }
/**
    * Appends a second vector to the first one.
    * @param {module:la.StrVector} vec - The appended vector.
    * @returns {number} The new length property of the vectors.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create two new vectors
    * var vec &#x3D; new la.StrVector([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]);
    * var vec2 &#x3D; new la.StrVector([&#x27;d&#x27;, &#x27;e&#x27;]);
    * // append the two vectors
    * vec.pushV(vec2);
    */
 exports.StrVector.prototype.pushV &#x3D; function (vec) { return 0; }
/**
    * Sums the elements in the vector.
    * @returns {number} The sum of all elements in the instance.
    * @example
    * // import la modules
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.StrVector([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]);
    * // sum all the elements of the vector
    * var sum &#x3D; vec.sum();
    */
 skip.exports.StrVector.prototype.sum &#x3D; function () { return StrVectorDefaultVal; }
/**
    * Gets the index of the maximal element.
    * @returns {number} Index of the maximal element in the vector.
    * // import la modules
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.StrVector([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]);
    * // get the index of the maximum value
    * var idx &#x3D; vec.getMaxIdx();
    *
    */
 skip.exports.StrVector.prototype.getMaxIdx &#x3D; function () { return 0; }
/**
    * Vector sort comparator callback.
    * @callback strVectorCompareCb
    * @param {string} arg1 - First argument.
    * @param {string} arg2 - Second argument.
    * @returns {(number | boolean)} If &#x60;strVectorCompareCb(arg1, arg2)&#x60; is less than 0 or false, sort &#x60;arg1&#x60; to a lower index than &#x60;arg2&#x60;, i.e. &#x60;arg1&#x60; comes first.
    */
/**
    * Sorts the vector (in place operation).
    * @param {(module:la~strVectorCompareCb | boolean)} [arg] - Sort callback or a boolean ascend flag. Default is boolean and true.
    * @returns {module:la.StrVector} Self.
    * &amp;lt;br&gt;1. Vector sorted in ascending order, if &#x60;arg&#x60; is boolean and true.
    * &amp;lt;br&gt;2. Vector sorted in descending order, if &#x60;arg&#x60; is boolean and false.
    * &amp;lt;br&gt;3. Vector sorted by using the comparator callback, if &#x60;arg&#x60; is a {@link module:la~strVectorCompareCb}.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.StrVector([&#x27;asd&#x27;, &#x27;z&#x27;, &#x27;kkkk&#x27;]);
    * // sort ascending
    * vec.sort(); // sorts to: [&#x27;asd&#x27;, &#x27;kkkk&#x27;, &#x27;z&#x27;]
    * // sort using callback
    * vec.sort(function(arg1, arg2) { return arg1.length - arg2.length; }); // sorts to: [&#x27;z&#x27;, &#x27;asd&#x27;, &#x27;kkkk&#x27;]
    */
 skip.exports.StrVector.prototype.sort &#x3D; function (bool) { return this; }
/**
    * Sorts the vector and returns the sorted vector as well as the permutation.
    * @param {boolean} [asc &#x3D; true] - Sort in ascending order flag.
    * @returns {Object} The object &#x60;StrVectorSortResult&#x60; containing the properties:
    * &amp;lt;br&gt; &#x60;StrVectorSortResult.vec&#x60; - The sorted vector,
    * &amp;lt;br&gt; &#x60;StrVectorSortResult.perm&#x60; - Permutation vector, where &#x60;StrVectorSortResult.vec[i] &#x3D; instanceVector[StrVectorSortResult.perm[i]]&#x60;.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.StrVector([&#x27;asd&#x27;, &#x27;z&#x27;, &#x27;kkkk&#x27;]);
    * // sort ascending
    * var result &#x3D; vec.sortPerm();
    * result.vec;  // [&#x27;asd&#x27;, &#x27;kkkk&#x27;, &#x27;z&#x27;]
    * result.perm; // permutation index vector
    */
 skip.exports.StrVector.prototype.sortPerm &#x3D; function (asc) { return {vec: Object.create(this), perm: Object.create(require(&#x27;qminer&#x27;).la.IntVector.prototype) }; }
/**
    * Randomly reorders the elements of the vector (inplace).
    * @returns {module:la.StrVector} Self. The elements are randomly reordered.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.StrVector([&#x27;asd&#x27;, &#x27;z&#x27;, &#x27;kkkk&#x27;]);
    * // shuffle the elements
    * vec.shuffle();
    */
 exports.StrVector.prototype.shuffle &#x3D; function () { return this; }
/**
    * Deletes elements with sprecific index or more.
    * @param {string} idx - Index (zero based).
    * @returns {module:la.StrVector} Self after truncating.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.StrVector([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]);
    * // trunc all elements with index 1 or more
    * vec.trunc(1); // returns vector [&#x27;a&#x27;]
    */
 exports.StrVector.prototype.trunc &#x3D; function (idx) { return this; }
/**
    * Creates a dense matrix A by multiplying two vectors x and y: &#x60;A &#x3D; x * y^T&#x60;.
    * @param {module:la.StrVector} vec - Second vector.
    * @returns {module:la.Matrix} Matrix obtained by the outer product of the instance and second vector.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create two new vectors
    * var x &#x3D; new la.StrVector([1, 2, 3]);
    * var y &#x3D; new la.StrVector([4, 5]);
    * // create the outer product of these vectors
    * var A &#x3D; x.outer(y); // creates the dense matrix [[4, 5], [8, 10], [12, 15]]
    */
 skip.exports.StrVector.prototype.outer &#x3D; function (vec) { return Object.create(require(&#x27;qminer&#x27;).la.Matrix.prototype); }
/**
    * Computes the inner product.
    * @param {module:la.Vector} vec - Other vector.
    * @returns {number} Inner product between the instance and the other vector.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create two new vectors
    * var x &#x3D; new la.Vector([1, 2, 3]);
    * var y &#x3D; new la.Vector([4, 5, -1]);
    * // get the inner product of the two vectors
    * var prod &#x3D; x.inner(y); // returns 11
    */
 skip.exports.Vector.prototype.inner &#x3D; function(vec) { return 0; }
/**
    * Returns the cosine between the two vectors.
    * @param {module:la.Vector} vec - Second vector.
    * @returns {number} The cosine between the two vectors.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create two new vectors
    * var x &#x3D; new la.Vector([1, 0]);
    * var y &#x3D; new la.Vector([0, 1]);
    * // calculate the cosine between those two vectors
    * var num &#x3D; x.cosine(y); // returns 0
    */
 skip.exports.Vector.prototype.cosine &#x3D; function (vec) { return 0.0; }
/**
    * Vector addition.
    * @param {module:la.Vector} vec - Second vector.
    * @returns {module:la.Vector} Sum of the instance and the second vector.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create two new vectors
    * var x &#x3D; new la.Vector([1, 2, 3]);
    * var y &#x3D; new la.Vector([4, 5, -1]);
    * // sum the vectors
    * var z &#x3D; x.plus(y);
    */
 skip.exports.Vector.prototype.plus &#x3D; function (vec) { return Object.create(this); }
/**
    * Vector substraction.
    * @param {module:la.Vector} vec - Second vector.
    * @returns {module:la.Vector} The difference of the instance and the other vector.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create two new vectors
    * var x &#x3D; new la.Vector([1, 2, 3]);
    * var y &#x3D; new la.Vector([4, 5, -1]);
    * // substract the vectors
    * var z &#x3D; x.minus(y);
    */
 skip.exports.Vector.prototype.minus &#x3D; function (vec) { return Object.create(this); }
/**
    * Multiplies the vector with a scalar.
    * @param {number} val - Scalar.
    * @returns {module:la.Vector} Product of the vector and scalar.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var x &#x3D; new la.Vector([4, 5, -1]);
    * // multiply the vector with the scalar 3
    * var y &#x3D; x.multiply(3);
    */
 skip.exports.Vector.prototype.multiply &#x3D; function (val) { return Object.create(this); }
/**
    * Normalizes vector.
    * @returns {module:la.Vector} Self. The vector is normalized.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var x &#x3D; new la.Vector([4, 5, -1]);
    * // normalize the vector
    * x.normalize();
    */
 skip.exports.Vector.prototype.normalize &#x3D; function () { return this; }
/**
    * Gives the length of vector. Type &#x60;number&#x60;.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var x &#x3D; new la.StrVector([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]);
    * // get the length of the vector
    * var len &#x3D; x.length; // returns 3
    */
 exports.StrVector.prototype.length &#x3D; 0;
/**
    * Returns the vector as string.
    * @returns {string} String representation.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.StrVector([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]);
    * // create vector as string
    * vec.toString(); // returns &#x27;a, b, c&#x27;
    */
 exports.StrVector.prototype.toString &#x3D; function () { return &#x27;&#x27;; }
/**
    * Creates a dense diagonal matrix out of the vector.
    * @returns{module:la.Matrix} Diagonal matrix, where the (i, i)-th element is the i-th element of vector.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.Vector([4, 5, -1]);
    * // create a dense matrix with the diagonal equal to vec
    * var mat &#x3D; vec.diag();
    */
 skip.exports.Vector.prototype.diag &#x3D; function () { return Object.create(require(&#x27;qminer&#x27;).la.Matrix.prototype); }
/**
    * Creates a sparse diagonal matrix out of the vector.
    * @returns {module:la.SparseMatrix} Diagonal matrix, where the (i, i)-th element is the i-th element of vector.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.Vector([4, 5, -1]);
    * // create a sparse matrix with the diagonal equal to vec
    * var mat &#x3D; vec.spDiag();
    */
 skip.exports.StrVector.prototype.spDiag &#x3D; function () { return Object.create(require(&#x27;qminer&#x27;).la.SparseMatrix.prototype); }
/**
    * Calculates the norm of the vector.
    * @returns {number} The norm of the vector.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.Vector([4, 5, -1]);
    * // get the norm of the vector
    * var norm &#x3D; vec.norm();
    */
 skip.exports.Vector.prototype.norm &#x3D; function () { return 0.0; }
/**
    * Creates the sparse vector representation of the vector.
    * @returns {module:la.SparseVector} The sparse vector representation.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.Vector([4, 5, -1]);
    * // create the sparse representation of the vector
    * var spVec &#x3D; vec.sparse();
    */
 skip.exports.Vector.prototype.sparse &#x3D; function () { return Object.create(require(&#x27;qminer&#x27;).la.SparseVector.prototype); }
/**
    * Creates a matrix with a single column that is equal to the vector.
    * @returns {module:la.Matrix} The matrix with a single column that is equal to the instance.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.Vector([4, 5, -1]);
    * // create a matrix representation of the vector
    * var mat &#x3D; vec.toMat();
    */
 skip.exports.Vector.prototype.toMat &#x3D; function () { return Object.create(require(&#x27;qminer&#x27;).la.Matrix.prototype); }
/**
    * Saves the vector as output stream (binary serialization).
    * @param {module:fs.FOut} fout - Output stream.
    * @returns {module:fs.FOut} The output stream &#x60;fout&#x60;.
    * @example
    * // import fs module
    * var fs &#x3D; require(&#x27;qminer&#x27;).fs;
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.StrVector([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]);
    * // open write stream
    * var fout &#x3D; fs.openWrite(&#x27;vec.dat&#x27;);
    * // save vector and close write stream
    * vec.save(fout).close();
    */
 exports.StrVector.prototype.save &#x3D; function (fout) {  return Object.create(require(&#x27;qminer&#x27;).fs.FOut.prototype); }
/**
    * Loads the vector from input stream (binary deserialization).
    * @param {module:fs.FIn} fin - Input stream.
    * @returns {module:la.StrVector} Self. The vector is filled using the input stream &#x60;fin&#x60;.
    * @example
    * // import fs module
    * var fs &#x3D; require(&#x27;qminer&#x27;).fs;
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create an empty vector
    * var vec &#x3D; new la.StrVector();
    * // open a read stream
    * var fin &#x3D; fs.openRead(&#x27;vec.dat&#x27;);
    * // load the vector
    * vec.load(fin);
    */
 exports.StrVector.prototype.load &#x3D; function (fin) { return this; }
/**
    * Saves the vector as output stream (ascii serialization).
    * @param {module:fs.FOut} fout - Output stream.
    * @returns {module:fs.FOut} The output stream &#x60;fout&#x60;.
    * @example
    * // import fs module
    * var fs &#x3D; require(&#x27;qminer&#x27;).fs;
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.StrVector([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]);
    * // open write stream
    * var fout &#x3D; fs.openWrite(&#x27;vec.dat&#x27;);
    * // save matrix and close write stream
    * vec.saveascii(fout).close();
    */
 exports.StrVector.prototype.saveascii &#x3D; function (fout) {  return Object.create(require(&#x27;qminer&#x27;).fs.FOut.prototype); }
/**
    * Loads the vector from input stream (ascii deserialization).
    * @param {module:fs.FIn} fin - Input stream.
    * @returns {module:la.StrVector} Self. The vector is filled using the input stream &#x60;fin&#x60;.
    * @example
    * // import fs module
    * var fs &#x3D; require(&#x27;qminer&#x27;).fs;
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create an empty vector
    * var vec &#x3D; new la.StrVector();
    * // open a read stream
    * var fin &#x3D; fs.openRead(&#x27;vec.dat&#x27;);
    * // load the matrix
    * vec.loadascii(fin);
    */
 exports.StrVector.prototype.loadascii &#x3D; function (fin) { return this; }

/**
 * Copyright (c) 2015, Jozef Stefan Institute, Quintelligence d.o.o. and contributors
 * All rights reserved.
 *
 * This source code is licensed under the FreeBSD license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
* Vector - array of integers.
* @classdesc The number vector representation. Wraps a C++ array.
* @class
* @param {(Array.&amp;lt;number&gt; | module:la.IntVector)} [arg] - Constructor arguments. There are two ways of constructing:
* &amp;lt;br&gt;1. using an array of vector elements. Example: using &#x60;[1, 2, 3]&#x60; creates a vector of length 3,
* &amp;lt;br&gt;2. using a vector (copy constructor).
* @example
* var la &#x3D; require(&#x27;qminer&#x27;).la;
* // create a new empty vector
* var vec &#x3D; new la.IntVector();
* // create a new vector
* var vec2 &#x3D; new la.IntVector([1, 2, 3]);
*/
 exports.IntVector &#x3D; function() { return Object.create(require(&#x27;qminer&#x27;).la.IntVector.prototype); }
 var IntVectorDefaultVal &#x3D; 0; // for intellisense
/**
    * Returns element at index.
    * @param {number} index - Element index (zero-based).
    * @returns {number} Vector element.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.IntVector([1, 2, 3]);
    * // get the element at index 1
    * var el &#x3D; vec[1];
    */
 exports.IntVector.prototype.at &#x3D; function(number) { return IntVectorDefaultVal; }
/**
    * Returns a subvector.
    * @param {(Array.&amp;lt;number&gt; | module:la.IntVector)} arg - Index array or vector. Indices can repeat (zero based).
    * @returns {module:la.IntVector} Subvector, where the i-th element is the &#x60;arg[i]&#x60;-th element of the instance.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.IntVector([1, 2, 3]);
    * // get the subvector of the first two elements
    * var subvec &#x3D; vec.subVec([0, 1]);
    */
 exports.IntVector.prototype.subVec &#x3D; function (arg) { return Object.create(this); }
/**
    * Sets an element in vector.
    * @param {number} idx - Index (zero based).
    * @param {number} val - Element value.
    * @returns {module:la.IntVector} Self. The values at index &#x60;idx&#x60; has been changed to &#x60;val&#x60;.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.IntVector([1, 2, 3]);
    * // set the first element to 10
    * vec.put(0, 10);
    */
 exports.IntVector.prototype.put &#x3D; function (idx, val) { return this;}
/**
    * Adds an element to the end of the vector.
    * @param {number} val - The element added to the vector.
    * @returns {number} The new length property of the object upon which the method was called.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.IntVector([1, 2, 3]);
    * // push an element to the vector
    * vec.push(10);
    */
 exports.IntVector.prototype.push &#x3D; function (val) { return 0; }
/**
    * Changes the vector by removing and adding elements.
    * @param {number} start - Index at which to start changing the array.
    * @param {number} deleteCount - Number of elements to be removed.
    * @param {...number} [itemN] - The element(s) to be add to the array. If no elements are given, splice() will only remove elements from the array.
    * @returns {module:la.IntVector} Self. The selected elements are removed/replaced.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.IntVector([1, 2, 3]);
    * // splice the vector by removing the last two elements and adding 4, 5
    * vec.splice(1, 2, 4, 5)// returns vector [1, 4, 5]
    */
 exports.IntVector.prototype.splice &#x3D; function (start, deleteCount, itemN) { return this; }
/**
    * Adds elements to the beginning of the vector.
    * @param {...number} args - One or more elements to be added to the vector.
    * @returns {number} The new length of vector.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.IntVector([1, 2, 3]);
    * // add two elements to the beggining of the vector
    * var len &#x3D; vec.unshift(4, 5); // returns 5
    */
 exports.IntVector.prototype.unshift &#x3D; function (args) { return 0; }
/**
    * Appends a second vector to the first one.
    * @param {module:la.IntVector} vec - The appended vector.
    * @returns {number} The new length property of the vectors.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create two new vectors
    * var vec &#x3D; new la.IntVector([1, 2, 3]);
    * var vec2 &#x3D; new la.IntVector([4, 5]);
    * // append the two vectors
    * vec.pushV(vec2);
    */
 exports.IntVector.prototype.pushV &#x3D; function (vec) { return 0; }
/**
    * Sums the elements in the vector.
    * @returns {number} The sum of all elements in the instance.
    * @example
    * // import la modules
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.IntVector([1, 2, 3]);
    * // sum all the elements of the vector
    * var sum &#x3D; vec.sum();
    */
 exports.IntVector.prototype.sum &#x3D; function () { return IntVectorDefaultVal; }
/**
    * Gets the index of the maximal element.
    * @returns {number} Index of the maximal element in the vector.
    * // import la modules
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.IntVector([1, 2, 3]);
    * // get the index of the maximum value
    * var idx &#x3D; vec.getMaxIdx();
    *
    */
 exports.IntVector.prototype.getMaxIdx &#x3D; function () { return 0; }
/**
    * Vector sort comparator callback.
    * @callback intVectorCompareCb
    * @param {number} arg1 - First argument.
    * @param {number} arg2 - Second argument.
    * @returns {(number | boolean)} If &#x60;intVectorCompareCb(arg1, arg2)&#x60; is less than 0 or false, sort &#x60;arg1&#x60; to a lower index than &#x60;arg2&#x60;, i.e. &#x60;arg1&#x60; comes first.
    */
/**
    * Sorts the vector (in place operation).
    * @param {(module:la~intVectorCompareCb | boolean)} [arg] - Sort callback or a boolean ascend flag. Default is boolean and true.
    * @returns {module:la.IntVector} Self.
    * &amp;lt;br&gt;1. Vector sorted in ascending order, if &#x60;arg&#x60; is boolean and true.
    * &amp;lt;br&gt;2. Vector sorted in descending order, if &#x60;arg&#x60; is boolean and false.
    * &amp;lt;br&gt;3. Vector sorted by using the comparator callback, if &#x60;arg&#x60; is a {@link module:la~intVectorCompareCb}.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.IntVector([-2, 1, 3]);
    * // sort ascending
    * vec.sort(); // sorts to: [-2, 1, 3]
    * // sort using callback
    * vec.sort(function(arg1, arg2) { return Math.abs(arg1) - Math.abs(arg2); }); // sorts to: [1, -2, 3]
    */
 skip.exports.IntVector.prototype.sort &#x3D; function (bool) { return this; }
/**
    * Sorts the vector and returns the sorted vector as well as the permutation.
    * @param {boolean} [asc &#x3D; true] - Sort in ascending order flag.
    * @returns {Object} The object &#x60;IntVectorSortResult&#x60; containing the properties:
    * &amp;lt;br&gt; &#x60;IntVectorSortResult.vec&#x60; - The sorted vector,
    * &amp;lt;br&gt; &#x60;IntVectorSortResult.perm&#x60; - Permutation vector, where &#x60;IntVectorSortResult.vec[i] &#x3D; instanceVector[IntVectorSortResult.perm[i]]&#x60;.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.IntVector([-2, 1, 3]);
    * // sort ascending
    * var result &#x3D; vec.sortPerm();
    * result.vec;  // [-2, 1, 3]
    * result.perm; // permutation index vector
    */
 skip.exports.IntVector.prototype.sortPerm &#x3D; function (asc) { return {vec: Object.create(this), perm: Object.create(require(&#x27;qminer&#x27;).la.IntVector.prototype) }; }
/**
    * Randomly reorders the elements of the vector (inplace).
    * @returns {module:la.IntVector} Self. The elements are randomly reordered.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.IntVector([-2, 1, 3]);
    * // shuffle the elements
    * vec.shuffle();
    */
 exports.IntVector.prototype.shuffle &#x3D; function () { return this; }
/**
    * Deletes elements with sprecific index or more.
    * @param {number} idx - Index (zero based).
    * @returns {module:la.IntVector} Self after truncating.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.IntVector([1, 2, 3]);
    * // trunc all elements with index 1 or more
    * vec.trunc(1); // returns vector [1]
    */
 exports.IntVector.prototype.trunc &#x3D; function (idx) { return this; }
/**
    * Creates a dense matrix A by multiplying two vectors x and y: &#x60;A &#x3D; x * y^T&#x60;.
    * @param {module:la.IntVector} vec - Second vector.
    * @returns {module:la.Matrix} Matrix obtained by the outer product of the instance and second vector.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create two new vectors
    * var x &#x3D; new la.IntVector([1, 2, 3]);
    * var y &#x3D; new la.IntVector([4, 5]);
    * // create the outer product of these vectors
    * var A &#x3D; x.outer(y); // creates the dense matrix [[4, 5], [8, 10], [12, 15]]
    */
 skip.exports.IntVector.prototype.outer &#x3D; function (vec) { return Object.create(require(&#x27;qminer&#x27;).la.Matrix.prototype); }
/**
    * Computes the inner product.
    * @param {module:la.Vector} vec - Other vector.
    * @returns {number} Inner product between the instance and the other vector.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create two new vectors
    * var x &#x3D; new la.Vector([1, 2, 3]);
    * var y &#x3D; new la.Vector([4, 5, -1]);
    * // get the inner product of the two vectors
    * var prod &#x3D; x.inner(y); // returns 11
    */
 skip.exports.Vector.prototype.inner &#x3D; function(vec) { return 0; }
/**
    * Returns the cosine between the two vectors.
    * @param {module:la.Vector} vec - Second vector.
    * @returns {number} The cosine between the two vectors.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create two new vectors
    * var x &#x3D; new la.Vector([1, 0]);
    * var y &#x3D; new la.Vector([0, 1]);
    * // calculate the cosine between those two vectors
    * var num &#x3D; x.cosine(y); // returns 0
    */
 skip.exports.Vector.prototype.cosine &#x3D; function (vec) { return 0.0; }
/**
    * Vector addition.
    * @param {module:la.Vector} vec - Second vector.
    * @returns {module:la.Vector} Sum of the instance and the second vector.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create two new vectors
    * var x &#x3D; new la.Vector([1, 2, 3]);
    * var y &#x3D; new la.Vector([4, 5, -1]);
    * // sum the vectors
    * var z &#x3D; x.plus(y);
    */
 skip.exports.Vector.prototype.plus &#x3D; function (vec) { return Object.create(this); }
/**
    * Vector substraction.
    * @param {module:la.Vector} vec - Second vector.
    * @returns {module:la.Vector} The difference of the instance and the other vector.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create two new vectors
    * var x &#x3D; new la.Vector([1, 2, 3]);
    * var y &#x3D; new la.Vector([4, 5, -1]);
    * // substract the vectors
    * var z &#x3D; x.minus(y);
    */
 skip.exports.Vector.prototype.minus &#x3D; function (vec) { return Object.create(this); }
/**
    * Multiplies the vector with a scalar.
    * @param {number} val - Scalar.
    * @returns {module:la.Vector} Product of the vector and scalar.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var x &#x3D; new la.Vector([4, 5, -1]);
    * // multiply the vector with the scalar 3
    * var y &#x3D; x.multiply(3);
    */
 skip.exports.Vector.prototype.multiply &#x3D; function (val) { return Object.create(this); }
/**
    * Normalizes vector.
    * @returns {module:la.Vector} Self. The vector is normalized.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var x &#x3D; new la.Vector([4, 5, -1]);
    * // normalize the vector
    * x.normalize();
    */
 skip.exports.Vector.prototype.normalize &#x3D; function () { return this; }
/**
    * Gives the length of vector. Type &#x60;number&#x60;.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var x &#x3D; new la.IntVector([1, 2, 3]);
    * // get the length of the vector
    * var len &#x3D; x.length; // returns 3
    */
 exports.IntVector.prototype.length &#x3D; 0;
/**
    * Returns the vector as string.
    * @returns {string} String representation.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.IntVector([1, 2, 3]);
    * // create vector as string
    * vec.toString(); // returns &#x27;1, 2, 3&#x27;
    */
 exports.IntVector.prototype.toString &#x3D; function () { return &#x27;&#x27;; }
/**
    * Creates a dense diagonal matrix out of the vector.
    * @returns{module:la.Matrix} Diagonal matrix, where the (i, i)-th element is the i-th element of vector.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.Vector([4, 5, -1]);
    * // create a dense matrix with the diagonal equal to vec
    * var mat &#x3D; vec.diag();
    */
 skip.exports.Vector.prototype.diag &#x3D; function () { return Object.create(require(&#x27;qminer&#x27;).la.Matrix.prototype); }
/**
    * Creates a sparse diagonal matrix out of the vector.
    * @returns {module:la.SparseMatrix} Diagonal matrix, where the (i, i)-th element is the i-th element of vector.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.Vector([4, 5, -1]);
    * // create a sparse matrix with the diagonal equal to vec
    * var mat &#x3D; vec.spDiag();
    */
 skip.exports.IntVector.prototype.spDiag &#x3D; function () { return Object.create(require(&#x27;qminer&#x27;).la.SparseMatrix.prototype); }
/**
    * Calculates the norm of the vector.
    * @returns {number} The norm of the vector.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.Vector([4, 5, -1]);
    * // get the norm of the vector
    * var norm &#x3D; vec.norm();
    */
 skip.exports.Vector.prototype.norm &#x3D; function () { return 0.0; }
/**
    * Creates the sparse vector representation of the vector.
    * @returns {module:la.SparseVector} The sparse vector representation.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.Vector([4, 5, -1]);
    * // create the sparse representation of the vector
    * var spVec &#x3D; vec.sparse();
    */
 skip.exports.Vector.prototype.sparse &#x3D; function () { return Object.create(require(&#x27;qminer&#x27;).la.SparseVector.prototype); }
/**
    * Creates a matrix with a single column that is equal to the vector.
    * @returns {module:la.Matrix} The matrix with a single column that is equal to the instance.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.Vector([4, 5, -1]);
    * // create a matrix representation of the vector
    * var mat &#x3D; vec.toMat();
    */
 skip.exports.Vector.prototype.toMat &#x3D; function () { return Object.create(require(&#x27;qminer&#x27;).la.Matrix.prototype); }
/**
    * Saves the vector as output stream (binary serialization).
    * @param {module:fs.FOut} fout - Output stream.
    * @returns {module:fs.FOut} The output stream &#x60;fout&#x60;.
    * @example
    * // import fs module
    * var fs &#x3D; require(&#x27;qminer&#x27;).fs;
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.IntVector([1, 2, 3]);
    * // open write stream
    * var fout &#x3D; fs.openWrite(&#x27;vec.dat&#x27;);
    * // save vector and close write stream
    * vec.save(fout).close();
    */
 exports.IntVector.prototype.save &#x3D; function (fout) {  return Object.create(require(&#x27;qminer&#x27;).fs.FOut.prototype); }
/**
    * Loads the vector from input stream (binary deserialization).
    * @param {module:fs.FIn} fin - Input stream.
    * @returns {module:la.IntVector} Self. The vector is filled using the input stream &#x60;fin&#x60;.
    * @example
    * // import fs module
    * var fs &#x3D; require(&#x27;qminer&#x27;).fs;
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create an empty vector
    * var vec &#x3D; new la.IntVector();
    * // open a read stream
    * var fin &#x3D; fs.openRead(&#x27;vec.dat&#x27;);
    * // load the vector
    * vec.load(fin);
    */
 exports.IntVector.prototype.load &#x3D; function (fin) { return this; }
/**
    * Saves the vector as output stream (ascii serialization).
    * @param {module:fs.FOut} fout - Output stream.
    * @returns {module:fs.FOut} The output stream &#x60;fout&#x60;.
    * @example
    * // import fs module
    * var fs &#x3D; require(&#x27;qminer&#x27;).fs;
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.IntVector([1, 2, 3]);
    * // open write stream
    * var fout &#x3D; fs.openWrite(&#x27;vec.dat&#x27;);
    * // save matrix and close write stream
    * vec.saveascii(fout).close();
    */
 exports.IntVector.prototype.saveascii &#x3D; function (fout) {  return Object.create(require(&#x27;qminer&#x27;).fs.FOut.prototype); }
/**
    * Loads the vector from input stream (ascii deserialization).
    * @param {module:fs.FIn} fin - Input stream.
    * @returns {module:la.IntVector} Self. The vector is filled using the input stream &#x60;fin&#x60;.
    * @example
    * // import fs module
    * var fs &#x3D; require(&#x27;qminer&#x27;).fs;
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create an empty vector
    * var vec &#x3D; new la.IntVector();
    * // open a read stream
    * var fin &#x3D; fs.openRead(&#x27;vec.dat&#x27;);
    * // load the matrix
    * vec.loadascii(fin);
    */
 exports.IntVector.prototype.loadascii &#x3D; function (fin) { return this; }

/**
 * Copyright (c) 2015, Jozef Stefan Institute, Quintelligence d.o.o. and contributors
 * All rights reserved.
 *
 * This source code is licensed under the FreeBSD license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
* Vector - array of boolean.
* @classdesc The boolean vector representation. Wraps a C++ array.
* @class
* @param {(Array.&amp;lt;boolean&gt; | module:la.BoolVector)} [arg] - Constructor arguments. There are two ways of constructing:
* &amp;lt;br&gt;1. using an array of vector elements. Example: using &#x60;[true, true, false]&#x60; creates a vector of length 3,
* &amp;lt;br&gt;2. using a vector (copy constructor).
* @example
* var la &#x3D; require(&#x27;qminer&#x27;).la;
* // create a new empty vector
* var vec &#x3D; new la.BoolVector();
* // create a new vector
* var vec2 &#x3D; new la.BoolVector([true, true, false]);
*/
 exports.BoolVector &#x3D; function() { return Object.create(require(&#x27;qminer&#x27;).la.BoolVector.prototype); }
 var BoolVectorDefaultVal &#x3D; false; // for intellisense
/**
    * Returns element at index.
    * @param {number} index - Element index (zero-based).
    * @returns {boolean} Vector element.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.BoolVector([true, true, false]);
    * // get the element at index 1
    * var el &#x3D; vec[1];
    */
 exports.BoolVector.prototype.at &#x3D; function(number) { return BoolVectorDefaultVal; }
/**
    * Returns a subvector.
    * @param {(Array.&amp;lt;number&gt; | module:la.IntVector)} arg - Index array or vector. Indices can repeat (zero based).
    * @returns {module:la.BoolVector} Subvector, where the i-th element is the &#x60;arg[i]&#x60;-th element of the instance.
    * @skip.example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.BoolVector([true, true, false]);
    * // get the subvector of the first two elements
    * var subvec &#x3D; vec.subVec([0, 1]);
    */
 skip.exports.BoolVector.prototype.subVec &#x3D; function (arg) { return Object.create(this); }
/**
    * Sets an element in vector.
    * @param {number} idx - Index (zero based).
    * @param {boolean} val - Element value.
    * @returns {module:la.BoolVector} Self. The values at index &#x60;idx&#x60; has been changed to &#x60;val&#x60;.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.BoolVector([true, true, false]);
    * // set the first element to false
    * vec.put(0, false);
    */
 exports.BoolVector.prototype.put &#x3D; function (idx, val) { return this;}
/**
    * Adds an element to the end of the vector.
    * @param {boolean} val - The element added to the vector.
    * @returns {number} The new length property of the object upon which the method was called.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.BoolVector([true, true, false]);
    * // push an element to the vector
    * vec.push(false);
    */
 exports.BoolVector.prototype.push &#x3D; function (val) { return 0; }
/**
    * Changes the vector by removing and adding elements.
    * @param {number} start - Index at which to start changing the array.
    * @param {number} deleteCount - Number of elements to be removed.
    * @param {...number} [itemN] - The element(s) to be add to the array. If no elements are given, splice() will only remove elements from the array.
    * @returns {module:la.BoolVector} Self. The selected elements are removed/replaced.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.BoolVector([true, true, false]);
    * // splice the vector by removing the last two elements and adding false, true
    * vec.splice(1, 2, false, true)// returns vector [true, false, true]
    */
 exports.BoolVector.prototype.splice &#x3D; function (start, deleteCount, itemN) { return this; }
/**
    * Adds elements to the beginning of the vector.
    * @param {...boolean} args - One or more elements to be added to the vector.
    * @returns {number} The new length of vector.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.BoolVector([true, true, false]);
    * // add two elements to the beggining of the vector
    * var len &#x3D; vec.unshift(false, true); // returns 5
    */
 exports.BoolVector.prototype.unshift &#x3D; function (args) { return 0; }
/**
    * Appends a second vector to the first one.
    * @param {module:la.BoolVector} vec - The appended vector.
    * @returns {number} The new length property of the vectors.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create two new vectors
    * var vec &#x3D; new la.BoolVector([true, true, false]);
    * var vec2 &#x3D; new la.BoolVector([false, true]);
    * // append the two vectors
    * vec.pushV(vec2);
    */
 exports.BoolVector.prototype.pushV &#x3D; function (vec) { return 0; }
/**
    * Sums the elements in the vector.
    * @returns {number} The sum of all elements in the instance.
    * @example
    * // import la modules
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.BoolVector([true, true, false]);
    * // sum all the elements of the vector
    * var sum &#x3D; vec.sum();
    */
 skip.exports.BoolVector.prototype.sum &#x3D; function () { return BoolVectorDefaultVal; }
/**
    * Gets the index of the maximal element.
    * @returns {number} Index of the maximal element in the vector.
    * // import la modules
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.BoolVector([true, true, false]);
    * // get the index of the maximum value
    * var idx &#x3D; vec.getMaxIdx();
    *
    */
 skip.exports.BoolVector.prototype.getMaxIdx &#x3D; function () { return 0; }
/**
    * Vector sort comparator callback.
    * @callback boolVectorCompareCb
    * @param {boolean} arg1 - First argument.
    * @param {boolean} arg2 - Second argument.
    * @returns {(number | boolean)} If &#x60;boolVectorCompareCb(arg1, arg2)&#x60; is less than 0 or false, sort &#x60;arg1&#x60; to a lower index than &#x60;arg2&#x60;, i.e. &#x60;arg1&#x60; comes first.
    */
/**
    * Sorts the vector (in place operation).
    * @param {(module:la~boolVectorCompareCb | boolean)} [arg] - Sort callback or a boolean ascend flag. Default is boolean and true.
    * @returns {module:la.BoolVector} Self.
    * &amp;lt;br&gt;1. Vector sorted in ascending order, if &#x60;arg&#x60; is boolean and true.
    * &amp;lt;br&gt;2. Vector sorted in descending order, if &#x60;arg&#x60; is boolean and false.
    * &amp;lt;br&gt;3. Vector sorted by using the comparator callback, if &#x60;arg&#x60; is a {@link module:la~boolVectorCompareCb}.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.BoolVector([true, false, false]);
    * // sort ascending
    * vec.sort(); // sorts to: [false, true, true]
    * // sort using callback
    * vec.sort(function(arg1, arg2) { return arg2; }); // sorts to: [false, true, true]
    */
 skip.exports.BoolVector.prototype.sort &#x3D; function (bool) { return this; }
/**
    * Sorts the vector and returns the sorted vector as well as the permutation.
    * @param {boolean} [asc &#x3D; true] - Sort in ascending order flag.
    * @returns {Object} The object &#x60;BoolVectorSortResult&#x60; containing the properties:
    * &amp;lt;br&gt; &#x60;BoolVectorSortResult.vec&#x60; - The sorted vector,
    * &amp;lt;br&gt; &#x60;BoolVectorSortResult.perm&#x60; - Permutation vector, where &#x60;BoolVectorSortResult.vec[i] &#x3D; instanceVector[BoolVectorSortResult.perm[i]]&#x60;.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.BoolVector([true, false, false]);
    * // sort ascending
    * var result &#x3D; vec.sortPerm();
    * result.vec;  // [false, true, true]
    * result.perm; // permutation index vector
    */
 skip.exports.BoolVector.prototype.sortPerm &#x3D; function (asc) { return {vec: Object.create(this), perm: Object.create(require(&#x27;qminer&#x27;).la.IntVector.prototype) }; }
/**
    * Randomly reorders the elements of the vector (inplace).
    * @returns {module:la.BoolVector} Self. The elements are randomly reordered.
    * @example
    * // import la module
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.BoolVector([true, false, false]);
    * // shuffle the elements
    * vec.shuffle();
    */
 exports.BoolVector.prototype.shuffle &#x3D; function () { return this; }
/**
    * Deletes elements with sprecific index or more.
    * @param {boolean} idx - Index (zero based).
    * @returns {module:la.BoolVector} Self after truncating.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.BoolVector([true, true, false]);
    * // trunc all elements with index 1 or more
    * vec.trunc(1); // returns vector [true]
    */
 exports.BoolVector.prototype.trunc &#x3D; function (idx) { return this; }
/**
    * Creates a dense matrix A by multiplying two vectors x and y: &#x60;A &#x3D; x * y^T&#x60;.
    * @param {module:la.BoolVector} vec - Second vector.
    * @returns {module:la.Matrix} Matrix obtained by the outer product of the instance and second vector.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create two new vectors
    * var x &#x3D; new la.BoolVector([1, 2, 3]);
    * var y &#x3D; new la.BoolVector([4, 5]);
    * // create the outer product of these vectors
    * var A &#x3D; x.outer(y); // creates the dense matrix [[4, 5], [8, 10], [12, 15]]
    */
 skip.exports.BoolVector.prototype.outer &#x3D; function (vec) { return Object.create(require(&#x27;qminer&#x27;).la.Matrix.prototype); }
/**
    * Computes the inner product.
    * @param {module:la.Vector} vec - Other vector.
    * @returns {number} Inner product between the instance and the other vector.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create two new vectors
    * var x &#x3D; new la.Vector([1, 2, 3]);
    * var y &#x3D; new la.Vector([4, 5, -1]);
    * // get the inner product of the two vectors
    * var prod &#x3D; x.inner(y); // returns 11
    */
 skip.exports.Vector.prototype.inner &#x3D; function(vec) { return 0; }
/**
    * Returns the cosine between the two vectors.
    * @param {module:la.Vector} vec - Second vector.
    * @returns {number} The cosine between the two vectors.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create two new vectors
    * var x &#x3D; new la.Vector([1, 0]);
    * var y &#x3D; new la.Vector([0, 1]);
    * // calculate the cosine between those two vectors
    * var num &#x3D; x.cosine(y); // returns 0
    */
 skip.exports.Vector.prototype.cosine &#x3D; function (vec) { return 0.0; }
/**
    * Vector addition.
    * @param {module:la.Vector} vec - Second vector.
    * @returns {module:la.Vector} Sum of the instance and the second vector.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create two new vectors
    * var x &#x3D; new la.Vector([1, 2, 3]);
    * var y &#x3D; new la.Vector([4, 5, -1]);
    * // sum the vectors
    * var z &#x3D; x.plus(y);
    */
 skip.exports.Vector.prototype.plus &#x3D; function (vec) { return Object.create(this); }
/**
    * Vector substraction.
    * @param {module:la.Vector} vec - Second vector.
    * @returns {module:la.Vector} The difference of the instance and the other vector.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create two new vectors
    * var x &#x3D; new la.Vector([1, 2, 3]);
    * var y &#x3D; new la.Vector([4, 5, -1]);
    * // substract the vectors
    * var z &#x3D; x.minus(y);
    */
 skip.exports.Vector.prototype.minus &#x3D; function (vec) { return Object.create(this); }
/**
    * Multiplies the vector with a scalar.
    * @param {number} val - Scalar.
    * @returns {module:la.Vector} Product of the vector and scalar.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var x &#x3D; new la.Vector([4, 5, -1]);
    * // multiply the vector with the scalar 3
    * var y &#x3D; x.multiply(3);
    */
 skip.exports.Vector.prototype.multiply &#x3D; function (val) { return Object.create(this); }
/**
    * Normalizes vector.
    * @returns {module:la.Vector} Self. The vector is normalized.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var x &#x3D; new la.Vector([4, 5, -1]);
    * // normalize the vector
    * x.normalize();
    */
 skip.exports.Vector.prototype.normalize &#x3D; function () { return this; }
/**
    * Gives the length of vector. Type &#x60;number&#x60;.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var x &#x3D; new la.BoolVector([true, true, false]);
    * // get the length of the vector
    * var len &#x3D; x.length; // returns 3
    */
 exports.BoolVector.prototype.length &#x3D; 0;
/**
    * Returns the vector as string.
    * @returns {string} String representation.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.BoolVector([true, true, false]);
    * // create vector as string
    * vec.toString(); // returns &#x27;true, true, false&#x27;
    */
 exports.BoolVector.prototype.toString &#x3D; function () { return &#x27;&#x27;; }
/**
    * Creates a dense diagonal matrix out of the vector.
    * @returns{module:la.Matrix} Diagonal matrix, where the (i, i)-th element is the i-th element of vector.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.Vector([4, 5, -1]);
    * // create a dense matrix with the diagonal equal to vec
    * var mat &#x3D; vec.diag();
    */
 skip.exports.Vector.prototype.diag &#x3D; function () { return Object.create(require(&#x27;qminer&#x27;).la.Matrix.prototype); }
/**
    * Creates a sparse diagonal matrix out of the vector.
    * @returns {module:la.SparseMatrix} Diagonal matrix, where the (i, i)-th element is the i-th element of vector.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.Vector([4, 5, -1]);
    * // create a sparse matrix with the diagonal equal to vec
    * var mat &#x3D; vec.spDiag();
    */
 skip.exports.BoolVector.prototype.spDiag &#x3D; function () { return Object.create(require(&#x27;qminer&#x27;).la.SparseMatrix.prototype); }
/**
    * Calculates the norm of the vector.
    * @returns {number} The norm of the vector.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.Vector([4, 5, -1]);
    * // get the norm of the vector
    * var norm &#x3D; vec.norm();
    */
 skip.exports.Vector.prototype.norm &#x3D; function () { return 0.0; }
/**
    * Creates the sparse vector representation of the vector.
    * @returns {module:la.SparseVector} The sparse vector representation.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.Vector([4, 5, -1]);
    * // create the sparse representation of the vector
    * var spVec &#x3D; vec.sparse();
    */
 skip.exports.Vector.prototype.sparse &#x3D; function () { return Object.create(require(&#x27;qminer&#x27;).la.SparseVector.prototype); }
/**
    * Creates a matrix with a single column that is equal to the vector.
    * @returns {module:la.Matrix} The matrix with a single column that is equal to the instance.
    * @example
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.Vector([4, 5, -1]);
    * // create a matrix representation of the vector
    * var mat &#x3D; vec.toMat();
    */
 skip.exports.Vector.prototype.toMat &#x3D; function () { return Object.create(require(&#x27;qminer&#x27;).la.Matrix.prototype); }
/**
    * Saves the vector as output stream (binary serialization).
    * @param {module:fs.FOut} fout - Output stream.
    * @returns {module:fs.FOut} The output stream &#x60;fout&#x60;.
    * @example
    * // import fs module
    * var fs &#x3D; require(&#x27;qminer&#x27;).fs;
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.BoolVector([true, true, false]);
    * // open write stream
    * var fout &#x3D; fs.openWrite(&#x27;vec.dat&#x27;);
    * // save vector and close write stream
    * vec.save(fout).close();
    */
 exports.BoolVector.prototype.save &#x3D; function (fout) {  return Object.create(require(&#x27;qminer&#x27;).fs.FOut.prototype); }
/**
    * Loads the vector from input stream (binary deserialization).
    * @param {module:fs.FIn} fin - Input stream.
    * @returns {module:la.BoolVector} Self. The vector is filled using the input stream &#x60;fin&#x60;.
    * @example
    * // import fs module
    * var fs &#x3D; require(&#x27;qminer&#x27;).fs;
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create an empty vector
    * var vec &#x3D; new la.BoolVector();
    * // open a read stream
    * var fin &#x3D; fs.openRead(&#x27;vec.dat&#x27;);
    * // load the vector
    * vec.load(fin);
    */
 exports.BoolVector.prototype.load &#x3D; function (fin) { return this; }
/**
    * Saves the vector as output stream (ascii serialization).
    * @param {module:fs.FOut} fout - Output stream.
    * @returns {module:fs.FOut} The output stream &#x60;fout&#x60;.
    * @example
    * // import fs module
    * var fs &#x3D; require(&#x27;qminer&#x27;).fs;
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create a new vector
    * var vec &#x3D; new la.BoolVector([true, true, false]);
    * // open write stream
    * var fout &#x3D; fs.openWrite(&#x27;vec.dat&#x27;);
    * // save matrix and close write stream
    * vec.saveascii(fout).close();
    */
 exports.BoolVector.prototype.saveascii &#x3D; function (fout) {  return Object.create(require(&#x27;qminer&#x27;).fs.FOut.prototype); }
/**
    * Loads the vector from input stream (ascii deserialization).
    * @param {module:fs.FIn} fin - Input stream.
    * @returns {module:la.BoolVector} Self. The vector is filled using the input stream &#x60;fin&#x60;.
    * @example
    * // import fs module
    * var fs &#x3D; require(&#x27;qminer&#x27;).fs;
    * var la &#x3D; require(&#x27;qminer&#x27;).la;
    * // create an empty vector
    * var vec &#x3D; new la.BoolVector();
    * // open a read stream
    * var fin &#x3D; fs.openRead(&#x27;vec.dat&#x27;);
    * // load the matrix
    * vec.loadascii(fin);
    */
 exports.BoolVector.prototype.loadascii &#x3D; function (fin) { return this; }

</code></pre>
            </article>
                                        </div>
                                </div>
                                <nav id="jsdoc-toc-nav" role="navigation"></nav>
                        </div>
                </div>
                    <footer id="jsdoc-footer" class="jsdoc-footer">
                            <div id="jsdoc-footer-container">
                                    <p>
                                      
                                    </p>
                            </div>
                    </footer>
                <script src="scripts/jquery.min.js"></script>
                <script src="scripts/tree.jquery.js"></script>
                <script src="scripts/prettify.js"></script>
                <script src="scripts/jsdoc-toc.js"></script>
                <script src="scripts/linenumber.js"></script>
                <script src="scripts/scrollanchor.js"></script>
        </body>
</html>
