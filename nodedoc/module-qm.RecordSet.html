<!doctype html>
<html>

<head>
  <meta name="generator" content="JSDoc 3">
  <meta charset="utf-8">
  <title>Class: RecordSet</title>
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Karla:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Noto+Serif:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Inconsolata:500" type="text/css">
  <link href="css/baseline.css" rel="stylesheet">
</head>

<body onload="prettyPrint()">
  <nav id="jsdoc-navbar" role="navigation" class="jsdoc-navbar">
    <div id="jsdoc-navbar-container">
      <div id="jsdoc-navbar-content">
        <a href="index.html" class="jsdoc-navbar-package-name">QMiner JavaScript API v9.3.1</a>
      </div>
    </div>
  </nav>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <div class="symbol-detail-labels"><span class="label label-kind">class</span>&nbsp;<span class="label label-static">static</span></div>
            <h1><small><a href="module-qm.html">qm</a>.<wbr></small><span class="symbol-name">RecordSet</span></h1>
            <p class="source-link">Source: <a href="qminerdoc.js.html#source-line-1706">qminerdoc.<wbr>js:1706</a></p>
            <dl class="dl-compact">
            </dl>
          </header>
          <section id="summary">
            <div class="summary-callout">
              <h2 class="summary-callout-heading">Properties</h2>
              <div class="summary-content">
                <div class="summary-column">
                  <dl class="dl-summary-callout">
                    <dt><a href="module-qm.RecordSet.html#empty">empty</a></dt>
                    <dd>
                    </dd>
                    <dt><a href="module-qm.RecordSet.html#length">length</a></dt>
                    <dd>
                    </dd>
                  </dl>
                </div>
                <div class="summary-column">
                  <dl class="dl-summary-callout">
                    <dt><a href="module-qm.RecordSet.html#store">store</a></dt>
                    <dd>
                    </dd>
                    <dt><a href="module-qm.RecordSet.html#weighted">weighted</a></dt>
                    <dd>
                    </dd>
                  </dl>
                </div>
                <div class="summary-column">
                </div>
              </div>
            </div>
            <div class="summary-callout">
              <h2 class="summary-callout-heading">Methods</h2>
              <div class="summary-content">
                <div class="summary-column">
                  <dl class="dl-summary-callout">
                    <dt><a href="module-qm.RecordSet.html#clone">clone()</a></dt>
                    <dd>
                    </dd>
                    <dt><a href="module-qm.RecordSet.html#deleteRecords">deleteRecords(rs)</a></dt>
                    <dd>
                    </dd>
                    <dt><a href="module-qm.RecordSet.html#each">each(callback)</a></dt>
                    <dd>
                    </dd>
                    <dt><a href="module-qm.RecordSet.html#filter">filter(callback)</a></dt>
                    <dd>
                    </dd>
                    <dt><a href="module-qm.RecordSet.html#filterByField">filterByField(fieldName, minVal, maxVal)</a></dt>
                    <dd>
                    </dd>
                    <dt><a href="module-qm.RecordSet.html#filterByFq">filterByFq([minFq][, maxFq])</a></dt>
                    <dd>
                    </dd>
                    <dt><a href="module-qm.RecordSet.html#filterById">filterById([minId][, maxId])</a></dt>
                    <dd>
                    </dd>
                    <dt><a href="module-qm.RecordSet.html#getMatrix">getMatrix(fieldName)</a></dt>
                    <dd>
                    </dd>
                  </dl>
                </div>
                <div class="summary-column">
                  <dl class="dl-summary-callout">
                    <dt><a href="module-qm.RecordSet.html#getVector">getVector(fieldName)</a></dt>
                    <dd>
                    </dd>
                    <dt><a href="module-qm.RecordSet.html#join">join(joinName[, sampleSize])</a></dt>
                    <dd>
                    </dd>
                    <dt><a href="module-qm.RecordSet.html#map">map(callback)</a></dt>
                    <dd>
                    </dd>
                    <dt><a href="module-qm.RecordSet.html#reverse">reverse()</a></dt>
                    <dd>
                    </dd>
                    <dt><a href="module-qm.RecordSet.html#sample">sample(num)</a></dt>
                    <dd>
                    </dd>
                    <dt><a href="module-qm.RecordSet.html#setDiff">setDiff(rs)</a></dt>
                    <dd>
                    </dd>
                    <dt><a href="module-qm.RecordSet.html#setIntersect">setIntersect(rs)</a></dt>
                    <dd>
                    </dd>
                    <dt><a href="module-qm.RecordSet.html#setUnion">setUnion(rs)</a></dt>
                    <dd>
                    </dd>
                  </dl>
                </div>
                <div class="summary-column">
                  <dl class="dl-summary-callout">
                    <dt><a href="module-qm.RecordSet.html#shuffle">shuffle([seed])</a></dt>
                    <dd>
                    </dd>
                    <dt><a href="module-qm.RecordSet.html#sort">sort(callback)</a></dt>
                    <dd>
                    </dd>
                    <dt><a href="module-qm.RecordSet.html#sortByField">sortByField(fieldName[, asc])</a></dt>
                    <dd>
                    </dd>
                    <dt><a href="module-qm.RecordSet.html#sortByFq">sortByFq([asc])</a></dt>
                    <dd>
                    </dd>
                    <dt><a href="module-qm.RecordSet.html#sortById">sortById([asc])</a></dt>
                    <dd>
                    </dd>
                    <dt><a href="module-qm.RecordSet.html#split">split(callback)</a></dt>
                    <dd>
                    </dd>
                    <dt><a href="module-qm.RecordSet.html#toJSON">toJSON()</a></dt>
                    <dd>
                    </dd>
                    <dt><a href="module-qm.RecordSet.html#trunc">trunc(limit_num[, offset_num])</a></dt>
                    <dd>
                    </dd>
                  </dl>
                </div>
              </div>
            </div>
          </section>
          <section>
            <h2 id="RecordSet"><span class="symbol-name">RecordSet</span><span class="signature"><span class="signature-params">()</span></span></h2>
            <p>Record Set is a set of records. <br>
              <b>Factory pattern</b>: this class cannot be construced using the new keyword. This class is constructed
              when calling a specific method or attribute, e.g. using <a href="module-qm.Store.html#allRecords">module:qm.Store#allRecords</a> to get all the records
              in the store as a record set.
            </p>
            <dl class="dl-compact">
            </dl>
          </section>
          <section>
            <h2>Properties</h2>
            <section>
              <h3 id="empty"><span class="symbol-name">empty</span></h3>
              <p>Checks if the record set is empty. If the record set is empty, then it returns true. Otherwise, it returns false. Type <code>boolean</code>.</p>
              <dl class="dl-compact">
              </dl>
              <h3 id="length"><span class="symbol-name">length</span></h3>
              <p>Returns the number of records in record set. Type <code>number</code>.</p>
              <dl class="dl-compact">
              </dl>
              <h3 id="store"><span class="symbol-name">store</span></h3>
              <p>Returns the store, where the records in the record set are stored. Type <a href="module-qm.Store.html">module:qm.Store</a>.</p>
              <dl class="dl-compact">
              </dl>
              <h3 id="weighted"><span class="symbol-name">weighted</span></h3>
              <p>Checks if the record set is weighted. If the record set is weighted, then it returns true. Otherwise, it returns false. Type <code>boolean</code>.</p>
              <dl class="dl-compact">
              </dl>
            </section>
            <h2>Methods</h2>
            <section>
              <h3 id="clone"><span class="symbol-name">clone</span><span class="signature"><span class="signature-params">()</span>&nbsp;&rarr; <span class="signature-returns"> <a href="module-qm.RecordSet.html">module:qm.RecordSet</a></span></span></h3>
              <p>Creates a new instance of the record set.</p>
              <section>
                <h4>
                  Example
                </h4>
                <div>
                  <pre class="prettyprint"><code>// import qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a new base containing one store
var base &#x3D; new qm.Base({
   mode: &quot;createClean&quot;,
   schema: [{
       name: &quot;Philosophers&quot;,
       fields: [
           { name: &quot;Name&quot;, type: &quot;string&quot; },
           { name: &quot;Era&quot;, type: &quot;string&quot; }
       ]
   }]
});
// put some records in the store
base.store(&quot;Philosophers&quot;).push({ Name: &quot;Plato&quot;, Era: &quot;Ancient philosophy&quot; });
base.store(&quot;Philosophers&quot;).push({ Name: &quot;Immanuel Kant&quot;, Era: &quot;18th-century philosophy&quot; });
base.store(&quot;Philosophers&quot;).push({ Name: &quot;Emmanuel Levinas&quot;, Era: &quot;20th-century philosophy&quot; });
base.store(&quot;Philosophers&quot;).push({ Name: &quot;Rene Descartes&quot;, Era: &quot;17th-century philosophy&quot; });
base.store(&quot;Philosophers&quot;).push({ Name: &quot;Confucius&quot;, Era: &quot;Ancient philosophy&quot; });
// create a record set out of the records in store
var recordSet &#x3D; base.store(&quot;Philosophers&quot;).allRecords;
// clone the record set of the &quot;Philosophers&quot; store
var philosophers &#x3D; recordSet.clone();
base.close();</code></pre>
                </div>
              </section>
              <dl class="dl-compact">
                <dt>Returns</dt>
                <dd>
                  <p><code><a href="module-qm.RecordSet.html">module:qm.RecordSet</a></code>B A copy of the record set.</p>
                </dd>
              </dl>
              <h3 id="deleteRecords"><span class="symbol-name">deleteRecords</span><span class="signature"><span class="signature-params">(rs)</span>&nbsp;&rarr; <span class="signature-returns"> <a href="module-qm.RecordSet.html">module:qm.RecordSet</a></span></span></h3>
              <p>Deletes the records, that are also in the second record set.</p>
              <section>
                <h4>
                  Example
                </h4>
                <div>
                  <pre class="prettyprint"><code>// import qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a new base containing one store
var base &#x3D; new qm.Base({
   mode: &quot;createClean&quot;,
   schema: [{
       name: &quot;BookWriters&quot;,
       fields: [
           { name: &quot;Name&quot;, type: &quot;string&quot; },
           { name: &quot;Genre&quot;, type: &quot;string&quot; },
           { name: &quot;Books&quot;, type: &quot;string_v&quot; }
       ]
   }]
});
// set new records in the store
base.store(&quot;BookWriters&quot;).push({ Name: &quot;Terry Pratchett&quot;, Genre: &quot;Fantasy&quot;, Books: [&quot;The Colour of Magic&quot;, &quot;Going Postal&quot;, &quot;Mort&quot;, &quot;Guards! Guards!&quot;] });
base.store(&quot;BookWriters&quot;).push({ Name: &quot;Douglas Adams&quot;, Genre: &quot;Sci-fi&quot;, Books: [&quot;The Hitchhiker&#x27;s Guide to the Galaxy&quot;, &quot;So Long, and Thanks for All the Fish&quot;] });
base.store(&quot;BookWriters&quot;).push({ Name: &quot;Fyodor Dostoyevsky&quot;, Genre: &quot;Drama&quot;, Books: [&quot;Crime and Punishment&quot;, &quot;Demons&quot;] });
base.store(&quot;BookWriters&quot;).push({ Name: &quot;J.R.R. Tolkien&quot;, Genre: &quot;Fantasy&quot;, Books: [&quot;The Hobbit&quot;, &quot;The Two Towers&quot;, &quot;The Silmarillion&quot; ] });
base.store(&quot;BookWriters&quot;).push({ Name: &quot;George R.R. Martin&quot;, Genre: &quot;Fantasy&quot;, Books: [&quot;A Game of Thrones&quot;, &quot;A Feast of Crows&quot;] });
base.store(&quot;BookWriters&quot;).push({ Name: &quot;J. K. Rowling&quot;, Genre: &quot;Fantasy&quot;, Books: [&quot;Harry Potter and the Philosopher&#x27;s Stone&quot;] });
base.store(&quot;BookWriters&quot;).push({ Name: &quot;Ivan Cankar&quot;, Genre: &quot;Drama&quot;, Books: [&quot;On the Hill&quot;, &quot;The King of Betajnova&quot;, &quot;The Serfs&quot;] });
// create one record set containing all records of store
var recordSet &#x3D; base.store(&quot;BookWriters&quot;).allRecords;
// create one record set containing the records with genre &quot;Fantasy&quot;
var fantasy &#x3D; base.store(&quot;BookWriters&quot;).allRecords.filterByField(&quot;Genre&quot;, &quot;Fantasy&quot;);
// delete the records in recordSet, that are also in fantasy
recordSet.deleteRecords(fantasy); // returns self, containing only three records: &quot;Douglas Adams&quot;, &quot;Fyodor Dostoyevsky&quot; and &quot;Ivan Cankar&quot;
base.close();</code></pre>
                </div>
              </section>
              <section>
                <h4>Parameter</h4>
                <table class="jsdoc-details-table">
                  <thead>
                    <tr>
                      <th>Name</th>
                      <th>Type</th>
                      <th>Optional</th>
                      <th>Description</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <p>rs</p>
                      </td>
                      <td>
                        <p><a href="module-qm.RecordSet.html">module:qm.RecordSet</a></p>
                      </td>
                      <td>
                        <p>&nbsp;</p>
                      </td>
                      <td>
                        <p>The second record set.</p>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </section>
              <dl class="dl-compact">
                <dt>Returns</dt>
                <dd>
                  <p><code><a href="module-qm.RecordSet.html">module:qm.RecordSet</a></code>B Self. Contains only the records, that are not in <code>rs</code>.</p>
                </dd>
              </dl>
              <h3 id="each"><span class="symbol-name">each</span><span class="signature"><span class="signature-params">(callback)</span>&nbsp;&rarr; <span class="signature-returns"> <a href="module-qm.RecordSet.html">module:qm.RecordSet</a></span></span></h3>
              <p>Executes a function on each record in record set.</p>
              <section>
                <h4>
                  Example
                </h4>
                <div>
                  <pre class="prettyprint"><code>// import qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a new base containing one store
var base &#x3D; new qm.Base({
   mode: &quot;createClean&quot;,
   schema: [{
       name: &quot;People&quot;,
       fields: [
           { name: &quot;Name&quot;, type: &quot;string&quot; },
           { name: &quot;Gender&quot;, type: &quot;string&quot; }
       ]
   }]
});
// put some records in the store
base.store(&quot;People&quot;).push({ Name: &quot;Eric Sugar&quot;, Gender: &quot;Male&quot; });
base.store(&quot;People&quot;).push({ Name: &quot;Jane Tokyo&quot;, Gender: &quot;Female&quot; });
base.store(&quot;People&quot;).push({ Name: &quot;Mister Tea&quot;, Gender: &quot;Male&quot; });
// create a record set out of the records of the store
var recordSet &#x3D; base.store(&quot;People&quot;).allRecords;
// change the Name of all records into &quot;Anonymous&quot;
recordSet.each(function (rec) { rec.Name &#x3D; &quot;Anonymous&quot;; }); // returns self, all record&#x27;s Name are &quot;Anonymous&quot;
base.close();</code></pre>
                </div>
              </section>
              <section>
                <h4>Parameter</h4>
                <table class="jsdoc-details-table">
                  <thead>
                    <tr>
                      <th>Name</th>
                      <th>Type</th>
                      <th>Optional</th>
                      <th>Description</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <p>callback</p>
                      </td>
                      <td>
                        <p>function()</p>
                      </td>
                      <td>
                        <p>&nbsp;</p>
                      </td>
                      <td>
                        <p>Function to be executed. It takes two parameters:
                          <br>1. <code>rec</code> - The current record. Type <a href="module-qm.Record.html">module:qm.Record</a>. Warning: Do not use <code>rec</code> outside the scope of the callback. An internal optimization re-uses <code>rec</code> object between calls to <code>callback</code>.
                          <br>2. <code>idx</code> - The index of the current record (<i>optional</i>). Type <code>number</code>.
                        </p>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </section>
              <dl class="dl-compact">
                <dt>Returns</dt>
                <dd>
                  <p><code><a href="module-qm.RecordSet.html">module:qm.RecordSet</a></code>B Self.</p>
                </dd>
              </dl>
              <h3 id="filter"><span class="symbol-name">filter</span><span class="signature"><span class="signature-params">(callback)</span>&nbsp;&rarr; <span class="signature-returns"> <a href="module-qm.RecordSet.html">module:qm.RecordSet</a></span></span></h3>
              <p>Keeps only the records that pass the callback function.</p>
              <section>
                <h4>
                  Example
                </h4>
                <div>
                  <pre class="prettyprint"><code>// import qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a new base containing one store
var base &#x3D; new qm.Base({
   mode: &quot;createClean&quot;,
   schema: [{
       name: &quot;ArcheryChampionship&quot;,
       fields: [
           { name: &quot;Name&quot;, type: &quot;string&quot; },
           { name: &quot;ScorePerRound&quot;, type: &quot;float_v&quot; }
       ]
   }]
});
// set new records in the store
base.store(&quot;ArcheryChampionship&quot;).push({ Name: &quot;Robin Hood&quot;, ScorePerRound: [50, 48, 48] });
base.store(&quot;ArcheryChampionship&quot;).push({ Name: &quot;Oliver Queen&quot;, ScorePerRound: [44, 46, 44] });
base.store(&quot;ArcheryChampionship&quot;).push({ Name: &quot;Legolas&quot;, ScorePerRound: [50, 50, 48] });
// create a record set out of the records of the store
var recordSet &#x3D; base.store(&quot;ArcheryChampionship&quot;).allRecords;
// filter the records: which archers have scored 48 points in the third round
recordSet.filter(function (rec) { return rec.ScorePerRound[2] &#x3D;&#x3D; 48; }); // keeps only the records, where the score of the third round is equal 48
base.close();</code></pre>
                </div>
              </section>
              <section>
                <h4>Parameter</h4>
                <table class="jsdoc-details-table">
                  <thead>
                    <tr>
                      <th>Name</th>
                      <th>Type</th>
                      <th>Optional</th>
                      <th>Description</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <p>callback</p>
                      </td>
                      <td>
                        <p>function()</p>
                      </td>
                      <td>
                        <p>&nbsp;</p>
                      </td>
                      <td>
                        <p>The filter function. It takes one parameter:
                          <br>1. <code>rec</code> - The record in the record set. Type <a href="module-qm.Record.html">module:qm.Record</a>.
                          <br> Returns a <code>boolean</code> value.
                        </p>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </section>
              <dl class="dl-compact">
                <dt>Returns</dt>
                <dd>
                  <p><code><a href="module-qm.RecordSet.html">module:qm.RecordSet</a></code>B Self. Contains only the records that pass the callback function.</p>
                </dd>
              </dl>
              <h3 id="filterByField"><span class="symbol-name">filterByField</span><span class="signature"><span class="signature-params">(fieldName, minVal, maxVal)</span>&nbsp;&rarr; <span class="signature-returns"> <a href="module-qm.RecordSet.html">module:qm.RecordSet</a></span></span></h3>
              <p>Keeps only the records with a specific value of some field.</p>
              <section>
                <h4>
                  Example
                </h4>
                <div>
                  <pre class="prettyprint"><code>// import qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a new base containing one store
var base &#x3D; new qm.Base({
   mode: &quot;createClean&quot;,
   schema: [{
       name: &quot;WeatherForcast&quot;,
       fields: [
           { name: &quot;Weather&quot;, type: &quot;string&quot; },
           { name: &quot;Date&quot;, type: &quot;datetime&quot; },
           { name: &quot;TemperatureDegrees&quot;, type: &quot;int&quot; },
       ]
   }]
});
// put some records in the &quot;WeatherForecast&quot; store
base.store(&quot;WeatherForcast&quot;).push({ Weather: &quot;Partly Cloudy&quot;, Date: &quot;2015-05-27T11:00:00&quot;, TemperatureDegrees: 19 });
base.store(&quot;WeatherForcast&quot;).push({ Weather: &quot;Partly Cloudy&quot;, Date: &quot;2015-05-28T11:00:00&quot;, TemperatureDegrees: 22 });
base.store(&quot;WeatherForcast&quot;).push({ Weather: &quot;Mostly Cloudy&quot;, Date: &quot;2015-05-29T11:00:00&quot;, TemperatureDegrees: 25 });
base.store(&quot;WeatherForcast&quot;).push({ Weather: &quot;Mostly Cloudy&quot;, Date: &quot;2015-05-30T11:00:00&quot;, TemperatureDegrees: 25 });
base.store(&quot;WeatherForcast&quot;).push({ Weather: &quot;Scattered Showers&quot;, Date: &quot;2015-05-31T11:00:00&quot;, TemperatureDegrees: 24 });
base.store(&quot;WeatherForcast&quot;).push({ Weather: &quot;Mostly Cloudy&quot;, Date: &quot;2015-06-01T11:00:00&quot;, TemperatureDegrees: 27 });
// get the record set containing the records from the &quot;WeatherForcast&quot; store
var recordSet &#x3D; base.store(&quot;WeatherForcast&quot;).allRecords;
// filter only the records, where the weather is Mostly Cloudy
recordSet.filterByField(&quot;Weather&quot;, &quot;Mostly Cloudy&quot;); // returns self, containing only the records, where the weather is &quot;Mostly Cloudy&quot;
base.close();</code></pre>
                </div>
              </section>
              <section>
                <h4>Parameters</h4>
                <table class="jsdoc-details-table">
                  <thead>
                    <tr>
                      <th>Name</th>
                      <th>Type</th>
                      <th>Optional</th>
                      <th>Description</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <p>fieldName</p>
                      </td>
                      <td>
                        <p>string</p>
                      </td>
                      <td>
                        <p>&nbsp;</p>
                      </td>
                      <td>
                        <p>The field by which the records will be filtered.</p>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <p>minVal</p>
                      </td>
                      <td>
                        <p>(string or number)</p>
                      </td>
                      <td>
                        <p>&nbsp;</p>
                      </td>
                      <td>
                        <p><br>1. If the field type is a <code>string</code>, the exact string to compare. Type <code>number</code>.
                          <br>2. If the field type is a <code>number</code>, the minimal value for comparison. Type <code>number</code>.
                          <br>3. TODO Time field
                        </p>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <p>maxVal</p>
                      </td>
                      <td>
                        <p>number</p>
                      </td>
                      <td>
                        <p>&nbsp;</p>
                      </td>
                      <td>
                        <p>Only in combination with <code>minVal</code> for non-string fields. The maximal value for comparison.</p>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </section>
              <dl class="dl-compact">
                <dt>Returns</dt>
                <dd>
                  <p><code><a href="module-qm.RecordSet.html">module:qm.RecordSet</a></code>B Self.
                    <br>1. If the <code>fieldName</code> field type is <code>number</code>, contains only the records with the <code>fieldName</code> value between <code>minVal</code> and <code>maxVal</code>.
                    <br>2. If the <code>fieldName</code> field type is <code>string</code>, contains only the records with <code>fieldName</code> equal to <code>minVal</code>.
                  </p>
                </dd>
              </dl>
              <h3 id="filterByFq"><span class="symbol-name">filterByFq</span><span class="signature"><span class="signature-params">([minFq][, maxFq])</span>&nbsp;&rarr; <span class="signature-returns"> <a href="module-qm.RecordSet.html">module:qm.RecordSet</a></span></span></h3>
              <p>Keeps only the records with weight between two values.</p>
              <section>
                <h4>Parameters</h4>
                <table class="jsdoc-details-table">
                  <thead>
                    <tr>
                      <th>Name</th>
                      <th>Type</th>
                      <th>Optional</th>
                      <th>Description</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <p>minFq</p>
                      </td>
                      <td>
                        <p>number</p>
                      </td>
                      <td>
                        <p>Yes</p>
                      </td>
                      <td>
                        <p>The minimum value.</p>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <p>maxFq</p>
                      </td>
                      <td>
                        <p>number</p>
                      </td>
                      <td>
                        <p>Yes</p>
                      </td>
                      <td>
                        <p>The maximum value.</p>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </section>
              <dl class="dl-compact">
                <dt>Returns</dt>
                <dd>
                  <p><code><a href="module-qm.RecordSet.html">module:qm.RecordSet</a></code>B Self.
                    <br>1. Contains only the records of the original with weights between <code>minFq</code> and <code>maxFq</code>, if parameters are given.
                    <br>2. Contains all the records of the original, if no parameter is given.
                  </p>
                </dd>
              </dl>
              <h3 id="filterById"><span class="symbol-name">filterById</span><span class="signature"><span class="signature-params">([minId][, maxId])</span>&nbsp;&rarr; <span class="signature-returns"> <a href="module-qm.RecordSet.html">module:qm.RecordSet</a></span></span></h3>
              <p>Keeps only records with ids between or equal two values.</p>
              <section>
                <h4>
                  Example
                </h4>
                <div>
                  <pre class="prettyprint"><code>// import qm require
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a new base containing one store
var base &#x3D; new qm.Base({
   mode: &quot;createClean&quot;,
   schema: [{
       name: &quot;FrankSinatraGreatestHits&quot;,
       fields: [
           { name: &quot;Title&quot;, type: &quot;string&quot; },
           { name: &quot;Length&quot;, type: &quot;int&quot; }
       ]
   }]
});
// put some records in the &quot;FrankSinatraGreatesHits&quot; store
base.store(&quot;FrankSinatraGreatestHits&quot;).push({ Title: &quot;Strangers in the Night&quot;, Length: 145 });
base.store(&quot;FrankSinatraGreatestHits&quot;).push({ Title: &quot;Summer Wind&quot;, Length: 173 });
base.store(&quot;FrankSinatraGreatestHits&quot;).push({ Title: &quot;It Was a Very Good Year&quot;, Length: 265 });
base.store(&quot;FrankSinatraGreatestHits&quot;).push({ Title: &quot;Somewhere in Your Heart&quot;, Length: 146 });
base.store(&quot;FrankSinatraGreatestHits&quot;).push({ Title: &quot;Forget Domani&quot;, Length: 156 });
base.store(&quot;FrankSinatraGreatestHits&quot;).push({ Title: &quot;Somethin&#x27; Stupid&quot;, Length: 155 });
base.store(&quot;FrankSinatraGreatestHits&quot;).push({ Title: &quot;This Town&quot;, Length: 186 });
// get the records of the store as a record set
var recordSet &#x3D; base.store(&quot;FrankSinatraGreatestHits&quot;).allRecords;
// from the record set keep the records with indeces between or equal 2 and 5
recordSet.filterById(2, 5);
base.close();</code></pre>
                </div>
              </section>
              <section>
                <h4>Parameters</h4>
                <table class="jsdoc-details-table">
                  <thead>
                    <tr>
                      <th>Name</th>
                      <th>Type</th>
                      <th>Optional</th>
                      <th>Description</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <p>minId</p>
                      </td>
                      <td>
                        <p>number</p>
                      </td>
                      <td>
                        <p>Yes</p>
                      </td>
                      <td>
                        <p>The minimum id.</p>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <p>maxId</p>
                      </td>
                      <td>
                        <p>number</p>
                      </td>
                      <td>
                        <p>Yes</p>
                      </td>
                      <td>
                        <p>The maximum id.</p>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </section>
              <dl class="dl-compact">
                <dt>Returns</dt>
                <dd>
                  <p><code><a href="module-qm.RecordSet.html">module:qm.RecordSet</a></code>B Self.
                    <br>1. Contains only the records of the original with IDs between <code>minId</code> and <code>maxId</code>, if parameters are given.
                    <br>2. Contains all the records of the original, if no parameter is given.
                  </p>
                </dd>
              </dl>
              <h3 id="getMatrix"><span class="symbol-name">getMatrix</span><span class="signature"><span class="signature-params">(fieldName)</span>&nbsp;&rarr; <span class="signature-returns"> (<a href="module-la.Matrix.html">module:la.Matrix</a> or <a href="module-la.SparseMatrix.html">module:la.SparseMatrix</a>)</span></span></h3>
              <p>Creates a vector containing the field values of records.</p>
              <section>
                <h4>
                  Example
                </h4>
                <div>
                  <pre class="prettyprint"><code>// import qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a new base containing one store
var base &#x3D; new qm.Base({
   mode: &quot;createClean&quot;,
   schema: [{
       name: &quot;ArcheryChampionship&quot;,
       fields: [
           { name: &quot;Name&quot;, type: &quot;string&quot; },
           { name: &quot;ScorePerRound&quot;, type: &quot;float_v&quot; }
       ]
   }]
});
// set new records in the store
base.store(&quot;ArcheryChampionship&quot;).push({ Name: &quot;Robin Hood&quot;, ScorePerRound: [50, 48, 48] });
base.store(&quot;ArcheryChampionship&quot;).push({ Name: &quot;Oliver Queen&quot;, ScorePerRound: [44, 46, 44] });
base.store(&quot;ArcheryChampionship&quot;).push({ Name: &quot;Legolas&quot;, ScorePerRound: [50, 50, 48] });
// create a record set of the records in store
var recordSet &#x3D; base.store(&quot;ArcheryChampionship&quot;).allRecords;
// create a matrix from the &quot;ScorePerRound&quot; field
// the i-th column of the matrix is the data of the i-th record in record set
// the matrix will look like
// 50  44  50
// 48  46  50
// 48  44  48
var matrix &#x3D; recordSet.getMatrix(&quot;ScorePerRound&quot;);
base.close();</code></pre>
                </div>
              </section>
              <section>
                <h4>Parameter</h4>
                <table class="jsdoc-details-table">
                  <thead>
                    <tr>
                      <th>Name</th>
                      <th>Type</th>
                      <th>Optional</th>
                      <th>Description</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <p>fieldName</p>
                      </td>
                      <td>
                        <p>string</p>
                      </td>
                      <td>
                        <p>&nbsp;</p>
                      </td>
                      <td>
                        <p>The field from which to take the values. It's type must be numeric, e.g. <code>int</code>, <code>float</code>, <code>float_v</code>, <code>num_sp_v</code>...</p>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </section>
              <dl class="dl-compact">
                <dt>Returns</dt>
                <dd>
                  <p><code>(<a href="module-la.Matrix.html">module:la.Matrix</a> or <a href="module-la.SparseMatrix.html">module:la.SparseMatrix</a>)</code>B The matrix containing the field values of records.</p>
                </dd>
              </dl>
              <h3 id="getVector"><span class="symbol-name">getVector</span><span class="signature"><span class="signature-params">(fieldName)</span>&nbsp;&rarr; <span class="signature-returns"> <a href="module-la.Vector.html">module:la.Vector</a></span></span></h3>
              <p>Creates a vector containing the field values of records.</p>
              <section>
                <h4>
                  Example
                </h4>
                <div>
                  <pre class="prettyprint"><code>// import qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a base containing one store
var base &#x3D; new qm.Base({
   mode: &quot;createClean&quot;,
   schema: [{
       name: &quot;TVSeries&quot;,
       fields: [
           { name: &quot;Title&quot;, type: &quot;string&quot;, &quot;primary&quot;: true },
           { name: &quot;NumberOfEpisodes&quot;, type: &quot;int&quot; }
       ]
   }]
});
// add some records in the store
base.store(&quot;TVSeries&quot;).push({ Title: &quot;Archer&quot;, NumberOfEpisodes: 75 });
base.store(&quot;TVSeries&quot;).push({ Title: &quot;The Simpsons&quot;, NumberOfEpisodes: 574 });
base.store(&quot;TVSeries&quot;).push({ Title: &quot;New Girl&quot;, NumberOfEpisodes: 94 });
base.store(&quot;TVSeries&quot;).push({ Title: &quot;Rick and Morty&quot;, NumberOfEpisodes: 11 });
base.store(&quot;TVSeries&quot;).push({ Title: &quot;Game of Thrones&quot;, NumberOfEpisodes: 47 });
// create a record set of the records of store
var recordSet &#x3D; base.store(&quot;TVSeries&quot;).allRecords;
// create a vector containing the number of episodes for each series
// the vector will look like [75, 574, 94, 11, 47]
var vector &#x3D; recordSet.getVector(&quot;NumberOfEpisodes&quot;);
base.close();</code></pre>
                </div>
              </section>
              <section>
                <h4>Parameter</h4>
                <table class="jsdoc-details-table">
                  <thead>
                    <tr>
                      <th>Name</th>
                      <th>Type</th>
                      <th>Optional</th>
                      <th>Description</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <p>fieldName</p>
                      </td>
                      <td>
                        <p>string</p>
                      </td>
                      <td>
                        <p>&nbsp;</p>
                      </td>
                      <td>
                        <p>The field from which to take the values. It's type must be one-dimensional, e.g. <code>int</code>, <code>float</code>, <code>string</code>...</p>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </section>
              <dl class="dl-compact">
                <dt>Returns</dt>
                <dd>
                  <p><code><a href="module-la.Vector.html">module:la.Vector</a></code>B The vector containing the field values of records. The type it contains is dependant of the field type.</p>
                </dd>
              </dl>
              <h3 id="join"><span class="symbol-name">join</span><span class="signature"><span class="signature-params">(joinName[, sampleSize])</span>&nbsp;&rarr; <span class="signature-returns"> <a href="module-qm.RecordSet.html">module:qm.RecordSet</a></span></span></h3>
              <p>Creates a new record set out of the join attribute of records.</p>
              <section>
                <h4>
                  Example
                </h4>
                <div>
                  <pre class="prettyprint"><code>// import qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a new base containing two stores, with join attributes
var base &#x3D; new qm.Base({
   mode: &quot;createClean&quot;,
   schema: [
   {
       name: &quot;Musicians&quot;,
       fields: [
           { name: &quot;Name&quot;, type: &quot;string&quot; },
           { name: &quot;Instruments&quot;, type: &quot;string_v&quot; }
       ],
       joins: [
           { name: &quot;PlaysIn&quot;, type: &quot;index&quot;, store: &quot;Bands&quot;, inverse: &quot;Members&quot; }
       ]
   },
   {
       name: &quot;Bands&quot;,
       fields: [
           { name: &quot;Name&quot;, type: &quot;string&quot; },
           { name: &quot;Genre&quot;, type: &quot;string&quot; }
       ],
       joins: [
           { name: &quot;Members&quot;, type: &quot;index&quot;, store: &quot;Musicians&quot;, inverse: &quot;PlaysIn&quot; }
       ]
   }]
});
// add some new records to both stores
base.store(&quot;Musicians&quot;).push({ Name: &quot;Robert Plant&quot;, Instruments: [&quot;Vocals&quot;], PlaysIn: [{Name: &quot;Led Zeppelin&quot;, &quot;Genre&quot;: &quot;Rock&quot; }] });
base.store(&quot;Musicians&quot;).push({ Name: &quot;Jimmy Page&quot;, Instruments: [&quot;Guitar&quot;], PlaysIn: [{Name: &quot;Led Zeppelin&quot;, &quot;Genre&quot;: &quot;Rock&quot; }] });
base.store(&quot;Bands&quot;).push({ Name: &quot;The White Stripes&quot;, Genre: &quot;Rock&quot; });
// create a record set containing the musicians, that are members of some bend
// returns a record set containing the records of &quot;Robert Plant&quot; and &quot;Jimmy Page&quot;
var ledZeppelin &#x3D; base.store(&quot;Bands&quot;).allRecords.join(&quot;Members&quot;);
// create a record set containing the first musician, that is a member of some band
// returns a record set containing only one record, which is &quot;Robert Plant&quot; or &quot;Jimmy Page&quot;
var ledMember &#x3D; base.store(&quot;Bands&quot;).allRecords.join(&quot;Members&quot;, 1);
base.close();</code></pre>
                </div>
              </section>
              <section>
                <h4>Parameters</h4>
                <table class="jsdoc-details-table">
                  <thead>
                    <tr>
                      <th>Name</th>
                      <th>Type</th>
                      <th>Optional</th>
                      <th>Description</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <p>joinName</p>
                      </td>
                      <td>
                        <p>string</p>
                      </td>
                      <td>
                        <p>&nbsp;</p>
                      </td>
                      <td>
                        <p>The name of the join attribute.</p>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <p>sampleSize</p>
                      </td>
                      <td>
                        <p>number</p>
                      </td>
                      <td>
                        <p>Yes</p>
                      </td>
                      <td>
                        <p>The number of records to be used for construction of the record set.</p>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </section>
              <dl class="dl-compact">
                <dt>Returns</dt>
                <dd>
                  <p><code><a href="module-qm.RecordSet.html">module:qm.RecordSet</a></code>B The record set containing the join records.</p>
                </dd>
              </dl>
              <h3 id="map"><span class="symbol-name">map</span><span class="signature"><span class="signature-params">(callback)</span>&nbsp;&rarr; <span class="signature-returns"> Array of Object</span></span></h3>
              <p>Creates an array of function outputs created from the records in record set.</p>
              <section>
                <h4>
                  Example
                </h4>
                <div>
                  <pre class="prettyprint"><code>// import qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a new base containing one store
var base &#x3D; new qm.Base({
   mode: &quot;createClean&quot;,
   schema: [{
       name: &quot;People&quot;,
       fields: [
           { name: &quot;Name&quot;, type: &quot;string&quot; },
           { name: &quot;Gender&quot;, type: &quot;string&quot; }
       ]
   }]
});
// put some records in the store
base.store(&quot;People&quot;).push({ Name: &quot;Eric Sugar&quot;, Gender: &quot;Male&quot; });
base.store(&quot;People&quot;).push({ Name: &quot;Jane Tokyo&quot;, Gender: &quot;Female&quot; });
base.store(&quot;People&quot;).push({ Name: &quot;Mister Tea&quot;, Gender: &quot;Male&quot; });
// create a record set out of the records of the store
var recordSet &#x3D; base.store(&quot;People&quot;).allRecords;
// make an array of record Names
var arr &#x3D; recordSet.map(function (rec) { return rec.Name; }); // returns an array: [&quot;Eric Sugar&quot;, &quot;Jane Tokyo&quot;, &quot;Mister Tea&quot;]
base.close();</code></pre>
                </div>
              </section>
              <section>
                <h4>Parameter</h4>
                <table class="jsdoc-details-table">
                  <thead>
                    <tr>
                      <th>Name</th>
                      <th>Type</th>
                      <th>Optional</th>
                      <th>Description</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <p>callback</p>
                      </td>
                      <td>
                        <p>function()</p>
                      </td>
                      <td>
                        <p>&nbsp;</p>
                      </td>
                      <td>
                        <p>Function that generates the array. It takes two parameters:
                          <br>1. <code>rec</code> - The current record. Type <a href="module-qm.Record.html">module:qm.Record</a>. Warning: Do not use <code>rec</code> outside the scope of the callback. An internal optimization re-uses <code>rec</code> object between calls to <code>callback</code>.
                          <br>2. <code>idx</code> - The index of the current record (<i>optional</i>). Type <code>number</code>.
                        </p>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </section>
              <dl class="dl-compact">
                <dt>Returns</dt>
                <dd>
                  <p><code>Array of Object</code>B The array created by the callback function.</p>
                </dd>
              </dl>
              <h3 id="reverse"><span class="symbol-name">reverse</span><span class="signature"><span class="signature-params">()</span>&nbsp;&rarr; <span class="signature-returns"> <a href="module-qm.RecordSet.html">module:qm.RecordSet</a></span></span></h3>
              <p>It reverses the record order.</p>
              <section>
                <h4>
                  Example
                </h4>
                <div>
                  <pre class="prettyprint"><code>// import qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a new base containing one store
var base &#x3D; new qm.Base({
   mode: &quot;createClean&quot;,
   schema: [{
       name: &quot;WeatherForcast&quot;,
       fields: [
           { name: &quot;Weather&quot;, type: &quot;string&quot; },
           { name: &quot;Date&quot;, type: &quot;datetime&quot; },
           { name: &quot;TemperatureDegrees&quot;, type: &quot;int&quot; },
       ]
   }]
});
// put some records in the &quot;WeatherForecast&quot; store
base.store(&quot;WeatherForcast&quot;).push({ Weather: &quot;Partly Cloudy&quot;, Date: &quot;2015-05-27T11:00:00&quot;, TemperatureDegrees: 19 });
base.store(&quot;WeatherForcast&quot;).push({ Weather: &quot;Partly Cloudy&quot;, Date: &quot;2015-05-28T11:00:00&quot;, TemperatureDegrees: 22 });
base.store(&quot;WeatherForcast&quot;).push({ Weather: &quot;Mostly Cloudy&quot;, Date: &quot;2015-05-29T11:00:00&quot;, TemperatureDegrees: 25 });
base.store(&quot;WeatherForcast&quot;).push({ Weather: &quot;Mostly Cloudy&quot;, Date: &quot;2015-05-30T11:00:00&quot;, TemperatureDegrees: 25 });
base.store(&quot;WeatherForcast&quot;).push({ Weather: &quot;Scattered Showers&quot;, Date: &quot;2015-05-31T11:00:00&quot;, TemperatureDegrees: 24 });
base.store(&quot;WeatherForcast&quot;).push({ Weather: &quot;Mostly Cloudy&quot;, Date: &quot;2015-06-01T11:00:00&quot;, TemperatureDegrees: 27 });
// get the record set containing the records from the &quot;WeatherForcast&quot; store
var recordSet &#x3D; base.store(&quot;WeatherForcast&quot;).allRecords;
// reverse the record order in the record set
recordSet.reverse(); // returns self, the records in the record set are in the reverse order
base.close();</code></pre>
                </div>
              </section>
              <dl class="dl-compact">
                <dt>Returns</dt>
                <dd>
                  <p><code><a href="module-qm.RecordSet.html">module:qm.RecordSet</a></code>B Self. Records are in reversed order.</p>
                </dd>
              </dl>
              <h3 id="sample"><span class="symbol-name">sample</span><span class="signature"><span class="signature-params">(num)</span>&nbsp;&rarr; <span class="signature-returns"> <a href="module-qm.RecordSet.html">module:qm.RecordSet</a></span></span></h3>
              <p>Creates a random sample of records of the record set.</p>
              <section>
                <h4>
                  Example
                </h4>
                <div>
                  <pre class="prettyprint"><code>// import qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a new base with one store
var base &#x3D; new qm.Base({
   mode: &quot;createClean&quot;,
   schema: [{
       name: &quot;Movies&quot;,
       fields: [
           { name: &quot;Title&quot;, type: &quot;string&quot; },
           { name: &quot;Length&quot;, type: &quot;int&quot; },
           { name: &quot;Director&quot;, type: &quot;string&quot; }
       ]
   }]
});
// put some records in the store
base.store(&quot;Movies&quot;).push({ Title: &quot;The Nightmare Before Christmas&quot;, Length: 76, Director: &quot;Henry Selick&quot; });
base.store(&quot;Movies&quot;).push({ Title: &quot;Jurassic Part&quot;, Length: 127, Director: &quot;Steven Spielberg&quot; });
base.store(&quot;Movies&quot;).push({ Title: &quot;The Avengers&quot;, Length: 143, Director: &quot;Joss Whedon&quot; });
base.store(&quot;Movies&quot;).push({ Title: &quot;The Clockwork Orange&quot;, Length: 136, Director: &quot;Stanley Kubrick&quot; });
base.store(&quot;Movies&quot;).push({ Title: &quot;Full Metal Jacket&quot;, Length: 116, Director: &quot;Stanely Kubrick&quot; });
// create a sample record set of containing 3 records from the &quot;Movies&quot; store
var sample &#x3D; base.store(&quot;Movies&quot;).allRecords.sample(3);
base.close();</code></pre>
                </div>
              </section>
              <section>
                <h4>Parameter</h4>
                <table class="jsdoc-details-table">
                  <thead>
                    <tr>
                      <th>Name</th>
                      <th>Type</th>
                      <th>Optional</th>
                      <th>Description</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <p>num</p>
                      </td>
                      <td>
                        <p>number</p>
                      </td>
                      <td>
                        <p>&nbsp;</p>
                      </td>
                      <td>
                        <p>The number of records in the sample.</p>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </section>
              <dl class="dl-compact">
                <dt>Returns</dt>
                <dd>
                  <p><code><a href="module-qm.RecordSet.html">module:qm.RecordSet</a></code>B A record set containing the sample records.</p>
                </dd>
              </dl>
              <h3 id="setDiff"><span class="symbol-name">setDiff</span><span class="signature"><span class="signature-params">(rs)</span>&nbsp;&rarr; <span class="signature-returns"> <a href="module-qm.RecordSet.html">module:qm.RecordSet</a></span></span></h3>
              <p>Creates the set difference between two record sets.</p>
              <section>
                <h4>
                  Example
                </h4>
                <div>
                  <pre class="prettyprint"><code>// import qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a new base containing one store
var base &#x3D; new qm.Base({
   mode: &quot;createClean&quot;,
   schema: [{
       name: &quot;BookWriters&quot;,
       fields: [
           { name: &quot;Name&quot;, type: &quot;string&quot; },
           { name: &quot;Genre&quot;, type: &quot;string&quot; },
           { name: &quot;Books&quot;, type: &quot;string_v&quot; }
       ]
   }]
});
// set new records in the store
base.store(&quot;BookWriters&quot;).push({ Name: &quot;Terry Pratchett&quot;, Genre: &quot;Fantasy&quot;, Books: [&quot;The Colour of Magic&quot;, &quot;Going Postal&quot;, &quot;Mort&quot;, &quot;Guards! Guards!&quot;] });
base.store(&quot;BookWriters&quot;).push({ Name: &quot;Douglas Adams&quot;, Genre: &quot;Sci-fi&quot;, Books: [&quot;The Hitchhiker&#x27;s Guide to the Galaxy&quot;, &quot;So Long, and Thanks for All the Fish&quot;] });
base.store(&quot;BookWriters&quot;).push({ Name: &quot;Fyodor Dostoyevsky&quot;, Genre: &quot;Drama&quot;, Books: [&quot;Crime and Punishment&quot;, &quot;Demons&quot;] });
base.store(&quot;BookWriters&quot;).push({ Name: &quot;J.R.R. Tolkien&quot;, Genre: &quot;Fantasy&quot;, Books: [&quot;The Hobbit&quot;, &quot;The Two Towers&quot;, &quot;The Silmarillion&quot; ] });
base.store(&quot;BookWriters&quot;).push({ Name: &quot;George R.R. Martin&quot;, Genre: &quot;Fantasy&quot;, Books: [&quot;A Game of Thrones&quot;, &quot;A Feast of Crows&quot;] });
base.store(&quot;BookWriters&quot;).push({ Name: &quot;J. K. Rowling&quot;, Genre: &quot;Fantasy&quot;, Books: [&quot;Harry Potter and the Philosopher&#x27;s Stone&quot;] });
base.store(&quot;BookWriters&quot;).push({ Name: &quot;Ivan Cankar&quot;, Genre: &quot;Drama&quot;, Books: [&quot;On the Hill&quot;, &quot;The King of Betajnova&quot;, &quot;The Serfs&quot;] });
// create one record set containing all records of store
var recordSet &#x3D; base.store(&quot;BookWriters&quot;).allRecords;
// create one record set containing the records with genre &quot;Fantasy&quot;
var fantasy &#x3D; base.store(&quot;BookWriters&quot;).allRecords.filterByField(&quot;Genre&quot;, &quot;Fantasy&quot;);
// create a new record set containing the difference of recordSet and fantasy
var difference &#x3D; recordSet.setDiff(fantasy); // returns a record set, containing the records of Douglas Adams, Fyodor Dostoyevsky and Ivan Cankar
base.close();</code></pre>
                </div>
              </section>
              <section>
                <h4>Parameter</h4>
                <table class="jsdoc-details-table">
                  <thead>
                    <tr>
                      <th>Name</th>
                      <th>Type</th>
                      <th>Optional</th>
                      <th>Description</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <p>rs</p>
                      </td>
                      <td>
                        <p><a href="module-qm.RecordSet.html">module:qm.RecordSet</a></p>
                      </td>
                      <td>
                        <p>&nbsp;</p>
                      </td>
                      <td>
                        <p>The other record set.</p>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </section>
              <dl class="dl-compact">
                <dt>Returns</dt>
                <dd>
                  <p><code><a href="module-qm.RecordSet.html">module:qm.RecordSet</a></code>B The difference between the two record sets.</p>
                </dd>
              </dl>
              <h3 id="setIntersect"><span class="symbol-name">setIntersect</span><span class="signature"><span class="signature-params">(rs)</span>&nbsp;&rarr; <span class="signature-returns"> <a href="module-qm.RecordSet.html">module:qm.RecordSet</a></span></span></h3>
              <p>Creates the set intersection of two record sets.</p>
              <section>
                <h4>
                  Example
                </h4>
                <div>
                  <pre class="prettyprint"><code>// import qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a new base with one store
var base &#x3D; new qm.Base({
   mode: &quot;createClean&quot;,
   schema: [{
       name: &quot;Movies&quot;,
       fields: [
           { name: &quot;Title&quot;, type: &quot;string&quot; },
           { name: &quot;Length&quot;, type: &quot;int&quot; },
           { name: &quot;Director&quot;, type: &quot;string&quot; }
       ]
   }]
});
// put some records in the store
base.store(&quot;Movies&quot;).push({ Title: &quot;The Nightmare Before Christmas&quot;, Length: 76, Director: &quot;Henry Selick&quot; });
base.store(&quot;Movies&quot;).push({ Title: &quot;Jurassic Part&quot;, Length: 127, Director: &quot;Steven Spielberg&quot; });
base.store(&quot;Movies&quot;).push({ Title: &quot;The Avengers&quot;, Length: 143, Director: &quot;Joss Whedon&quot; });
base.store(&quot;Movies&quot;).push({ Title: &quot;The Clockwork Orange&quot;, Length: 136, Director: &quot;Stanley Kubrick&quot; });
base.store(&quot;Movies&quot;).push({ Title: &quot;Full Metal Jacket&quot;, Length: 116, Director: &quot;Stanely Kubrick&quot; });
// create a record set out of the records in store, where length of the movie is greater than 110
var greaterSet &#x3D; base.store(&quot;Movies&quot;).allRecords.filterByField(&quot;Length&quot;, 110, 150);
// create a record set out of the records in store, where the length of the movie is lesser than 130
var lesserSet &#x3D; base.store(&quot;Movies&quot;).allRecords.filterByField(&quot;Length&quot;, 0, 130);
// get the intersection of greaterSet and lesserSet
var intersection &#x3D; greaterSet.setIntersect(lesserSet); // returns a record set, containing the movies with lengths between 110 and 130
base.close();</code></pre>
                </div>
              </section>
              <section>
                <h4>Parameter</h4>
                <table class="jsdoc-details-table">
                  <thead>
                    <tr>
                      <th>Name</th>
                      <th>Type</th>
                      <th>Optional</th>
                      <th>Description</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <p>rs</p>
                      </td>
                      <td>
                        <p><a href="module-qm.RecordSet.html">module:qm.RecordSet</a></p>
                      </td>
                      <td>
                        <p>&nbsp;</p>
                      </td>
                      <td>
                        <p>The other record set.</p>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </section>
              <dl class="dl-compact">
                <dt>Returns</dt>
                <dd>
                  <p><code><a href="module-qm.RecordSet.html">module:qm.RecordSet</a></code>B The intersection of the two record sets.</p>
                </dd>
              </dl>
              <h3 id="setUnion"><span class="symbol-name">setUnion</span><span class="signature"><span class="signature-params">(rs)</span>&nbsp;&rarr; <span class="signature-returns"> <a href="module-qm.RecordSet.html">module:qm.RecordSet</a></span></span></h3>
              <p>Creates the set union of two record sets.</p>
              <section>
                <h4>
                  Example
                </h4>
                <div>
                  <pre class="prettyprint"><code>// import qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a base containing one store
var base &#x3D; new qm.Base({
   mode: &quot;createClean&quot;,
   schema: [{
       name: &quot;TVSeries&quot;,
       fields: [
           { name: &quot;Title&quot;, type: &quot;string&quot;, &quot;primary&quot;: true },
           { name: &quot;NumberOfEpisodes&quot;, type: &quot;int&quot; }
       ]
   }]
});
// add some records in the store
base.store(&quot;TVSeries&quot;).push({ Title: &quot;Archer&quot;, NumberOfEpisodes: 75 });
base.store(&quot;TVSeries&quot;).push({ Title: &quot;The Simpsons&quot;, NumberOfEpisodes: 574 });
base.store(&quot;TVSeries&quot;).push({ Title: &quot;New Girl&quot;, NumberOfEpisodes: 94 });
base.store(&quot;TVSeries&quot;).push({ Title: &quot;Rick and Morty&quot;, NumberOfEpisodes: 11 });
base.store(&quot;TVSeries&quot;).push({ Title: &quot;Game of Thrones&quot;, NumberOfEpisodes: 47 });
// create a record set out of the records in store, where the number of episodes is lesser than 47
var lesserSet &#x3D; base.store(&quot;TVSeries&quot;).allRecords.filterByField(&quot;NumberOfEpisodes&quot;, 0, 47);
// create a record set out of the records in store, where the number of episodes is greater than 100
var greaterSet &#x3D; base.store(&quot;TVSeries&quot;).allRecords.filterByField(&quot;NumberOfEpisodes&quot;, 100, 600);
// get the union of lesserSet and greaterSet
var union &#x3D; lesserSet.setUnion(greaterSet); // returns a record set, which is the union of the two record sets
base.close();</code></pre>
                </div>
              </section>
              <section>
                <h4>Parameter</h4>
                <table class="jsdoc-details-table">
                  <thead>
                    <tr>
                      <th>Name</th>
                      <th>Type</th>
                      <th>Optional</th>
                      <th>Description</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <p>rs</p>
                      </td>
                      <td>
                        <p><a href="module-qm.RecordSet.html">module:qm.RecordSet</a></p>
                      </td>
                      <td>
                        <p>&nbsp;</p>
                      </td>
                      <td>
                        <p>The second record set.</p>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </section>
              <dl class="dl-compact">
                <dt>Returns</dt>
                <dd>
                  <p><code><a href="module-qm.RecordSet.html">module:qm.RecordSet</a></code>B The union of the two record sets.</p>
                </dd>
              </dl>
              <h3 id="shuffle"><span class="symbol-name">shuffle</span><span class="signature"><span class="signature-params">([seed])</span>&nbsp;&rarr; <span class="signature-returns"> <a href="module-qm.RecordSet.html">module:qm.RecordSet</a></span></span></h3>
              <p>Shuffles the order of records in the record set.</p>
              <section>
                <h4>
                  Example
                </h4>
                <div>
                  <pre class="prettyprint"><code>// import qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a new base containing one store
var base &#x3D; new qm.Base({
   mode: &quot;createClean&quot;,
   schema: [{
       name: &quot;WeatherForcast&quot;,
       fields: [
           { name: &quot;Weather&quot;, type: &quot;string&quot; },
           { name: &quot;Date&quot;, type: &quot;datetime&quot; },
           { name: &quot;TemperatureDegrees&quot;, type: &quot;int&quot; }
       ]
   }]
});
// put some records in the &quot;WeatherForecast&quot; store
base.store(&quot;WeatherForcast&quot;).push({ Weather: &quot;Partly Cloudy&quot;, Date: &quot;2015-05-27T11:00:00&quot;, TemperatureDegrees: 19 });
base.store(&quot;WeatherForcast&quot;).push({ Weather: &quot;Partly Cloudy&quot;, Date: &quot;2015-05-28T11:00:00&quot;, TemperatureDegrees: 22 });
base.store(&quot;WeatherForcast&quot;).push({ Weather: &quot;Mostly Cloudy&quot;, Date: &quot;2015-05-29T11:00:00&quot;, TemperatureDegrees: 25 });
base.store(&quot;WeatherForcast&quot;).push({ Weather: &quot;Mostly Cloudy&quot;, Date: &quot;2015-05-30T11:00:00&quot;, TemperatureDegrees: 25 });
base.store(&quot;WeatherForcast&quot;).push({ Weather: &quot;Scattered Showers&quot;, Date: &quot;2015-05-31T11:00:00&quot;, TemperatureDegrees: 24 });
base.store(&quot;WeatherForcast&quot;).push({ Weather: &quot;Mostly Cloudy&quot;, Date: &quot;2015-06-01T11:00:00&quot;, TemperatureDegrees: 27 });
// get the record set containing the records from the &quot;WeatherForcast&quot; store
var recordSet &#x3D; base.store(&quot;WeatherForcast&quot;).allRecords;
// shuffle the records in the newly created record set. Use the number 100 as the seed for the shuffle
recordSet.shuffle(100); // returns self, the records in the record set are shuffled
base.close();</code></pre>
                </div>
              </section>
              <section>
                <h4>Parameter</h4>
                <table class="jsdoc-details-table">
                  <thead>
                    <tr>
                      <th>Name</th>
                      <th>Type</th>
                      <th>Optional</th>
                      <th>Description</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <p>seed</p>
                      </td>
                      <td>
                        <p>number</p>
                      </td>
                      <td>
                        <p>Yes</p>
                      </td>
                      <td>
                        <p>Integer.</p>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </section>
              <dl class="dl-compact">
                <dt>Returns</dt>
                <dd>
                  <p><code><a href="module-qm.RecordSet.html">module:qm.RecordSet</a></code>B Self. The records in the record set are in a different order.</p>
                </dd>
              </dl>
              <h3 id="sort"><span class="symbol-name">sort</span><span class="signature"><span class="signature-params">(callback)</span>&nbsp;&rarr; <span class="signature-returns"> <a href="module-qm.RecordSet.html">module:qm.RecordSet</a></span></span></h3>
              <p>Sorts the records according to the given callback function.</p>
              <section>
                <h4>
                  Example
                </h4>
                <div>
                  <pre class="prettyprint"><code>// import qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a new base containing one store
var base &#x3D; new qm.Base({
   mode: &quot;createClean&quot;,
   schema: [{
       name: &quot;TVSeries&quot;,
       fields: [
           { name: &quot;Title&quot;, type: &quot;string&quot;, primary: true },
           { name: &quot;NumberOfEpisodes&quot;, type: &quot;int&quot; }
       ]
   }]
});
// add some records in the store
base.store(&quot;TVSeries&quot;).push({ Title: &quot;Archer&quot;, NumberOfEpisodes: 75 });
base.store(&quot;TVSeries&quot;).push({ Title: &quot;The Simpsons&quot;, NumberOfEpisodes: 574 });
base.store(&quot;TVSeries&quot;).push({ Title: &quot;New Girl&quot;, NumberOfEpisodes: 94 });
base.store(&quot;TVSeries&quot;).push({ Title: &quot;Rick and Morty&quot;, NumberOfEpisodes: 11 });
base.store(&quot;TVSeries&quot;).push({ Title: &quot;Game of Thrones&quot;, NumberOfEpisodes: 47 });
// get the records of the &quot;TVSeries&quot; store as a record set
var recordSet &#x3D; base.store(&quot;TVSeries&quot;).allRecords;
// sort the records by their number of episodes
recordSet.sort(function (rec, rec2) { return rec.NumberOfEpisodes &lt; rec2.NumberOfEpisodes; }); // returns self, records are sorted by the number of episodes
base.close();</code></pre>
                </div>
              </section>
              <section>
                <h4>Parameter</h4>
                <table class="jsdoc-details-table">
                  <thead>
                    <tr>
                      <th>Name</th>
                      <th>Type</th>
                      <th>Optional</th>
                      <th>Description</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <p>callback</p>
                      </td>
                      <td>
                        <p>function()</p>
                      </td>
                      <td>
                        <p>&nbsp;</p>
                      </td>
                      <td>
                        <p>The function used to sort the records. It takes two parameters:
                          <br>1. <code>rec</code> - The first record.
                          <br>2. <code>rec2</code> - The second record.
                          <br>The function return type <code>boolean</code>.
                        </p>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </section>
              <dl class="dl-compact">
                <dt>Returns</dt>
                <dd>
                  <p><code><a href="module-qm.RecordSet.html">module:qm.RecordSet</a></code>B Self. The records are sorted according to the <code>callback</code> function.</p>
                </dd>
              </dl>
              <h3 id="sortByField"><span class="symbol-name">sortByField</span><span class="signature"><span class="signature-params">(fieldName[, asc])</span>&nbsp;&rarr; <span class="signature-returns"> <a href="module-qm.RecordSet.html">module:qm.RecordSet</a></span></span></h3>
              <p>Sorts the records according to a specific record field.</p>
              <section>
                <h4>
                  Example
                </h4>
                <div>
                  <pre class="prettyprint"><code>// import qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a new base containing one store
var base &#x3D; new qm.Base({
   mode: &quot;createClean&quot;,
   schema: [{
       name: &quot;TVSeries&quot;,
       fields: [
           { name: &quot;Title&quot;, type: &quot;string&quot;, primary: true },
           { name: &quot;NumberOfEpisodes&quot;, type: &quot;int&quot; }
       ]
   }]
});
// add some records in the store
base.store(&quot;TVSeries&quot;).push({ Title: &quot;Archer&quot;, NumberOfEpisodes: 75 });
base.store(&quot;TVSeries&quot;).push({ Title: &quot;The Simpsons&quot;, NumberOfEpisodes: 574 });
base.store(&quot;TVSeries&quot;).push({ Title: &quot;New Girl&quot;, NumberOfEpisodes: 94 });
base.store(&quot;TVSeries&quot;).push({ Title: &quot;Rick and Morty&quot;, NumberOfEpisodes: 11 });
base.store(&quot;TVSeries&quot;).push({ Title: &quot;Game of Thrones&quot;, NumberOfEpisodes: 47 });
// get the records of the &quot;TVSeries&quot; store as a record set
var recordSet &#x3D; base.store(&quot;TVSeries&quot;).allRecords;
// sort the records by their &quot;Title&quot; field in ascending order
recordSet.sortByField(&quot;Title&quot;, true); // returns self, record are sorted by their &quot;Title&quot;
base.close();</code></pre>
                </div>
              </section>
              <section>
                <h4>Parameters</h4>
                <table class="jsdoc-details-table">
                  <thead>
                    <tr>
                      <th>Name</th>
                      <th>Type</th>
                      <th>Optional</th>
                      <th>Description</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <p>fieldName</p>
                      </td>
                      <td>
                        <p>string</p>
                      </td>
                      <td>
                        <p>&nbsp;</p>
                      </td>
                      <td>
                        <p>The field by which the sort will work.</p>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <p>asc</p>
                      </td>
                      <td>
                        <p>number</p>
                      </td>
                      <td>
                        <p>Yes</p>
                      </td>
                      <td>
                        <p>if <code>asc</code> &gt; 0, it sorts in ascending order. Otherwise, it sorts in descending order.</p>
                        <p>Defaults to <code>-1</code>.</p>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </section>
              <dl class="dl-compact">
                <dt>Returns</dt>
                <dd>
                  <p><code><a href="module-qm.RecordSet.html">module:qm.RecordSet</a></code>B Self. Records are sorted according to <code>fieldName</code> and <code>asc</code>.</p>
                </dd>
              </dl>
              <h3 id="sortByFq"><span class="symbol-name">sortByFq</span><span class="signature"><span class="signature-params">([asc])</span>&nbsp;&rarr; <span class="signature-returns"> <a href="module-qm.RecordSet.html">module:qm.RecordSet</a></span></span></h3>
              <p>Sorts the records according to their weight.</p>
              <section>
                <h4>Parameter</h4>
                <table class="jsdoc-details-table">
                  <thead>
                    <tr>
                      <th>Name</th>
                      <th>Type</th>
                      <th>Optional</th>
                      <th>Description</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <p>asc</p>
                      </td>
                      <td>
                        <p>number</p>
                      </td>
                      <td>
                        <p>Yes</p>
                      </td>
                      <td>
                        <p>If <code>asc</code> &gt; 0, it sorts in ascending order. Otherwise, it sorts in descending order.</p>
                        <p>Defaults to <code>1</code>.</p>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </section>
              <dl class="dl-compact">
                <dt>Returns</dt>
                <dd>
                  <p><code><a href="module-qm.RecordSet.html">module:qm.RecordSet</a></code>B Self. Records are sorted according to record weight and <code>asc</code>.</p>
                </dd>
              </dl>
              <h3 id="sortById"><span class="symbol-name">sortById</span><span class="signature"><span class="signature-params">([asc])</span>&nbsp;&rarr; <span class="signature-returns"> <a href="module-qm.RecordSet.html">module:qm.RecordSet</a></span></span></h3>
              <p>Sorts the records according to record ID.</p>
              <section>
                <h4>
                  Example
                </h4>
                <div>
                  <pre class="prettyprint"><code>// import qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a new base containing one store
var base &#x3D; new qm.Base({
   mode: &quot;createClean&quot;,
   schema: [{
       name: &quot;Tea&quot;,
       fields: [
           { name: &quot;Name&quot;, type: &quot;string&quot; },
           { name: &quot;Type&quot;, type: &quot;string&quot;},
           { name: &quot;Origin&quot;, type: &quot;string&quot;, &quot;null&quot;: true  }
       ]
   }]
});
// put some records in the &quot;Tea&quot; store
base.store(&quot;Tea&quot;).push({ Name: &quot;Tanyang Gongfu&quot;, Type: &quot;Black&quot;, Origin: &quot;Tanyang&quot; });
base.store(&quot;Tea&quot;).push({ Name: &quot;Rou Gui&quot;, Type: &quot;White&quot; });
base.store(&quot;Tea&quot;).push({ Name: &quot;Tieluohan Tea&quot;, Type: &quot;Wuyi&quot;, Origin: &quot;Northern Fujian&quot; });
base.store(&quot;Tea&quot;).push({ Name: &quot;Red Robe&quot;, Type: &quot;Oolong&quot;, Origin: &quot;Wuyi Mountains&quot; });
// get the records of the &quot;Tea&quot; store as a record set
var recordSet &#x3D; base.store(&quot;Tea&quot;).allRecords;
// sort the records in the record set by their id in descending order
recordSet.sortById(); // returns self, the records are sorted in descending order (default)
// sort the records in the record set by their id in ascending order
recordSet.sortById(1); // returns self, the records are sorted in ascending order
base.close();</code></pre>
                </div>
              </section>
              <section>
                <h4>Parameter</h4>
                <table class="jsdoc-details-table">
                  <thead>
                    <tr>
                      <th>Name</th>
                      <th>Type</th>
                      <th>Optional</th>
                      <th>Description</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <p>asc</p>
                      </td>
                      <td>
                        <p>number</p>
                      </td>
                      <td>
                        <p>Yes</p>
                      </td>
                      <td>
                        <p>If <code>asc</code> &gt; 0, it sorts in ascending order. Otherwise, it sorts in descending order.</p>
                        <p>Defaults to <code>-1</code>.</p>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </section>
              <dl class="dl-compact">
                <dt>Returns</dt>
                <dd>
                  <p><code><a href="module-qm.RecordSet.html">module:qm.RecordSet</a></code>B Self. Records are sorted according to record ID and <code>asc</code>.</p>
                </dd>
              </dl>
              <h3 id="split"><span class="symbol-name">split</span><span class="signature"><span class="signature-params">(callback)</span>&nbsp;&rarr; <span class="signature-returns"> Array of <a href="module-qm.RecordSet.html">module:qm.RecordSet</a></span></span></h3>
              <p>Splits the record set into smaller record sets.</p>
              <section>
                <h4>
                  Example
                </h4>
                <div>
                  <pre class="prettyprint"><code>// import qm module
var qm &#x3D; require(&quot;qminer&quot;);
// create a new base containing one store
var base &#x3D; new qm.Base({
   mode: &quot;createClean&quot;,
   schema: [{
       name: &quot;SocialGames&quot;,
       fields: [
           { name: &quot;Title&quot;, type: &quot;string&quot; },
           { name: &quot;Type&quot;, type: &quot;string&quot; },
           { name: &quot;MinPlayers&quot;, type: &quot;int&quot; },
           { name: &quot;MaxPlayers&quot;, type: &quot;int&quot; }
       ]
   }]
});
// set new records in the store
base.store(&quot;SocialGames&quot;).push({ Title: &quot;DungeonsAndDragons&quot;, Type: &quot;Role-Playing&quot;, MinPlayers: 5, MaxPlayers: 5 });
base.store(&quot;SocialGames&quot;).push({ Title: &quot;Dobble&quot;, Type: &quot;Card&quot;, MinPlayers: 2, MaxPlayers: 8 });
base.store(&quot;SocialGames&quot;).push({ Title: &quot;Settlers of Catan&quot;, Type: &quot;Board&quot;, MinPlayers: 3, MaxPlayers: 4 });
base.store(&quot;SocialGames&quot;).push({ Title: &quot;Munchkin&quot;, Type: &quot;Card&quot;, MinPlayers: 3, MaxPlayers: 6 });
// create a record set out of the records of the store
var recordSet &#x3D; base.store(&quot;SocialGames&quot;).allRecords;
// sort the records by MinPlayers in ascending order
recordSet.sortByField(&quot;MinPlayers&quot;, true);
// split the record set by the minimum number of players
// returns an array containing three record sets: the first containing the &quot;DungeonsAndDragons&quot; record,
// the second containing the &quot;Settlers of Catan&quot; and &quot;Munchkin&quot; records and the third containing the
// &quot;Dobble&quot; record
var arr &#x3D; recordSet.split(function (rec, rec2) { return rec.MinPlayers &lt; rec2.MinPlayers; });
base.close();</code></pre>
                </div>
              </section>
              <section>
                <h4>Parameter</h4>
                <table class="jsdoc-details-table">
                  <thead>
                    <tr>
                      <th>Name</th>
                      <th>Type</th>
                      <th>Optional</th>
                      <th>Description</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <p>callback</p>
                      </td>
                      <td>
                        <p>function()</p>
                      </td>
                      <td>
                        <p>&nbsp;</p>
                      </td>
                      <td>
                        <p>The splitter function. It takes two parameters:
                          <br>1. <code>rec</code> - The first record. Type <a href="module-qm.Record.html">module:qm.Record</a>.
                          <br>2. <code>rec2</code> - The second record. Type <a href="module-qm.Record.html">module:qm.Record</a>.
                          <br> Returns a <code>boolean</code> value.
                        </p>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </section>
              <dl class="dl-compact">
                <dt>Returns</dt>
                <dd>
                  <p><code>Array of <a href="module-qm.RecordSet.html">module:qm.RecordSet</a></code>B An array containing the smaller record sets. The records are split according the callback function.</p>
                </dd>
              </dl>
              <h3 id="toJSON"><span class="symbol-name">toJSON</span><span class="signature"><span class="signature-params">()</span>&nbsp;&rarr; <span class="signature-returns"> Object</span></span></h3>
              <p>Returns the record set as a JSON.</p>
              <section>
                <h4>
                  Example
                </h4>
                <div>
                  <pre class="prettyprint"><code>// import qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a new base containing one store
var base &#x3D; new qm.Base({
   mode: &quot;createClean&quot;,
   schema: [{
       name: &quot;Musicians&quot;,
       fields: [
           { name: &quot;Name&quot;, type: &quot;string&quot;, primary: true },
           { name: &quot;DateOfBirth&quot;, type: &quot;datetime&quot; },
           { name: &quot;GreatestHits&quot;, type: &quot;string_v&quot; }
       ]
   }]
});
// create some records
base.store(&quot;Musicians&quot;).push({ Name: &quot;Jimmy Page&quot;, DateOfBirth:  &quot;1944-01-09T00:00:00&quot;, GreatestHits: [&quot;Stairway to Heaven&quot;, &quot;Whole Lotta Love&quot;] });
base.store(&quot;Musicians&quot;).push({ Name: &quot;Beyonce&quot;, DateOfBirth: &quot;1981-09-04T00:00:00&quot;, GreatestHits: [&quot;Single Ladies (Put a Ring on It)&quot;] });
// create a record set out of the records in the &quot;Musicians&quot; store
var recordSet &#x3D; base.store(&quot;Musicians&quot;).allRecords;
// create a JSON object out of the record set
var json &#x3D; recordSet.toJSON();
base.close();</code></pre>
                </div>
              </section>
              <dl class="dl-compact">
                <dt>Returns</dt>
                <dd>
                  <p><code>Object</code>B The record set as a JSON.</p>
                </dd>
              </dl>
              <h3 id="trunc"><span class="symbol-name">trunc</span><span class="signature"><span class="signature-params">(limit_num[, offset_num])</span>&nbsp;&rarr; <span class="signature-returns"> <a href="module-qm.RecordSet.html">module:qm.RecordSet</a></span></span></h3>
              <p>Truncates the first records.</p>
              <section>
                <h4>
                  Example
                </h4>
                <div>
                  <pre class="prettyprint"><code>// import qm module
var qm &#x3D; require(&#x27;qminer&#x27;);
// create a new base containing one store
var base &#x3D; new qm.Base({
   mode: &quot;createClean&quot;,
   schema: [{
       name: &quot;Philosophers&quot;,
       fields: [
           { name: &quot;Name&quot;, type: &quot;string&quot; },
           { name: &quot;Era&quot;, type: &quot;string&quot; }
       ]
   }]
});
// put some records in the store
base.store(&quot;Philosophers&quot;).push({ Name: &quot;Plato&quot;, Era: &quot;Ancient philosophy&quot; });
base.store(&quot;Philosophers&quot;).push({ Name: &quot;Immanuel Kant&quot;, Era: &quot;18th-century philosophy&quot; });
base.store(&quot;Philosophers&quot;).push({ Name: &quot;Emmanuel Levinas&quot;, Era: &quot;20th-century philosophy&quot; });
base.store(&quot;Philosophers&quot;).push({ Name: &quot;Rene Descartes&quot;, Era: &quot;17th-century philosophy&quot; });
base.store(&quot;Philosophers&quot;).push({ Name: &quot;Confucius&quot;, Era: &quot;Ancient philosophy&quot; });
// create two identical record sets of the &quot;Philosophers&quot; store
var recordSet1 &#x3D; base.store(&quot;Philosophers&quot;).allRecords;
var recordSet2 &#x3D; base.store(&quot;Philosophers&quot;).allRecords;
// truncate the first 3 records in recordSet1
recordSet1.trunc(3); // return self, containing only the first 3 records (&quot;Plato&quot;, &quot;Immanuel Kant&quot;, &quot;Emmanuel Levinas&quot;)
// truncate the first 2 records in recordSet2, starting with &quot;Emmanuel Levinas&quot;
recordSet2.trunc(2, 2); // returns self, containing only the 2 records (&quot;Emmanuel Levinas&quot;, &quot;Rene Descartes&quot;)
base.close();</code></pre>
                </div>
              </section>
              <section>
                <h4>Parameters</h4>
                <table class="jsdoc-details-table">
                  <thead>
                    <tr>
                      <th>Name</th>
                      <th>Type</th>
                      <th>Optional</th>
                      <th>Description</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <p>limit_num</p>
                      </td>
                      <td>
                        <p>number</p>
                      </td>
                      <td>
                        <p>&nbsp;</p>
                      </td>
                      <td>
                        <p>How many records to truncate.</p>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <p>offset_num</p>
                      </td>
                      <td>
                        <p>number</p>
                      </td>
                      <td>
                        <p>Yes</p>
                      </td>
                      <td>
                        <p>Where to start to truncate.</p>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </section>
              <dl class="dl-compact">
                <dt>Returns</dt>
                <dd>
                  <p><code><a href="module-qm.RecordSet.html">module:qm.RecordSet</a></code>B Self.</p>
                </dd>
              </dl>
            </section>
          </section>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
  <footer id="jsdoc-footer" class="jsdoc-footer">
    <div id="jsdoc-footer-container">
      <p>
        
      </p>
    </div>
  </footer>
  <script src="scripts/jquery.min.js"></script>
  <script src="scripts/tree.jquery.js"></script>
  <script src="scripts/prettify.js"></script>
  <script src="scripts/jsdoc-toc.js"></script>
  <script src="scripts/linenumber.js"></script>
  <script src="scripts/scrollanchor.js"></script>
</body>

</html>